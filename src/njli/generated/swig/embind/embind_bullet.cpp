/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.11
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */
#include <emscripten/bind.h>
using namespace emscripten;


#ifndef SWIGEMBIND
#define SWIGEMBIND
#endif


#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if defined(__GNUC__)
#  if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#    ifndef GCC_HASCLASSVISIBILITY
#      define GCC_HASCLASSVISIBILITY
#    endif
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif

/* Deal with Apple's deprecated 'AssertMacros.h' from Carbon-framework */
#if defined(__APPLE__) && !defined(__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES)
# define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
#endif

/* Intel's compiler complains if a variable which was never initialised is
 * cast to void, which is a common idiom which we use to indicate that we
 * are aware a variable isn't used.  So we just silence that warning.
 * See: https://github.com/swig/swig/issues/192 for more discussion.
 */
#ifdef __INTEL_COMPILER
# pragma warning disable 592
#endif


#define SWIGVERSION 0x030011 
#define SWIG_VERSION SWIGVERSION


#define SWIG_as_voidptr(a) (void *)((const void *)(a)) 
#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),(void**)(a)) 


#ifdef __cplusplus	/* generic alloc/dealloc fns*/
#define SWIG_ALLOC_ARRAY(TYPE,LEN) 	new TYPE[LEN]
#define SWIG_FREE_ARRAY(PTR)		delete[] PTR
#else
#define SWIG_ALLOC_ARRAY(TYPE,LEN) 	(TYPE *)malloc(LEN*sizeof(TYPE))
#define SWIG_FREE_ARRAY(PTR)		free(PTR)
#endif
/* counting the size of arrays:*/
SWIGINTERN int SWIG_itable_size(lua_State* L, int index)
{
	int n=0;
	while(1){
		lua_rawgeti(L,index,n+1);
		if (lua_isnil(L,-1))break;
		++n;
		lua_pop(L,1);
	}
	lua_pop(L,1);
	return n;
}

SWIGINTERN int SWIG_table_size(lua_State* L, int index)
{
	int n=0;
	lua_pushnil(L);  /* first key*/
	while (lua_next(L, index) != 0) {
		++n;
		lua_pop(L, 1);  /* removes `value'; keeps `key' for next iteration*/
	}
	return n;
}

/* super macro to declare array typemap helper fns */
#define SWIG_DECLARE_TYPEMAP_ARR_FN(NAME,TYPE)\
	SWIGINTERN int SWIG_read_##NAME##_num_array(lua_State* L,int index,TYPE *array,int size){\
		int i;\
		for (i = 0; i < size; i++) {\
			lua_rawgeti(L,index,i+1);\
			if (lua_isnumber(L,-1)){\
				array[i] = (TYPE)lua_tonumber(L,-1);\
			} else {\
				lua_pop(L,1);\
				return 0;\
			}\
			lua_pop(L,1);\
		}\
		return 1;\
	}\
	SWIGINTERN TYPE* SWIG_get_##NAME##_num_array_fixed(lua_State* L, int index, int size){\
		TYPE *array;\
		if (!lua_istable(L,index) || SWIG_itable_size(L,index) != size) {\
			SWIG_Lua_pushferrstring(L,"expected a table of size %d",size);\
			return 0;\
		}\
		array=SWIG_ALLOC_ARRAY(TYPE,size);\
		if (!SWIG_read_##NAME##_num_array(L,index,array,size)){\
			SWIG_Lua_pusherrstring(L,"table must contain numbers");\
			SWIG_FREE_ARRAY(array);\
			return 0;\
		}\
		return array;\
	}\
	SWIGINTERN TYPE* SWIG_get_##NAME##_num_array_var(lua_State* L, int index, int* size)\
	{\
		TYPE *array;\
		if (!lua_istable(L,index)) {\
			SWIG_Lua_pusherrstring(L,"expected a table");\
			return 0;\
		}\
		*size=SWIG_itable_size(L,index);\
		if (*size<1){\
			SWIG_Lua_pusherrstring(L,"table appears to be empty");\
			return 0;\
		}\
		array=SWIG_ALLOC_ARRAY(TYPE,*size);\
		if (!SWIG_read_##NAME##_num_array(L,index,array,*size)){\
			SWIG_Lua_pusherrstring(L,"table must contain numbers");\
			SWIG_FREE_ARRAY(array);\
			return 0;\
		}\
		return array;\
	}\
	SWIGINTERN void SWIG_write_##NAME##_num_array(lua_State* L,TYPE *array,int size){\
		int i;\
		lua_newtable(L);\
		for (i = 0; i < size; i++){\
			lua_pushnumber(L,(lua_Number)array[i]);\
			lua_rawseti(L,-2,i+1);/* -1 is the number, -2 is the table*/ \
		}\
	}

SWIG_DECLARE_TYPEMAP_ARR_FN(schar,signed char)
SWIG_DECLARE_TYPEMAP_ARR_FN(uchar,unsigned char)
SWIG_DECLARE_TYPEMAP_ARR_FN(int,int)
SWIG_DECLARE_TYPEMAP_ARR_FN(uint,unsigned int)
SWIG_DECLARE_TYPEMAP_ARR_FN(short,short)
SWIG_DECLARE_TYPEMAP_ARR_FN(ushort,unsigned short)
SWIG_DECLARE_TYPEMAP_ARR_FN(long,long)
SWIG_DECLARE_TYPEMAP_ARR_FN(ulong,unsigned long)
SWIG_DECLARE_TYPEMAP_ARR_FN(float,float)
SWIG_DECLARE_TYPEMAP_ARR_FN(double,double)

SWIGINTERN int SWIG_read_ptr_array(lua_State* L,int index,void **array,int size,swig_type_info *type){
	int i;
	for (i = 0; i < size; i++) {
		lua_rawgeti(L,index,i+1);
		if (!lua_isuserdata(L,-1) || SWIG_ConvertPtr(L,-1,&array[i],type,0)==-1){
			lua_pop(L,1);
			return 0;
		}
		lua_pop(L,1);
	}
	return 1;
}
SWIGINTERN void** SWIG_get_ptr_array_fixed(lua_State* L, int index, int size,swig_type_info *type){
	void **array;
	if (!lua_istable(L,index) || SWIG_itable_size(L,index) != size) {
		SWIG_Lua_pushferrstring(L,"expected a table of size %d",size);
		return 0;
	}
	array=SWIG_ALLOC_ARRAY(void*,size);
	if (!SWIG_read_ptr_array(L,index,array,size,type)){
		SWIG_Lua_pushferrstring(L,"table must contain pointers of type %s",type->name);
		SWIG_FREE_ARRAY(array);
		return 0;
	}
	return array;
}
SWIGINTERN void** SWIG_get_ptr_array_var(lua_State* L, int index, int* size,swig_type_info *type){
	void **array;
	if (!lua_istable(L,index)) {
		SWIG_Lua_pusherrstring(L,"expected a table");
		return 0;
	}
	*size=SWIG_itable_size(L,index);
	if (*size<1){
		SWIG_Lua_pusherrstring(L,"table appears to be empty");
		return 0;
	}
	array=SWIG_ALLOC_ARRAY(void*,*size);
	if (!SWIG_read_ptr_array(L,index,array,*size,type)){
		SWIG_Lua_pushferrstring(L,"table must contain pointers of type %s",type->name);
		SWIG_FREE_ARRAY(array);
		return 0;
	}
	return array;
}
SWIGINTERN void SWIG_write_ptr_array(lua_State* L,void **array,int size,swig_type_info *type,int own){
	int i;
	lua_newtable(L);
	for (i = 0; i < size; i++){
		SWIG_NewPointerObj(L,array[i],type,own);
		lua_rawseti(L,-2,i+1);/* -1 is the number, -2 is the table*/
	}
}


#include <string>


#undef SWIG_fail_arg
#define SWIG_fail_arg(func_name,argnum,type) \
{lua_Debug ar;\
lua_getstack(L, 1, &ar);\
lua_getinfo(L, "nSl", &ar);\
lua_pushfstring(L,"Error (%s:%d) in %s (arg %d), expected '%s' got '%s'",\
ar.source,ar.currentline,func_name,argnum,type,SWIG_Lua_typename(L,argnum));\
goto fail;}
    

#undef SWIG_check_num_args
#define SWIG_check_num_args(func_name,a,b) \
if(LUA_WRAPPER_LOGGING){\
lua_Debug ar;\
lua_getstack(L, 1, &ar);\
lua_getinfo(L, "nSl", &ar);\
printf("(%s:%d) in %s",\
ar.short_src,ar.currentline,ar.name); \
}\
if (lua_gettop(L)<a || lua_gettop(L)>b) \
{SWIG_Lua_pushferrstring(L,"Error in %s expected %d..%d args, got %d",func_name,a,b,lua_gettop(L));\
goto fail;}
    

    #include "btPrint.h"
    #include "btVector2.h"
    //#include "btClock.h"
    #include "BulletCollision/BroadphaseCollision/btBroadphaseInterface.h"
    #include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"
    #include "BulletCollision/BroadphaseCollision/btCollisionAlgorithm.h"
    #include "BulletCollision/BroadphaseCollision/btDbvt.h"
    #include "BulletCollision/BroadphaseCollision/btDbvtBroadphase.h"
    #include "BulletCollision/BroadphaseCollision/btDispatcher.h"
    //#include "BulletCollision/BroadphaseCollision/btMultiSapBroadphase.h"
    #include "BulletCollision/BroadphaseCollision/btOverlappingPairCache.h"
    #include "BulletCollision/BroadphaseCollision/btOverlappingPairCallback.h"
    #include "BulletCollision/BroadphaseCollision/btQuantizedBvh.h"
    #include "BulletCollision/BroadphaseCollision/btSimpleBroadphase.h"
    #include "BulletCollision/CollisionDispatch/btActivatingCollisionAlgorithm.h"
    #include "BulletCollision/CollisionDispatch/btBox2dBox2dCollisionAlgorithm.h"
    #include "BulletCollision/CollisionDispatch/btBoxBoxCollisionAlgorithm.h"
    #include "BulletCollision/CollisionDispatch/btBoxBoxDetector.h"
    #include "BulletCollision/CollisionDispatch/btCollisionConfiguration.h"
    #include "BulletCollision/CollisionDispatch/btCollisionCreateFunc.h"
    #include "BulletCollision/CollisionDispatch/btCollisionDispatcher.h"
    #include "BulletCollision/CollisionDispatch/btCollisionObject.h"
    #include "BulletCollision/CollisionDispatch/btCollisionObjectWrapper.h"
    #include "BulletCollision/CollisionDispatch/btCollisionWorld.h"
    #include "BulletCollision/CollisionDispatch/btCompoundCollisionAlgorithm.h"
    #include "BulletCollision/CollisionDispatch/btCompoundCompoundCollisionAlgorithm.h"
    #include "BulletCollision/CollisionDispatch/btConvex2dConvex2dAlgorithm.h"
    #include "BulletCollision/CollisionDispatch/btConvexConcaveCollisionAlgorithm.h"
    #include "BulletCollision/CollisionDispatch/btConvexConvexAlgorithm.h"
    #include "BulletCollision/CollisionDispatch/btConvexPlaneCollisionAlgorithm.h"
    #include "BulletCollision/CollisionDispatch/btDefaultCollisionConfiguration.h"
    #include "BulletCollision/CollisionDispatch/btEmptyCollisionAlgorithm.h"
    #include "BulletCollision/CollisionDispatch/btGhostObject.h"
    #include "BulletCollision/CollisionDispatch/btHashedSimplePairCache.h"
    #include "BulletCollision/CollisionDispatch/btInternalEdgeUtility.h"
    #include "BulletCollision/CollisionDispatch/btManifoldResult.h"
    #include "BulletCollision/CollisionDispatch/btSimulationIslandManager.h"
    #include "BulletCollision/CollisionDispatch/btSphereBoxCollisionAlgorithm.h"
    #include "BulletCollision/CollisionDispatch/btSphereSphereCollisionAlgorithm.h"
    #include "BulletCollision/CollisionDispatch/btSphereTriangleCollisionAlgorithm.h"
    #include "BulletCollision/CollisionDispatch/btUnionFind.h"
    #include "BulletCollision/CollisionDispatch/SphereTriangleDetector.h"
    #include "BulletCollision/CollisionShapes/btBox2dShape.h"
    #include "BulletCollision/CollisionShapes/btBoxShape.h"
    #include "BulletCollision/CollisionShapes/btBvhTriangleMeshShape.h"
    #include "BulletCollision/CollisionShapes/btCapsuleShape.h"
    #include "BulletCollision/CollisionShapes/btCollisionMargin.h"
    #include "BulletCollision/CollisionShapes/btCollisionShape.h"
    #include "BulletCollision/CollisionShapes/btCompoundShape.h"
    #include "BulletCollision/CollisionShapes/btConcaveShape.h"
    #include "BulletCollision/CollisionShapes/btConeShape.h"
    #include "BulletCollision/CollisionShapes/btConvex2dShape.h"
    #include "BulletCollision/CollisionShapes/btConvexHullShape.h"
    #include "BulletCollision/CollisionShapes/btConvexInternalShape.h"
    #include "BulletCollision/CollisionShapes/btConvexPointCloudShape.h"
    #include "BulletCollision/CollisionShapes/btConvexPolyhedron.h"
    #include "BulletCollision/CollisionShapes/btConvexShape.h"
    #include "BulletCollision/CollisionShapes/btConvexTriangleMeshShape.h"
    #include "BulletCollision/CollisionShapes/btCylinderShape.h"
    #include "BulletCollision/CollisionShapes/btEmptyShape.h"
    #include "BulletCollision/CollisionShapes/btHeightfieldTerrainShape.h"
    #include "BulletCollision/CollisionShapes/btMaterial.h"
    #include "BulletCollision/CollisionShapes/btMinkowskiSumShape.h"
    #include "BulletCollision/CollisionShapes/btMultimaterialTriangleMeshShape.h"
    #include "BulletCollision/CollisionShapes/btMultiSphereShape.h"
    #include "BulletCollision/CollisionShapes/btOptimizedBvh.h"
    #include "BulletCollision/CollisionShapes/btPolyhedralConvexShape.h"
    #include "BulletCollision/CollisionShapes/btScaledBvhTriangleMeshShape.h"
    #include "BulletCollision/CollisionShapes/btShapeHull.h"
    #include "BulletCollision/CollisionShapes/btSphereShape.h"
    #include "BulletCollision/CollisionShapes/btStaticPlaneShape.h"
    #include "BulletCollision/CollisionShapes/btStridingMeshInterface.h"
    #include "BulletCollision/CollisionShapes/btTetrahedronShape.h"
    #include "BulletCollision/CollisionShapes/btTriangleBuffer.h"
    #include "BulletCollision/CollisionShapes/btTriangleCallback.h"
    #include "BulletCollision/CollisionShapes/btTriangleIndexVertexArray.h"
    #include "BulletCollision/CollisionShapes/btTriangleIndexVertexMaterialArray.h"
    #include "BulletCollision/CollisionShapes/btTriangleInfoMap.h"
    #include "BulletCollision/CollisionShapes/btTriangleMesh.h"
    #include "BulletCollision/CollisionShapes/btTriangleMeshShape.h"
    #include "BulletCollision/CollisionShapes/btTriangleShape.h"
    #include "BulletCollision/CollisionShapes/btUniformScalingShape.h"
    #include "BulletCollision/NarrowPhaseCollision/btContinuousConvexCollision.h"
    #include "BulletCollision/NarrowPhaseCollision/btConvexCast.h"
    #include "BulletCollision/NarrowPhaseCollision/btConvexPenetrationDepthSolver.h"
    #include "BulletCollision/NarrowPhaseCollision/btDiscreteCollisionDetectorInterface.h"
    #include "BulletCollision/NarrowPhaseCollision/btGjkConvexCast.h"
    #include "BulletCollision/NarrowPhaseCollision/btGjkEpa2.h"
    #include "BulletCollision/NarrowPhaseCollision/btGjkEpaPenetrationDepthSolver.h"
    #include "BulletCollision/NarrowPhaseCollision/btGjkPairDetector.h"
    #include "BulletCollision/NarrowPhaseCollision/btManifoldPoint.h"
    #include "BulletCollision/NarrowPhaseCollision/btMinkowskiPenetrationDepthSolver.h"
    #include "BulletCollision/NarrowPhaseCollision/btPersistentManifold.h"
    #include "BulletCollision/NarrowPhaseCollision/btPointCollector.h"
    #include "BulletCollision/NarrowPhaseCollision/btPolyhedralContactClipping.h"
    #include "BulletCollision/NarrowPhaseCollision/btRaycastCallback.h"
    #include "BulletCollision/NarrowPhaseCollision/btSimplexSolverInterface.h"
    #include "BulletCollision/NarrowPhaseCollision/btSubSimplexConvexCast.h"
    #include "BulletCollision/NarrowPhaseCollision/btVoronoiSimplexSolver.h"
    #include "BulletDynamics/Character/btCharacterControllerInterface.h"
    #include "BulletDynamics/Character/btKinematicCharacterController.h"
    #include "BulletDynamics/ConstraintSolver/btConeTwistConstraint.h"
    #include "BulletDynamics/ConstraintSolver/btConstraintSolver.h"
    #include "BulletDynamics/ConstraintSolver/btContactConstraint.h"
    #include "BulletDynamics/ConstraintSolver/btContactSolverInfo.h"
    #include "BulletDynamics/ConstraintSolver/btFixedConstraint.h"
    #include "BulletDynamics/ConstraintSolver/btGearConstraint.h"
    #include "BulletDynamics/ConstraintSolver/btGeneric6DofConstraint.h"
    #include "BulletDynamics/ConstraintSolver/btGeneric6DofSpringConstraint.h"
    #include "BulletDynamics/ConstraintSolver/btHinge2Constraint.h"
    #include "BulletDynamics/ConstraintSolver/btHingeConstraint.h"
    #include "BulletDynamics/ConstraintSolver/btJacobianEntry.h"
    #include "BulletDynamics/ConstraintSolver/btPoint2PointConstraint.h"
    #include "BulletDynamics/ConstraintSolver/btSequentialImpulseConstraintSolver.h"
    #include "BulletDynamics/ConstraintSolver/btSliderConstraint.h"
    #include "BulletDynamics/ConstraintSolver/btSolve2LinearConstraint.h"
    #include "BulletDynamics/ConstraintSolver/btSolverBody.h"
    #include "BulletDynamics/ConstraintSolver/btSolverConstraint.h"
    #include "BulletDynamics/ConstraintSolver/btTypedConstraint.h"
    #include "BulletDynamics/ConstraintSolver/btUniversalConstraint.h"
    #include "BulletDynamics/Dynamics/btActionInterface.h"
    #include "BulletDynamics/Dynamics/btDiscreteDynamicsWorld.h"
    #include "BulletDynamics/Dynamics/btDynamicsWorld.h"
    #include "BulletDynamics/Dynamics/btRigidBody.h"
    #include "BulletDynamics/Dynamics/btSimpleDynamicsWorld.h"
    #include "BulletDynamics/Featherstone/btMultiBody.h"
    #include "BulletDynamics/Featherstone/btMultiBodyConstraint.h"
    #include "BulletDynamics/Featherstone/btMultiBodyConstraintSolver.h"
    #include "BulletDynamics/Featherstone/btMultiBodyDynamicsWorld.h"
    #include "BulletDynamics/Featherstone/btMultiBodyJointLimitConstraint.h"
    #include "BulletDynamics/Featherstone/btMultiBodyJointMotor.h"
    #include "BulletDynamics/Featherstone/btMultiBodyLink.h"
    #include "BulletDynamics/Featherstone/btMultiBodyLinkCollider.h"
    #include "BulletDynamics/Featherstone/btMultiBodyPoint2Point.h"
    #include "BulletDynamics/Featherstone/btMultiBodySolverConstraint.h"
    #include "BulletDynamics/MLCPSolvers/btDantzigLCP.h"
    #include "BulletDynamics/MLCPSolvers/btDantzigSolver.h"
    #include "BulletDynamics/MLCPSolvers/btMLCPSolver.h"
    #include "BulletDynamics/MLCPSolvers/btMLCPSolverInterface.h"
    #include "BulletDynamics/MLCPSolvers/btPATHSolver.h"
    #include "BulletDynamics/MLCPSolvers/btSolveProjectedGaussSeidel.h"
    #include "BulletDynamics/Vehicle/btRaycastVehicle.h"
    #include "BulletDynamics/Vehicle/btVehicleRaycaster.h"
    #include "BulletDynamics/Vehicle/btWheelInfo.h"
    #include "BulletSoftBody/btDefaultSoftBodySolver.h"
    #include "BulletSoftBody/btSoftBody.h"
    #include "BulletSoftBody/btSoftBodyConcaveCollisionAlgorithm.h"
    #include "BulletSoftBody/btSoftBodyData.h"
    #include "BulletSoftBody/btSoftBodyHelpers.h"
    #include "BulletSoftBody/btSoftBodyInternals.h"
    #include "BulletSoftBody/btSoftBodyRigidBodyCollisionConfiguration.h"
    #include "BulletSoftBody/btSoftBodySolvers.h"
    #include "BulletSoftBody/btSoftBodySolverVertexBuffer.h"
    #include "BulletSoftBody/btSoftRigidCollisionAlgorithm.h"
    #include "BulletSoftBody/btSoftRigidDynamicsWorld.h"
    #include "BulletSoftBody/btSoftSoftCollisionAlgorithm.h"
    #include "BulletSoftBody/btSparseSDF.h"
    #include "LinearMath/btAabbUtil2.h"
    #include "LinearMath/btAlignedAllocator.h"
    #include "LinearMath/btAlignedObjectArray.h"
    #include "LinearMath/btConvexHull.h"
    #include "LinearMath/btConvexHullComputer.h"
    #include "LinearMath/btDefaultMotionState.h"
    #include "LinearMath/btGeometryUtil.h"
    #include "LinearMath/btGrahamScan2dConvexHull.h"
    #include "LinearMath/btHashMap.h"
    #include "LinearMath/btIDebugDraw.h"
    #include "LinearMath/btList.h"
    #include "LinearMath/btMatrix3x3.h"
    #include "LinearMath/btMatrixX.h"
    #include "LinearMath/btMinMax.h"
    #include "LinearMath/btMotionState.h"
    #include "LinearMath/btPolarDecomposition.h"
    #include "LinearMath/btPoolAllocator.h"
    #include "LinearMath/btQuadWord.h"
    #include "LinearMath/btQuaternion.h"
    #include "LinearMath/btQuickprof.h"
    #include "LinearMath/btRandom.h"
    #include "LinearMath/btScalar.h"
    #include "LinearMath/btSerializer.h"
    #include "LinearMath/btStackAlloc.h"
    #include "LinearMath/btTransform.h"
    #include "LinearMath/btTransformUtil.h"
    #include "LinearMath/btVector3.h"


static btManifoldPoint *new_btManifoldPointArray(int nelements) { 
  return new btManifoldPoint[nelements](); 
}

static void delete_btManifoldPointArray(btManifoldPoint *ary) { 
  delete [] ary; 
}

static btManifoldPoint btManifoldPointArray_getitem(btManifoldPoint *ary, int index) {
    return ary[index];
}
static void btManifoldPointArray_setitem(btManifoldPoint *ary, int index, btManifoldPoint value) {
    ary[index] = value;
}


static btMatrix3x3 *new_btMatrix3x3Array(int nelements) { 
  return new btMatrix3x3[nelements](); 
}

static void delete_btMatrix3x3Array(btMatrix3x3 *ary) { 
  delete [] ary; 
}

static btMatrix3x3 btMatrix3x3Array_getitem(btMatrix3x3 *ary, int index) {
    return ary[index];
}
static void btMatrix3x3Array_setitem(btMatrix3x3 *ary, int index, btMatrix3x3 value) {
    ary[index] = value;
}


static btQuaternion *new_btQuaternionArray(int nelements) { 
  return new btQuaternion[nelements](); 
}

static void delete_btQuaternionArray(btQuaternion *ary) { 
  delete [] ary; 
}

static btQuaternion btQuaternionArray_getitem(btQuaternion *ary, int index) {
    return ary[index];
}
static void btQuaternionArray_setitem(btQuaternion *ary, int index, btQuaternion value) {
    ary[index] = value;
}


static btTransform *new_btTransformArray(int nelements) { 
  return new btTransform[nelements](); 
}

static void delete_btTransformArray(btTransform *ary) { 
  delete [] ary; 
}

static btTransform btTransformArray_getitem(btTransform *ary, int index) {
    return ary[index];
}
static void btTransformArray_setitem(btTransform *ary, int index, btTransform value) {
    ary[index] = value;
}


static btVector2 *new_btVector2Array(int nelements) { 
  return new btVector2[nelements](); 
}

static void delete_btVector2Array(btVector2 *ary) { 
  delete [] ary; 
}

static btVector2 btVector2Array_getitem(btVector2 *ary, int index) {
    return ary[index];
}
static void btVector2Array_setitem(btVector2 *ary, int index, btVector2 value) {
    ary[index] = value;
}


static btVector3 *new_btVector3Array(int nelements) { 
  return new btVector3[nelements](); 
}

static void delete_btVector3Array(btVector3 *ary) { 
  delete [] ary; 
}

static btVector3 btVector3Array_getitem(btVector3 *ary, int index) {
    return ary[index];
}
static void btVector3Array_setitem(btVector3 *ary, int index, btVector3 value) {
    ary[index] = value;
}


static btVector4 *new_btVector4Array(int nelements) { 
  return new btVector4[nelements](); 
}

static void delete_btVector4Array(btVector4 *ary) { 
  delete [] ary; 
}

static btVector4 btVector4Array_getitem(btVector4 *ary, int index) {
    return ary[index];
}
static void btVector4Array_setitem(btVector4 *ary, int index, btVector4 value) {
    ary[index] = value;
}


static btScalar *new_btScalarArray(int nelements) { 
  return new btScalar[nelements](); 
}

static void delete_btScalarArray(btScalar *ary) { 
  delete [] ary; 
}

static btScalar btScalarArray_getitem(btScalar *ary, int index) {
    return ary[index];
}
static void btScalarArray_setitem(btScalar *ary, int index, btScalar value) {
    ary[index] = value;
}

EMSCRIPTEN_BINDINGS(bullet) {
	function("new_btManifoldPointArray", &new_btManifoldPointArray, allow_raw_pointers());
	function("delete_btManifoldPointArray", &delete_btManifoldPointArray);
	function("btManifoldPointArray_getitem", &btManifoldPointArray_getitem);
	function("btManifoldPointArray_setitem", &btManifoldPointArray_setitem);
	function("new_btMatrix3x3Array", &new_btMatrix3x3Array, allow_raw_pointers());
	function("delete_btMatrix3x3Array", &delete_btMatrix3x3Array);
	function("btMatrix3x3Array_getitem", &btMatrix3x3Array_getitem);
	function("btMatrix3x3Array_setitem", &btMatrix3x3Array_setitem);
	function("new_btQuaternionArray", &new_btQuaternionArray, allow_raw_pointers());
	function("delete_btQuaternionArray", &delete_btQuaternionArray);
	function("btQuaternionArray_getitem", &btQuaternionArray_getitem);
	function("btQuaternionArray_setitem", &btQuaternionArray_setitem);
	function("new_btTransformArray", &new_btTransformArray, allow_raw_pointers());
	function("delete_btTransformArray", &delete_btTransformArray);
	function("btTransformArray_getitem", &btTransformArray_getitem);
	function("btTransformArray_setitem", &btTransformArray_setitem);
	function("new_btVector2Array", &new_btVector2Array, allow_raw_pointers());
	function("delete_btVector2Array", &delete_btVector2Array);
	function("btVector2Array_getitem", &btVector2Array_getitem);
	function("btVector2Array_setitem", &btVector2Array_setitem);
	function("new_btVector3Array", &new_btVector3Array, allow_raw_pointers());
	function("delete_btVector3Array", &delete_btVector3Array);
	function("btVector3Array_getitem", &btVector3Array_getitem);
	function("btVector3Array_setitem", &btVector3Array_setitem);
	function("new_btVector4Array", &new_btVector4Array, allow_raw_pointers());
	function("delete_btVector4Array", &delete_btVector4Array);
	function("btVector4Array_getitem", &btVector4Array_getitem);
	function("btVector4Array_setitem", &btVector4Array_setitem);
	function("new_btScalarArray", &new_btScalarArray, allow_raw_pointers());
	function("delete_btScalarArray", &delete_btScalarArray);
	function("btScalarArray_getitem", &btScalarArray_getitem);
	function("btScalarArray_setitem", &btScalarArray_setitem);
	constant("btVector3Zero", btVector3Zero);
	function("btGetVersion", &btGetVersion);
	function("btSqrt", &btSqrt);
	function("btFabs", &btFabs);
	function("btCos", &btCos);
	function("btSin", &btSin);
	function("btTan", &btTan);
	function("btAcos", &btAcos);
	function("btAsin", &btAsin);
	function("btAtan", &btAtan);
	function("btAtan2", &btAtan2);
	function("btExp", &btExp);
	function("btLog", &btLog);
	function("btPow", &btPow);
	function("btFmod", &btFmod);
	function("btAtan2Fast", &btAtan2Fast);
	function("btFuzzyZero", &btFuzzyZero);
	function("btEqual", &btEqual);
	function("btGreaterEqual", &btGreaterEqual);
	function("btIsNegative", &btIsNegative);
	function("btRadians", &btRadians);
	function("btDegrees", &btDegrees);
	function("btFsel", &btFsel);
	function("btMachineIsLittleEndian", &btMachineIsLittleEndian);
	function("btSelect", &btSelect);
	function("btSwapEndian", &btSwapEndian);
	function("btSwapEndianFloat", &btSwapEndianFloat);
	function("btUnswapEndianFloat", &btUnswapEndianFloat);
	function("btSwapEndianDouble", &btSwapEndianDouble);
	function("btUnswapEndianDouble", &btUnswapEndianDouble);
	function("btLargeDot", &btLargeDot);
	function("btNormalizeAngle", &btNormalizeAngle);
	class_<btTypedObject>("btTypedObject")
	.constructor<int>()
	constant("m_objectType", m_objectType);
	.function("getObjectType", &btTypedObject::getObjectType)
	;
	function("btAlignedAllocInternal", &btAlignedAllocInternal, allow_raw_pointers());
	function("btAlignedFreeInternal", &btAlignedFreeInternal);
	function("btAlignedAllocSetCustom", &btAlignedAllocSetCustom);
	function("btAlignedAllocSetCustomAligned", &btAlignedAllocSetCustomAligned);
	class_<btVector3>("btVector3")
	.constructor<r.q(const).btScalar,r.q(const).btScalar,r.q(const).btScalar>()
	.function("dot", &btVector3::dot)
	.function("length2", &btVector3::length2)
	.function("length", &btVector3::length)
	.function("norm", &btVector3::norm)
	.function("safeNorm", &btVector3::safeNorm)
	.function("distance2", &btVector3::distance2)
	.function("distance", &btVector3::distance)
	.function("safeNormalize", &btVector3::safeNormalize)
	.function("normalize", &btVector3::normalize)
	.function("normalized", &btVector3::normalized)
	.function("rotate", &btVector3::rotate)
	.function("angle", &btVector3::angle)
	.function("absolute", &btVector3::absolute)
	.function("cross", &btVector3::cross)
	.function("triple", &btVector3::triple)
	.function("minAxis", &btVector3::minAxis)
	.function("maxAxis", &btVector3::maxAxis)
	.function("furthestAxis", &btVector3::furthestAxis)
	.function("closestAxis", &btVector3::closestAxis)
	.function("setInterpolate3", &btVector3::setInterpolate3)
	.function("lerp", &btVector3::lerp)
	.function("getX", &btVector3::getX)
	.function("getY", &btVector3::getY)
	.function("getZ", &btVector3::getZ)
	.function("setX", &btVector3::setX)
	.function("setY", &btVector3::setY)
	.function("setZ", &btVector3::setZ)
	.function("setW", &btVector3::setW)
	.function("x", &btVector3::x)
	.function("y", &btVector3::y)
	.function("z", &btVector3::z)
	.function("w", &btVector3::w)
	.function("operator btScalar*", &btVector3::operator btScalar*)
	.function("operator const btScalar*", &btVector3::operator const btScalar*)
	.function("operator ==_r.q(const).btVector3", select_overload<bool(r.q(const).btVector3)const>(&btVector3::operator ==))
	.function("setMax", &btVector3::setMax)
	.function("setMin", &btVector3::setMin)
	.function("setValue", &btVector3::setValue)
	.function("getSkewSymmetricMatrix", &btVector3::getSkewSymmetricMatrix)
	.function("setZero", &btVector3::setZero)
	.function("isZero", &btVector3::isZero)
	.function("fuzzyZero", &btVector3::fuzzyZero)
	.function("serialize", &btVector3::serialize)
	.function("deSerialize", &btVector3::deSerialize)
	.function("serializeFloat", &btVector3::serializeFloat)
	.function("deSerializeFloat", &btVector3::deSerializeFloat)
	.function("serializeDouble", &btVector3::serializeDouble)
	.function("deSerializeDouble", &btVector3::deSerializeDouble)
	.function("maxDot", &btVector3::maxDot)
	.function("minDot", &btVector3::minDot)
	.function("dot3", &btVector3::dot3)
	.function("__str__", &btVector3::__str__)
	.constructor<r.q(const).btVector3>()
	.function("__add__", &btVector3::__add__)
	.function("__sub__", &btVector3::__sub__)
	.function("__mul___r.q(const).btVector3", select_overload<btVector3(r.q(const).btVector3)>(&btVector3::__mul__))
	.function("__mul___r.q(const).btMatrix3x3", select_overload<btVector3(r.q(const).btMatrix3x3)>(&btVector3::__mul__))
	.function("__mul___r.q(const).btScalar", select_overload<btVector3(r.q(const).btScalar)>(&btVector3::__mul__))
	.function("__mul___r.q(const).btQuaternion", select_overload<btQuaternion(r.q(const).btQuaternion)>(&btVector3::__mul__))
	.function("__div___r.q(const).btVector3", select_overload<btVector3(r.q(const).btVector3)>(&btVector3::__div__))
	.function("__div___r.q(const).btScalar", select_overload<btVector3(r.q(const).btScalar)>(&btVector3::__div__))
	.function("__neg__", &btVector3::__neg__)
	.function("__concat__", &btVector3::__concat__)
	.function("__eq___r.q(const).btVector3", select_overload<bool(r.q(const).btVector3)>(&btVector3::__eq__))
	.function("__lt__", &btVector3::__lt__)
	.function("__le__", &btVector3::__le__)
	;
	function("btDot", &btDot);
	function("btDistance2", &btDistance2);
	function("btDistance", &btDistance);
	function("btAngle", &btAngle);
	function("btCross", &btCross);
	function("btTriple", &btTriple);
	function("lerp", &lerp);
	class_<btVector4, base<btVector3>>("btVector4")
	.constructor<r.q(const).btScalar,r.q(const).btScalar,r.q(const).btScalar,r.q(const).btScalar>()
	.function("absolute4", &btVector4::absolute4)
	.function("getW", &btVector4::getW)
	.function("maxAxis4", &btVector4::maxAxis4)
	.function("minAxis4", &btVector4::minAxis4)
	.function("closestAxis4", &btVector4::closestAxis4)
	.function("setValue", &btVector4::setValue)
	.function("__str__", &btVector4::__str__)
	.constructor<r.q(const).btVector4>()
	.function("__concat__", &btVector4::__concat__)
	.function("__eq__", &btVector4::__eq__)
	.function("__lt__", &btVector4::__lt__)
	.function("__le__", &btVector4::__le__)
	;
	function("btSwapScalarEndian", &btSwapScalarEndian);
	function("btSwapVector3Endian", &btSwapVector3Endian);
	function("btUnSwapVector3Endian", &btUnSwapVector3Endian);
	class_<btVector3FloatData>("btVector3FloatData")
	constant("m_floats", m_floats);
	;
	class_<btVector3DoubleData>("btVector3DoubleData")
	constant("m_floats", m_floats);
	;
	class_<btVector2>("btVector2")
	.constructor<r.q(const).btScalar,r.q(const).btScalar>()
	.constructor<r.q(const).btVector2>()
	.constructor<r.q(const).btVector3>()
	.function("operator btVector3", &btVector2::operator btVector3)
	.function("operator const btScalar*", &btVector2::operator const btScalar*)
	.function("x", &btVector2::x)
	.function("y", &btVector2::y)
	.function("setX", &btVector2::setX)
	.function("setY", &btVector2::setY)
	.function("dot", &btVector2::dot)
	.function("length2", &btVector2::length2)
	.function("length", &btVector2::length)
	.function("distance2", &btVector2::distance2)
	.function("distance", &btVector2::distance)
	.function("normalize", &btVector2::normalize)
	.function("normalized", &btVector2::normalized)
	.function("rotate", &btVector2::rotate)
	.function("rotated", &btVector2::rotated)
	.function("absolute", &btVector2::absolute)
	.function("angle", &btVector2::angle)
	.function("serializeFloat", &btVector2::serializeFloat)
	.function("deSerializeFloat", &btVector2::deSerializeFloat)
	.function("serializeDouble", &btVector2::serializeDouble)
	.function("deSerializeDouble", &btVector2::deSerializeDouble)
	.function("serialize", &btVector2::serialize)
	.function("deSerialize", &btVector2::deSerialize)
	.function("__str__", &btVector2::__str__)
	.function("__add__", &btVector2::__add__)
	.function("__sub__", &btVector2::__sub__)
	.function("__mul___r.q(const).btVector2", select_overload<btVector2(r.q(const).btVector2)>(&btVector2::__mul__))
	.function("__mul___r.q(const).btScalar", select_overload<btVector2(r.q(const).btScalar)>(&btVector2::__mul__))
	.function("__div___r.q(const).btVector2", select_overload<btVector2(r.q(const).btVector2)>(&btVector2::__div__))
	.function("__div___r.q(const).btScalar", select_overload<btVector2(r.q(const).btScalar)>(&btVector2::__div__))
	.function("__neg__", &btVector2::__neg__)
	.function("__concat__", &btVector2::__concat__)
	.function("__eq__", &btVector2::__eq__)
	.function("__lt__", &btVector2::__lt__)
	.function("__le__", &btVector2::__le__)
	;
	function("dot", &dot);
	function("distance2", &distance2);
	function("distance", &distance);
	class_<btVector2FloatData>("btVector2FloatData")
	constant("xy_", xy_);
	;
	class_<btVector2DoubleData>("btVector2DoubleData")
	constant("xy_", xy_);
	;
	enum_<BroadphaseNativeTypes>("BroadphaseNativeTypes")
		.value("BOX_SHAPE_PROXYTYPE", BOX_SHAPE_PROXYTYPE)
		.value("TRIANGLE_SHAPE_PROXYTYPE", TRIANGLE_SHAPE_PROXYTYPE)
		.value("TETRAHEDRAL_SHAPE_PROXYTYPE", TETRAHEDRAL_SHAPE_PROXYTYPE)
		.value("CONVEX_TRIANGLEMESH_SHAPE_PROXYTYPE", CONVEX_TRIANGLEMESH_SHAPE_PROXYTYPE)
		.value("CONVEX_HULL_SHAPE_PROXYTYPE", CONVEX_HULL_SHAPE_PROXYTYPE)
		.value("CONVEX_POINT_CLOUD_SHAPE_PROXYTYPE", CONVEX_POINT_CLOUD_SHAPE_PROXYTYPE)
		.value("CUSTOM_POLYHEDRAL_SHAPE_TYPE", CUSTOM_POLYHEDRAL_SHAPE_TYPE)
		.value("IMPLICIT_CONVEX_SHAPES_START_HERE", IMPLICIT_CONVEX_SHAPES_START_HERE)
		.value("SPHERE_SHAPE_PROXYTYPE", SPHERE_SHAPE_PROXYTYPE)
		.value("MULTI_SPHERE_SHAPE_PROXYTYPE", MULTI_SPHERE_SHAPE_PROXYTYPE)
		.value("CAPSULE_SHAPE_PROXYTYPE", CAPSULE_SHAPE_PROXYTYPE)
		.value("CONE_SHAPE_PROXYTYPE", CONE_SHAPE_PROXYTYPE)
		.value("CONVEX_SHAPE_PROXYTYPE", CONVEX_SHAPE_PROXYTYPE)
		.value("CYLINDER_SHAPE_PROXYTYPE", CYLINDER_SHAPE_PROXYTYPE)
		.value("UNIFORM_SCALING_SHAPE_PROXYTYPE", UNIFORM_SCALING_SHAPE_PROXYTYPE)
		.value("MINKOWSKI_SUM_SHAPE_PROXYTYPE", MINKOWSKI_SUM_SHAPE_PROXYTYPE)
		.value("MINKOWSKI_DIFFERENCE_SHAPE_PROXYTYPE", MINKOWSKI_DIFFERENCE_SHAPE_PROXYTYPE)
		.value("BOX_2D_SHAPE_PROXYTYPE", BOX_2D_SHAPE_PROXYTYPE)
		.value("CONVEX_2D_SHAPE_PROXYTYPE", CONVEX_2D_SHAPE_PROXYTYPE)
		.value("CUSTOM_CONVEX_SHAPE_TYPE", CUSTOM_CONVEX_SHAPE_TYPE)
		.value("CONCAVE_SHAPES_START_HERE", CONCAVE_SHAPES_START_HERE)
		.value("TRIANGLE_MESH_SHAPE_PROXYTYPE", TRIANGLE_MESH_SHAPE_PROXYTYPE)
		.value("SCALED_TRIANGLE_MESH_SHAPE_PROXYTYPE", SCALED_TRIANGLE_MESH_SHAPE_PROXYTYPE)
		.value("FAST_CONCAVE_MESH_PROXYTYPE", FAST_CONCAVE_MESH_PROXYTYPE)
		.value("TERRAIN_SHAPE_PROXYTYPE", TERRAIN_SHAPE_PROXYTYPE)
		.value("GIMPACT_SHAPE_PROXYTYPE", GIMPACT_SHAPE_PROXYTYPE)
		.value("MULTIMATERIAL_TRIANGLE_MESH_PROXYTYPE", MULTIMATERIAL_TRIANGLE_MESH_PROXYTYPE)
		.value("EMPTY_SHAPE_PROXYTYPE", EMPTY_SHAPE_PROXYTYPE)
		.value("STATIC_PLANE_PROXYTYPE", STATIC_PLANE_PROXYTYPE)
		.value("CUSTOM_CONCAVE_SHAPE_TYPE", CUSTOM_CONCAVE_SHAPE_TYPE)
		.value("CONCAVE_SHAPES_END_HERE", CONCAVE_SHAPES_END_HERE)
		.value("COMPOUND_SHAPE_PROXYTYPE", COMPOUND_SHAPE_PROXYTYPE)
		.value("SOFTBODY_SHAPE_PROXYTYPE", SOFTBODY_SHAPE_PROXYTYPE)
		.value("HFFLUID_SHAPE_PROXYTYPE", HFFLUID_SHAPE_PROXYTYPE)
		.value("HFFLUID_BUOYANT_CONVEX_SHAPE_PROXYTYPE", HFFLUID_BUOYANT_CONVEX_SHAPE_PROXYTYPE)
		.value("INVALID_SHAPE_PROXYTYPE", INVALID_SHAPE_PROXYTYPE)
		.value("MAX_BROADPHASE_COLLISION_TYPES", MAX_BROADPHASE_COLLISION_TYPES)
		;
	class_<btBroadphaseProxy>("btBroadphaseProxy")
	enum_<btBroadphaseProxy::CollisionFilterGroups>("btBroadphaseProxy::CollisionFilterGroups")
		.value("DefaultFilter", btBroadphaseProxy::DefaultFilter)
		.value("StaticFilter", btBroadphaseProxy::StaticFilter)
		.value("KinematicFilter", btBroadphaseProxy::KinematicFilter)
		.value("DebrisFilter", btBroadphaseProxy::DebrisFilter)
		.value("SensorTrigger", btBroadphaseProxy::SensorTrigger)
		.value("CharacterFilter", btBroadphaseProxy::CharacterFilter)
		.value("AllFilter", btBroadphaseProxy::AllFilter)
		;
	constant("m_clientObject", m_clientObject);
	constant("m_collisionFilterGroup", m_collisionFilterGroup);
	constant("m_collisionFilterMask", m_collisionFilterMask);
	constant("m_uniqueId", m_uniqueId);
	constant("m_aabbMin", m_aabbMin);
	constant("m_aabbMax", m_aabbMax);
	.function("getUid", &btBroadphaseProxy::getUid)
	.constructor<r.q(const).btVector3,r.q(const).btVector3,p.void,int,int>()
	.class_function("isPolyhedral", &btBroadphaseProxy::isPolyhedral)
	.class_function("isConvex", &btBroadphaseProxy::isConvex)
	.class_function("isNonMoving", &btBroadphaseProxy::isNonMoving)
	.class_function("isConcave", &btBroadphaseProxy::isConcave)
	.class_function("isCompound", &btBroadphaseProxy::isCompound)
	.class_function("isSoftBody", &btBroadphaseProxy::isSoftBody)
	.class_function("isInfinite", &btBroadphaseProxy::isInfinite)
	.class_function("isConvex2d", &btBroadphaseProxy::isConvex2d)
	;
	class_<btBroadphasePair>("btBroadphasePair")
	.constructor<r.q(const).btBroadphasePair>()
	.constructor<r.btBroadphaseProxy,r.btBroadphaseProxy>()
	constant("m_pProxy0", m_pProxy0);
	constant("m_pProxy1", m_pProxy1);
	constant("m_algorithm", m_algorithm);
	;
	class_<btBroadphasePairSortPredicate>("btBroadphasePairSortPredicate")
	.function("operator ()", &btBroadphasePairSortPredicate::operator ())
	;
	class_<btBroadphaseAabbCallback>("btBroadphaseAabbCallback")
	.function("process", &btBroadphaseAabbCallback::process)
	;
	class_<btBroadphaseRayCallback, base<btBroadphaseAabbCallback>>("btBroadphaseRayCallback")
	constant("m_rayDirectionInverse", m_rayDirectionInverse);
	constant("m_signs", m_signs);
	constant("m_lambda_max", m_lambda_max);
	;
	class_<btBroadphaseInterface>("btBroadphaseInterface")
	.function("createProxy", &btBroadphaseInterface::createProxy)
	.function("destroyProxy", &btBroadphaseInterface::destroyProxy)
	.function("setAabb", &btBroadphaseInterface::setAabb)
	.function("getAabb", &btBroadphaseInterface::getAabb)
	.function("rayTest", &btBroadphaseInterface::rayTest)
	.function("rayTest", &btBroadphaseInterface::rayTest)
	.function("rayTest", &btBroadphaseInterface::rayTest)
	.function("aabbTest", &btBroadphaseInterface::aabbTest)
	.function("calculateOverlappingPairs", &btBroadphaseInterface::calculateOverlappingPairs)
	.function("getOverlappingPairCache", select_overload<btOverlappingPairCache()>(&btBroadphaseInterface::getOverlappingPairCache))
	.function("getOverlappingPairCache", select_overload<q(const).btOverlappingPairCache()const>(&btBroadphaseInterface::getOverlappingPairCache))
	.function("getBroadphaseAabb", &btBroadphaseInterface::getBroadphaseAabb)
	.function("resetPool", &btBroadphaseInterface::resetPool)
	.function("printStats", &btBroadphaseInterface::printStats)
	;
	class_<btCollisionAlgorithmConstructionInfo>("btCollisionAlgorithmConstructionInfo")
	.constructor<p.btDispatcher,int>()
	constant("m_dispatcher1", m_dispatcher1);
	constant("m_manifold", m_manifold);
	;
	class_<btCollisionAlgorithm>("btCollisionAlgorithm")
	.constructor<r.q(const).btCollisionAlgorithmConstructionInfo>()
	.function("processCollision", &btCollisionAlgorithm::processCollision)
	.function("calculateTimeOfImpact", &btCollisionAlgorithm::calculateTimeOfImpact)
	.function("getAllContactManifolds", &btCollisionAlgorithm::getAllContactManifolds)
	;
	class_<btQuadWord>("btQuadWord")
	.function("getX", &btQuadWord::getX)
	.function("getY", &btQuadWord::getY)
	.function("getZ", &btQuadWord::getZ)
	.function("setX", &btQuadWord::setX)
	.function("setY", &btQuadWord::setY)
	.function("setZ", &btQuadWord::setZ)
	.function("setW", &btQuadWord::setW)
	.function("x", &btQuadWord::x)
	.function("y", &btQuadWord::y)
	.function("z", &btQuadWord::z)
	.function("w", &btQuadWord::w)
	.function("operator btScalar*", &btQuadWord::operator btScalar*)
	.function("operator const btScalar*", &btQuadWord::operator const btScalar*)
	.function("operator ==", &btQuadWord::operator ==)
	.function("setValue_r.q(const).btScalar_r.q(const).btScalar_r.q(const).btScalar", select_overload<void(r.q(const).btScalar, r.q(const).btScalar, r.q(const).btScalar)>(&btQuadWord::setValue))
	.function("setValue_r.q(const).btScalar_r.q(const).btScalar_r.q(const).btScalar_r.q(const).btScalar", select_overload<void(r.q(const).btScalar, r.q(const).btScalar, r.q(const).btScalar, r.q(const).btScalar)>(&btQuadWord::setValue))
	.constructor<r.q(const).btScalar,r.q(const).btScalar,r.q(const).btScalar>()
	.constructor<r.q(const).btScalar,r.q(const).btScalar,r.q(const).btScalar,r.q(const).btScalar>()
	.function("setMax", &btQuadWord::setMax)
	.function("setMin", &btQuadWord::setMin)
	;
	class_<btQuaternion, base<btQuadWord>>("btQuaternion")
	.constructor<r.q(const).btScalar,r.q(const).btScalar,r.q(const).btScalar,r.q(const).btScalar>()
	.constructor<r.q(const).btVector3,r.q(const).btScalar>()
	.constructor<r.q(const).btScalar,r.q(const).btScalar,r.q(const).btScalar>()
	.function("setRotation", &btQuaternion::setRotation)
	.function("setEuler", &btQuaternion::setEuler)
	.function("setEulerZYX", &btQuaternion::setEulerZYX)
	.function("dot", &btQuaternion::dot)
	.function("length2", &btQuaternion::length2)
	.function("length", &btQuaternion::length)
	.function("normalize", &btQuaternion::normalize)
	.function("operator *_r.q(const).btScalar", select_overload<btQuaternion(r.q(const).btScalar)const>(&btQuaternion::operator *))
	.function("operator /_r.q(const).btScalar", select_overload<btQuaternion(r.q(const).btScalar)const>(&btQuaternion::operator /))
	.function("normalized", &btQuaternion::normalized)
	.function("angle", &btQuaternion::angle)
	.function("angleShortestPath", &btQuaternion::angleShortestPath)
	.function("getAngle", &btQuaternion::getAngle)
	.function("getAngleShortestPath", &btQuaternion::getAngleShortestPath)
	.function("getAxis", &btQuaternion::getAxis)
	.function("inverse", &btQuaternion::inverse)
	.function("operator +_r.q(const).btQuaternion", select_overload<btQuaternion(r.q(const).btQuaternion)const>(&btQuaternion::operator +))
	.function("operator -_r.q(const).btQuaternion", select_overload<btQuaternion(r.q(const).btQuaternion)const>(&btQuaternion::operator -))
	.function("operator -", &btQuaternion::operator -)
	.function("farthest", &btQuaternion::farthest)
	.function("nearest", &btQuaternion::nearest)
	.function("slerp", &btQuaternion::slerp)
	.class_function("getIdentity", &btQuaternion::getIdentity)
	.function("getW", &btQuaternion::getW)
	.function("serialize", &btQuaternion::serialize)
	.function("deSerialize", &btQuaternion::deSerialize)
	.function("serializeFloat", &btQuaternion::serializeFloat)
	.function("deSerializeFloat", &btQuaternion::deSerializeFloat)
	.function("serializeDouble", &btQuaternion::serializeDouble)
	.function("deSerializeDouble", &btQuaternion::deSerializeDouble)
	.function("__str__", &btQuaternion::__str__)
	.constructor<r.q(const).btQuaternion>()
	.function("__add___r.q(const).btQuaternion", select_overload<btQuaternion(r.q(const).btQuaternion)>(&btQuaternion::__add__))
	.function("__sub___r.q(const).btQuaternion", select_overload<btQuaternion(r.q(const).btQuaternion)>(&btQuaternion::__sub__))
	.function("__mul___r.q(const).btQuaternion", select_overload<btQuaternion(r.q(const).btQuaternion)>(&btQuaternion::__mul__))
	.function("__mul___r.q(const).btVector3", select_overload<btQuaternion(r.q(const).btVector3)>(&btQuaternion::__mul__))
	.function("__mul___r.q(const).btScalar", select_overload<btQuaternion(r.q(const).btScalar)>(&btQuaternion::__mul__))
	.function("__div___r.q(const).btScalar", select_overload<btQuaternion(r.q(const).btScalar)>(&btQuaternion::__div__))
	.function("__concat__", &btQuaternion::__concat__)
	;
	function("dot", &dot);
	function("length", &length);
	function("btAngle", &btAngle);
	function("inverse", &inverse);
	function("slerp", &slerp);
	function("quatRotate", &quatRotate);
	function("shortestArcQuat", &shortestArcQuat);
	function("shortestArcQuatNormalize2", &shortestArcQuatNormalize2);
	class_<btQuaternionFloatData>("btQuaternionFloatData")
	constant("m_floats", m_floats);
	;
	class_<btQuaternionDoubleData>("btQuaternionDoubleData")
	constant("m_floats", m_floats);
	;
	class_<btMatrix3x3>("btMatrix3x3")
	.constructor<r.q(const).btQuaternion>()
	.constructor<r.q(const).btScalar,r.q(const).btScalar,r.q(const).btScalar,r.q(const).btScalar,r.q(const).btScalar,r.q(const).btScalar,r.q(const).btScalar,r.q(const).btScalar,r.q(const).btScalar>()
	.constructor<r.q(const).btMatrix3x3>()
	.function("getColumn", &btMatrix3x3::getColumn)
	.function("getRow", &btMatrix3x3::getRow)
	.function("setValue", &btMatrix3x3::setValue)
	.function("setRotation", &btMatrix3x3::setRotation)
	.function("setEulerYPR", &btMatrix3x3::setEulerYPR)
	.function("setEulerZYX", &btMatrix3x3::setEulerZYX)
	.function("setIdentity", &btMatrix3x3::setIdentity)
	.class_function("getIdentity", &btMatrix3x3::getIdentity)
	.function("getOpenGLSubMatrix", &btMatrix3x3::getOpenGLSubMatrix)
	.function("getRotation", &btMatrix3x3::getRotation)
	.function("getEulerYPR", &btMatrix3x3::getEulerYPR)
	.function("getEulerZYX_r.btScalar_r.btScalar_r.btScalar_unsigned int", select_overload<void(r.btScalar, r.btScalar, r.btScalar, unsigned int)const>(&btMatrix3x3::getEulerZYX))
	.function("getEulerZYX_r.btScalar_r.btScalar_r.btScalar", select_overload<void(r.btScalar, r.btScalar, r.btScalar)const>(&btMatrix3x3::getEulerZYX))
	.function("scaled", &btMatrix3x3::scaled)
	.function("determinant", &btMatrix3x3::determinant)
	.function("adjoint", &btMatrix3x3::adjoint)
	.function("absolute", &btMatrix3x3::absolute)
	.function("transpose", &btMatrix3x3::transpose)
	.function("inverse", &btMatrix3x3::inverse)
	.function("solve33", &btMatrix3x3::solve33)
	.function("transposeTimes", &btMatrix3x3::transposeTimes)
	.function("timesTranspose", &btMatrix3x3::timesTranspose)
	.function("tdotx", &btMatrix3x3::tdotx)
	.function("tdoty", &btMatrix3x3::tdoty)
	.function("tdotz", &btMatrix3x3::tdotz)
	.function("diagonalize", &btMatrix3x3::diagonalize)
	.function("cofac", &btMatrix3x3::cofac)
	.function("serialize", &btMatrix3x3::serialize)
	.function("serializeFloat", &btMatrix3x3::serializeFloat)
	.function("deSerialize", &btMatrix3x3::deSerialize)
	.function("deSerializeFloat", &btMatrix3x3::deSerializeFloat)
	.function("deSerializeDouble", &btMatrix3x3::deSerializeDouble)
	.function("__str__", &btMatrix3x3::__str__)
	.function("__add__", &btMatrix3x3::__add__)
	.function("__sub__", &btMatrix3x3::__sub__)
	.function("__mul___r.q(const).btMatrix3x3", select_overload<btMatrix3x3(r.q(const).btMatrix3x3)>(&btMatrix3x3::__mul__))
	.function("__mul___r.q(const).btVector3", select_overload<btVector3(r.q(const).btVector3)>(&btMatrix3x3::__mul__))
	.function("__mul___r.q(const).btScalar", select_overload<btMatrix3x3(r.q(const).btScalar)>(&btMatrix3x3::__mul__))
	.function("__concat__", &btMatrix3x3::__concat__)
	.function("__eq__", &btMatrix3x3::__eq__)
	;
	class_<btMatrix3x3FloatData>("btMatrix3x3FloatData")
	constant("m_el", m_el);
	;
	class_<btMatrix3x3DoubleData>("btMatrix3x3DoubleData")
	constant("m_el", m_el);
	;
	class_<btTransform>("btTransform")
	.constructor<r.q(const).btQuaternion,r.q(const).btVector3>()
	.constructor<r.q(const).btQuaternion>()
	.constructor<r.q(const).btMatrix3x3,r.q(const).btVector3>()
	.constructor<r.q(const).btMatrix3x3>()
	.constructor<r.q(const).btTransform>()
	.function("mult", &btTransform::mult)
	.function("operator ()", &btTransform::operator ())
	.function("operator *_r.q(const).btVector3", select_overload<btVector3(r.q(const).btVector3)const>(&btTransform::operator *))
	.function("operator *_r.q(const).btQuaternion", select_overload<btQuaternion(r.q(const).btQuaternion)const>(&btTransform::operator *))
	.function("getBasis", select_overload<btMatrix3x3()>(&btTransform::getBasis))
	.function("getBasis", select_overload<q(const).btMatrix3x3()const>(&btTransform::getBasis))
	.function("getOrigin", select_overload<btVector3()>(&btTransform::getOrigin))
	.function("getOrigin", select_overload<q(const).btVector3()const>(&btTransform::getOrigin))
	.function("getRotation", &btTransform::getRotation)
	.function("getOpenGLMatrix", &btTransform::getOpenGLMatrix)
	.function("setOrigin", &btTransform::setOrigin)
	.function("invXform", &btTransform::invXform)
	.function("setBasis", &btTransform::setBasis)
	.function("setRotation", &btTransform::setRotation)
	.function("setIdentity", &btTransform::setIdentity)
	.function("inverse", &btTransform::inverse)
	.function("inverseTimes", &btTransform::inverseTimes)
	.function("operator *_r.q(const).btTransform", select_overload<btTransform(r.q(const).btTransform)const>(&btTransform::operator *))
	.class_function("getIdentity", &btTransform::getIdentity)
	.function("serialize", &btTransform::serialize)
	.function("serializeFloat", &btTransform::serializeFloat)
	.function("deSerialize", &btTransform::deSerialize)
	.function("deSerializeDouble", &btTransform::deSerializeDouble)
	.function("deSerializeFloat", &btTransform::deSerializeFloat)
	.function("__str__", &btTransform::__str__)
	.function("__mul___r.q(const).btVector3", select_overload<btVector3(r.q(const).btVector3)>(&btTransform::__mul__))
	.function("__mul___r.q(const).btQuaternion", select_overload<btQuaternion(r.q(const).btQuaternion)>(&btTransform::__mul__))
	.function("__mul___r.q(const).btTransform", select_overload<btTransform(r.q(const).btTransform)>(&btTransform::__mul__))
	.function("__eq__", &btTransform::__eq__)
	.function("__concat__", &btTransform::__concat__)
	;
	class_<btTransformFloatData>("btTransformFloatData")
	constant("m_basis", m_basis);
	constant("m_origin", m_origin);
	;
	class_<btTransformDoubleData>("btTransformDoubleData")
	constant("m_basis", m_basis);
	constant("m_origin", m_origin);
	;
	function("AabbExpand", &AabbExpand);
	function("TestPointAgainstAabb2", &TestPointAgainstAabb2);
	function("TestAabbAgainstAabb2", &TestAabbAgainstAabb2);
	function("TestTriangleAgainstAabb2", &TestTriangleAgainstAabb2);
	function("btOutcode", &btOutcode);
	function("btRayAabb2", &btRayAabb2);
	function("btRayAabb", &btRayAabb);
	function("btTransformAabb", &btTransformAabb);
	function("btTransformAabb", &btTransformAabb);
	function("testQuantizedAabbAgainstQuantizedAabb", &testQuantizedAabbAgainstQuantizedAabb);
	class_<btDbvtAabbMm>("btDbvtAabbMm")
	.function("Center", &btDbvtAabbMm::Center)
	.function("Lengths", &btDbvtAabbMm::Lengths)
	.function("Extents", &btDbvtAabbMm::Extents)
	.function("Mins", &btDbvtAabbMm::Mins)
	.function("Maxs", &btDbvtAabbMm::Maxs)
	.class_function("FromCE", &btDbvtAabbMm::FromCE)
	.class_function("FromCR", &btDbvtAabbMm::FromCR)
	.class_function("FromMM", &btDbvtAabbMm::FromMM)
	.class_function("FromPoints", &btDbvtAabbMm::FromPoints)
	.class_function("FromPoints", &btDbvtAabbMm::FromPoints)
	.function("Expand", &btDbvtAabbMm::Expand)
	.function("SignedExpand", &btDbvtAabbMm::SignedExpand)
	.function("Contain", &btDbvtAabbMm::Contain)
	.function("Classify", &btDbvtAabbMm::Classify)
	.function("ProjectMinimum", &btDbvtAabbMm::ProjectMinimum)
	function("Intersect", &Intersect);
	function("Intersect", &Intersect);
	function("Proximity", &Proximity);
	function("Select", &Select);
	function("Merge", &Merge);
	function("NotEqual", &NotEqual);
	.function("tMins", &btDbvtAabbMm::tMins)
	.function("tMaxs", &btDbvtAabbMm::tMaxs)
	.function("AddSpan", &btDbvtAabbMm::AddSpan)
	;
	class_<btDbvtNode>("btDbvtNode")
	constant("volume", volume);
	constant("parent", parent);
	.function("isleaf", &btDbvtNode::isleaf)
	.function("isinternal", &btDbvtNode::isinternal)
	;
	class_<btDbvt>("btDbvt")
	enum_<>("")
		.value("SIMPLE_STACKSIZE", btDbvt::SIMPLE_STACKSIZE)
		.value("DOUBLE_STACKSIZE", btDbvt::DOUBLE_STACKSIZE)
		;
	constant("m_root", m_root);
	constant("m_free", m_free);
	constant("m_lkhd", m_lkhd);
	constant("m_leaves", m_leaves);
	constant("m_opath", m_opath);
	constant("m_stkStack", m_stkStack);
	.function("clear", &btDbvt::clear)
	.function("empty", &btDbvt::empty)
	.function("optimizeBottomUp", &btDbvt::optimizeBottomUp)
	.function("optimizeTopDown_int", select_overload<void(int)>(&btDbvt::optimizeTopDown))
	.function("optimizeTopDown", select_overload<void()>(&btDbvt::optimizeTopDown))
	.function("optimizeIncremental", &btDbvt::optimizeIncremental)
	.function("insert", &btDbvt::insert)
	.function("update_p.btDbvtNode_int", select_overload<void(p.btDbvtNode, int)>(&btDbvt::update))
	.function("update_p.btDbvtNode", select_overload<void(p.btDbvtNode)>(&btDbvt::update))
	.function("update_p.btDbvtNode_r.btDbvtVolume", select_overload<void(p.btDbvtNode, r.btDbvtVolume)>(&btDbvt::update))
	.function("update_p.btDbvtNode_r.btDbvtVolume_r.q(const).btVector3_btScalar", select_overload<bool(p.btDbvtNode, r.btDbvtVolume, r.q(const).btVector3, btScalar)>(&btDbvt::update))
	.function("update_p.btDbvtNode_r.btDbvtVolume_r.q(const).btVector3", select_overload<bool(p.btDbvtNode, r.btDbvtVolume, r.q(const).btVector3)>(&btDbvt::update))
	.function("update_p.btDbvtNode_r.btDbvtVolume_btScalar", select_overload<bool(p.btDbvtNode, r.btDbvtVolume, btScalar)>(&btDbvt::update))
	.function("remove", &btDbvt::remove)
	.function("write", &btDbvt::write)
	.function("clone_r.btDbvt_p.btDbvt::IClone", select_overload<void(r.btDbvt, p.btDbvt::IClone)const>(&btDbvt::clone))
	.function("clone_r.btDbvt", select_overload<void(r.btDbvt)const>(&btDbvt::clone))
	.class_function("maxdepth", &btDbvt::maxdepth)
	.class_function("countLeaves", &btDbvt::countLeaves)
	.class_function("extractLeaves", &btDbvt::extractLeaves)
	.class_function("benchmark", &btDbvt::benchmark)
	.class_function("enumNodes", &btDbvt::enumNodes)
	.class_function("enumLeaves", &btDbvt::enumLeaves)
	.function("collideTT", &btDbvt::collideTT)
	.function("collideTTpersistentStack", &btDbvt::collideTTpersistentStack)
	.function("collideTV", &btDbvt::collideTV)
	.function("collideTVNoStackAlloc", &btDbvt::collideTVNoStackAlloc)
	.class_function("rayTest", &btDbvt::rayTest)
	.function("rayTestInternal", &btDbvt::rayTestInternal)
	.class_function("collideKDOP", &btDbvt::collideKDOP)
	.class_function("collideOCL", &btDbvt::collideOCL)
	.class_function("collideOCL", &btDbvt::collideOCL)
	.class_function("collideTU", &btDbvt::collideTU)
	.class_function("nearest", &btDbvt::nearest)
	.class_function("allocate", &btDbvt::allocate)
	.constructor<r.q(const).btDbvt>()
	;
	class_<btOverlappingPairCallback>("btOverlappingPairCallback")
	.function("addOverlappingPair", &btOverlappingPairCallback::addOverlappingPair)
	.function("removeOverlappingPair", &btOverlappingPairCallback::removeOverlappingPair)
	.function("removeOverlappingPairsContainingProxy", &btOverlappingPairCallback::removeOverlappingPairsContainingProxy)
	;
	class_<btOverlapCallback>("btOverlapCallback")
	.function("processOverlap", &btOverlapCallback::processOverlap)
	;
	class_<btOverlapFilterCallback>("btOverlapFilterCallback")
	.function("needBroadphaseCollision", &btOverlapFilterCallback::needBroadphaseCollision)
	;
	constant("gRemovePairs", gRemovePairs);
	constant("gAddedPairs", gAddedPairs);
	constant("gFindPairs", gFindPairs);
	constant("BT_NULL_PAIR", BT_NULL_PAIR);
	class_<btOverlappingPairCache, base<btOverlappingPairCallback>>("btOverlappingPairCache")
	.function("getOverlappingPairArrayPtr", select_overload<btBroadphasePair()>(&btOverlappingPairCache::getOverlappingPairArrayPtr))
	.function("getOverlappingPairArrayPtr", select_overload<q(const).btBroadphasePair()const>(&btOverlappingPairCache::getOverlappingPairArrayPtr))
	.function("getOverlappingPairArray", &btOverlappingPairCache::getOverlappingPairArray)
	.function("cleanOverlappingPair", &btOverlappingPairCache::cleanOverlappingPair)
	.function("getNumOverlappingPairs", &btOverlappingPairCache::getNumOverlappingPairs)
	.function("cleanProxyFromPairs", &btOverlappingPairCache::cleanProxyFromPairs)
	.function("setOverlapFilterCallback", &btOverlappingPairCache::setOverlapFilterCallback)
	.function("processAllOverlappingPairs", &btOverlappingPairCache::processAllOverlappingPairs)
	.function("findPair", &btOverlappingPairCache::findPair)
	.function("hasDeferredRemoval", &btOverlappingPairCache::hasDeferredRemoval)
	.function("setInternalGhostPairCallback", &btOverlappingPairCache::setInternalGhostPairCallback)
	.function("sortOverlappingPairs", &btOverlappingPairCache::sortOverlappingPairs)
	;
	class_<btHashedOverlappingPairCache, base<btOverlappingPairCache>>("btHashedOverlappingPairCache")
	.function("needsBroadphaseCollision", &btHashedOverlappingPairCache::needsBroadphaseCollision)
	.function("getOverlappingPairArrayPtr", select_overload<btBroadphasePair()>(&btHashedOverlappingPairCache::getOverlappingPairArrayPtr))
	.function("getOverlappingPairArrayPtr", select_overload<q(const).btBroadphasePair()const>(&btHashedOverlappingPairCache::getOverlappingPairArrayPtr))
	.function("getOverlappingPairArray", select_overload<btBroadphasePairArray()>(&btHashedOverlappingPairCache::getOverlappingPairArray))
	.function("getOverlappingPairArray", select_overload<q(const).btBroadphasePairArray()const>(&btHashedOverlappingPairCache::getOverlappingPairArray))
	.function("GetCount", &btHashedOverlappingPairCache::GetCount)
	.function("getOverlapFilterCallback", &btHashedOverlappingPairCache::getOverlapFilterCallback)
	.function("internalAddPair", &btHashedOverlappingPairCache::internalAddPair)
	.function("growTables", &btHashedOverlappingPairCache::growTables)
	.function("equalsPair", &btHashedOverlappingPairCache::equalsPair)
	.function("getHash", &btHashedOverlappingPairCache::getHash)
	.function("internalFindPair", &btHashedOverlappingPairCache::internalFindPair)
	.function("hasDeferredRemoval", &btHashedOverlappingPairCache::hasDeferredRemoval)
	.function("setInternalGhostPairCallback", &btHashedOverlappingPairCache::setInternalGhostPairCallback)
	.function("sortOverlappingPairs", &btHashedOverlappingPairCache::sortOverlappingPairs)
	;
	class_<btSortedOverlappingPairCache, base<btOverlappingPairCache>>("btSortedOverlappingPairCache")
	.function("needsBroadphaseCollision", &btSortedOverlappingPairCache::needsBroadphaseCollision)
	.function("getOverlappingPairArray", select_overload<btBroadphasePairArray()>(&btSortedOverlappingPairCache::getOverlappingPairArray))
	.function("getOverlappingPairArray", select_overload<q(const).btBroadphasePairArray()const>(&btSortedOverlappingPairCache::getOverlappingPairArray))
	.function("getOverlappingPairArrayPtr", select_overload<btBroadphasePair()>(&btSortedOverlappingPairCache::getOverlappingPairArrayPtr))
	.function("getOverlappingPairArrayPtr", select_overload<q(const).btBroadphasePair()const>(&btSortedOverlappingPairCache::getOverlappingPairArrayPtr))
	.function("getOverlapFilterCallback", &btSortedOverlappingPairCache::getOverlapFilterCallback)
	;
	class_<btNullPairCache, base<btOverlappingPairCache>>("btNullPairCache")
	.function("getOverlappingPairArrayPtr", select_overload<btBroadphasePair()>(&btNullPairCache::getOverlappingPairArrayPtr))
	.function("getOverlappingPairArrayPtr", select_overload<q(const).btBroadphasePair()const>(&btNullPairCache::getOverlappingPairArrayPtr))
	;
	class_<btDbvtProxy, base<btBroadphaseProxy>>("btDbvtProxy")
	constant("leaf", leaf);
	constant("links", links);
	constant("stage", stage);
	.constructor<r.q(const).btVector3,r.q(const).btVector3,p.void,int,int>()
	;
	class_<btDbvtBroadphase, base<btBroadphaseInterface>>("btDbvtBroadphase")
	enum_<>("")
		.value("DYNAMIC_SET", btDbvtBroadphase::DYNAMIC_SET)
		.value("FIXED_SET", btDbvtBroadphase::FIXED_SET)
		.value("STAGECOUNT", btDbvtBroadphase::STAGECOUNT)
		;
	constant("m_sets", m_sets);
	constant("m_stageRoots", m_stageRoots);
	constant("m_paircache", m_paircache);
	constant("m_prediction", m_prediction);
	constant("m_stageCurrent", m_stageCurrent);
	constant("m_fupdates", m_fupdates);
	constant("m_dupdates", m_dupdates);
	constant("m_cupdates", m_cupdates);
	constant("m_newpairs", m_newpairs);
	constant("m_fixedleft", m_fixedleft);
	constant("m_updates_call", m_updates_call);
	constant("m_updates_done", m_updates_done);
	constant("m_updates_ratio", m_updates_ratio);
	constant("m_pid", m_pid);
	constant("m_cid", m_cid);
	constant("m_gid", m_gid);
	constant("m_releasepaircache", m_releasepaircache);
	constant("m_deferedcollide", m_deferedcollide);
	constant("m_needcleanup", m_needcleanup);
	constant("m_rayTestStacks", m_rayTestStacks);
	.constructor<p.btOverlappingPairCache>()
	.function("collide", &btDbvtBroadphase::collide)
	.function("optimize", &btDbvtBroadphase::optimize)
	.function("getOverlappingPairCache", select_overload<btOverlappingPairCache()>(&btDbvtBroadphase::getOverlappingPairCache))
	.function("getOverlappingPairCache", select_overload<q(const).btOverlappingPairCache()const>(&btDbvtBroadphase::getOverlappingPairCache))
	.function("performDeferredRemoval", &btDbvtBroadphase::performDeferredRemoval)
	.function("setVelocityPrediction", &btDbvtBroadphase::setVelocityPrediction)
	.function("getVelocityPrediction", &btDbvtBroadphase::getVelocityPrediction)
	.function("setAabbForceUpdate", &btDbvtBroadphase::setAabbForceUpdate)
	.class_function("benchmark", &btDbvtBroadphase::benchmark)
	;
	class_<btDispatcherInfo>("btDispatcherInfo")
	enum_<btDispatcherInfo::DispatchFunc>("btDispatcherInfo::DispatchFunc")
		.value("DISPATCH_DISCRETE", btDispatcherInfo::DISPATCH_DISCRETE)
		.value("DISPATCH_CONTINUOUS", btDispatcherInfo::DISPATCH_CONTINUOUS)
		;
	constant("m_timeStep", m_timeStep);
	constant("m_stepCount", m_stepCount);
	constant("m_dispatchFunc", m_dispatchFunc);
	constant("m_timeOfImpact", m_timeOfImpact);
	constant("m_useContinuous", m_useContinuous);
	constant("m_debugDraw", m_debugDraw);
	constant("m_enableSatConvex", m_enableSatConvex);
	constant("m_enableSPU", m_enableSPU);
	constant("m_useEpa", m_useEpa);
	constant("m_allowedCcdPenetration", m_allowedCcdPenetration);
	constant("m_useConvexConservativeDistanceUtil", m_useConvexConservativeDistanceUtil);
	constant("m_convexConservativeDistanceThreshold", m_convexConservativeDistanceThreshold);
	;
	enum_<ebtDispatcherQueryType>("ebtDispatcherQueryType")
		.value("BT_CONTACT_POINT_ALGORITHMS", BT_CONTACT_POINT_ALGORITHMS)
		.value("BT_CLOSEST_POINT_ALGORITHMS", BT_CLOSEST_POINT_ALGORITHMS)
		;
	class_<btDispatcher>("btDispatcher")
	.function("findAlgorithm", &btDispatcher::findAlgorithm)
	.function("getNewManifold", &btDispatcher::getNewManifold)
	.function("releaseManifold", &btDispatcher::releaseManifold)
	.function("clearManifold", &btDispatcher::clearManifold)
	.function("needsCollision", &btDispatcher::needsCollision)
	.function("needsResponse", &btDispatcher::needsResponse)
	.function("dispatchAllCollisionPairs", &btDispatcher::dispatchAllCollisionPairs)
	.function("getNumManifolds", &btDispatcher::getNumManifolds)
	.function("getManifoldByIndexInternal", &btDispatcher::getManifoldByIndexInternal)
	.function("getInternalManifoldPointer", &btDispatcher::getInternalManifoldPointer)
	.function("getInternalManifoldPool", select_overload<btPoolAllocator()>(&btDispatcher::getInternalManifoldPool))
	.function("getInternalManifoldPool", select_overload<q(const).btPoolAllocator()const>(&btDispatcher::getInternalManifoldPool))
	.function("allocateCollisionAlgorithm", &btDispatcher::allocateCollisionAlgorithm)
	.function("freeCollisionAlgorithm", &btDispatcher::freeCollisionAlgorithm)
	;
	class_<btQuantizedBvhNode>("btQuantizedBvhNode")
	constant("m_quantizedAabbMin", m_quantizedAabbMin);
	constant("m_quantizedAabbMax", m_quantizedAabbMax);
	constant("m_escapeIndexOrTriangleIndex", m_escapeIndexOrTriangleIndex);
	.function("isLeafNode", &btQuantizedBvhNode::isLeafNode)
	.function("getEscapeIndex", &btQuantizedBvhNode::getEscapeIndex)
	.function("getTriangleIndex", &btQuantizedBvhNode::getTriangleIndex)
	.function("getPartId", &btQuantizedBvhNode::getPartId)
	;
	class_<btOptimizedBvhNode>("btOptimizedBvhNode")
	constant("m_aabbMinOrg", m_aabbMinOrg);
	constant("m_aabbMaxOrg", m_aabbMaxOrg);
	constant("m_escapeIndex", m_escapeIndex);
	constant("m_subPart", m_subPart);
	constant("m_triangleIndex", m_triangleIndex);
	constant("m_padding", m_padding);
	;
	class_<btBvhSubtreeInfo>("btBvhSubtreeInfo")
	.function("setAabbFromQuantizeNode", &btBvhSubtreeInfo::setAabbFromQuantizeNode)
	;
	class_<btNodeOverlapCallback>("btNodeOverlapCallback")
	.function("processNode", &btNodeOverlapCallback::processNode)
	;
	class_<btQuantizedBvh>("btQuantizedBvh")
	enum_<btQuantizedBvh::btTraversalMode>("btQuantizedBvh::btTraversalMode")
		;
	.function("setInternalNodeAabbMin", &btQuantizedBvh::setInternalNodeAabbMin)
	.function("setInternalNodeAabbMax", &btQuantizedBvh::setInternalNodeAabbMax)
	.function("getAabbMin", &btQuantizedBvh::getAabbMin)
	.function("getAabbMax", &btQuantizedBvh::getAabbMax)
	.function("setInternalNodeEscapeIndex", &btQuantizedBvh::setInternalNodeEscapeIndex)
	.function("mergeInternalNodeAabb", &btQuantizedBvh::mergeInternalNodeAabb)
	.function("swapLeafNodes", &btQuantizedBvh::swapLeafNodes)
	.function("assignInternalNodeFromLeafNode", &btQuantizedBvh::assignInternalNodeFromLeafNode)
	.function("buildTree", &btQuantizedBvh::buildTree)
	.function("calcSplittingAxis", &btQuantizedBvh::calcSplittingAxis)
	.function("sortAndCalcSplittingIndex", &btQuantizedBvh::sortAndCalcSplittingIndex)
	.function("walkStacklessTree", &btQuantizedBvh::walkStacklessTree)
	.function("walkStacklessQuantizedTreeAgainstRay", &btQuantizedBvh::walkStacklessQuantizedTreeAgainstRay)
	.function("walkStacklessQuantizedTree", &btQuantizedBvh::walkStacklessQuantizedTree)
	.function("walkStacklessTreeAgainstRay", &btQuantizedBvh::walkStacklessTreeAgainstRay)
	.function("walkStacklessQuantizedTreeCacheFriendly", &btQuantizedBvh::walkStacklessQuantizedTreeCacheFriendly)
	.function("walkRecursiveQuantizedTreeAgainstQueryAabb", &btQuantizedBvh::walkRecursiveQuantizedTreeAgainstQueryAabb)
	.function("walkRecursiveQuantizedTreeAgainstQuantizedTree", &btQuantizedBvh::walkRecursiveQuantizedTreeAgainstQuantizedTree)
	.function("updateSubtreeHeaders", &btQuantizedBvh::updateSubtreeHeaders)
	.function("setQuantizationValues_r.q(const).btVector3_r.q(const).btVector3_btScalar", select_overload<void(r.q(const).btVector3, r.q(const).btVector3, btScalar)>(&btQuantizedBvh::setQuantizationValues))
	.function("setQuantizationValues_r.q(const).btVector3_r.q(const).btVector3", select_overload<void(r.q(const).btVector3, r.q(const).btVector3)>(&btQuantizedBvh::setQuantizationValues))
	.function("getLeafNodeArray", &btQuantizedBvh::getLeafNodeArray)
	.function("buildInternal", &btQuantizedBvh::buildInternal)
	.function("reportAabbOverlappingNodex", &btQuantizedBvh::reportAabbOverlappingNodex)
	.function("reportRayOverlappingNodex", &btQuantizedBvh::reportRayOverlappingNodex)
	.function("reportBoxCastOverlappingNodex", &btQuantizedBvh::reportBoxCastOverlappingNodex)
	.function("quantize", &btQuantizedBvh::quantize)
	.function("quantizeWithClamp", &btQuantizedBvh::quantizeWithClamp)
	.function("unQuantize", &btQuantizedBvh::unQuantize)
	.function("setTraversalMode", &btQuantizedBvh::setTraversalMode)
	.function("getQuantizedNodeArray", &btQuantizedBvh::getQuantizedNodeArray)
	.function("getSubtreeInfoArray", &btQuantizedBvh::getSubtreeInfoArray)
	.function("calculateSerializeBufferSize", &btQuantizedBvh::calculateSerializeBufferSize)
	.function("serialize_p.void_unsigned int_bool", select_overload<bool(p.void, unsigned int, bool)const>(&btQuantizedBvh::serialize))
	.class_function("deSerializeInPlace", &btQuantizedBvh::deSerializeInPlace)
	.class_function("getAlignmentSerializationPadding", &btQuantizedBvh::getAlignmentSerializationPadding)
	.function("calculateSerializeBufferSizeNew", &btQuantizedBvh::calculateSerializeBufferSizeNew)
	.function("serialize_p.void_p.btSerializer", select_overload<q(const).char(p.void, p.btSerializer)const>(&btQuantizedBvh::serialize))
	.function("deSerializeFloat", &btQuantizedBvh::deSerializeFloat)
	.function("deSerializeDouble", &btQuantizedBvh::deSerializeDouble)
	.function("isQuantized", &btQuantizedBvh::isQuantized)
	.constructor<r.btQuantizedBvh,bool>()
	;
	class_<btBvhSubtreeInfoData>("btBvhSubtreeInfoData")
	constant("m_rootNodeIndex", m_rootNodeIndex);
	constant("m_subtreeSize", m_subtreeSize);
	constant("m_quantizedAabbMin", m_quantizedAabbMin);
	constant("m_quantizedAabbMax", m_quantizedAabbMax);
	;
	class_<btOptimizedBvhNodeFloatData>("btOptimizedBvhNodeFloatData")
	constant("m_aabbMinOrg", m_aabbMinOrg);
	constant("m_aabbMaxOrg", m_aabbMaxOrg);
	constant("m_escapeIndex", m_escapeIndex);
	constant("m_subPart", m_subPart);
	constant("m_triangleIndex", m_triangleIndex);
	constant("m_pad", m_pad);
	;
	class_<btOptimizedBvhNodeDoubleData>("btOptimizedBvhNodeDoubleData")
	constant("m_aabbMinOrg", m_aabbMinOrg);
	constant("m_aabbMaxOrg", m_aabbMaxOrg);
	constant("m_escapeIndex", m_escapeIndex);
	constant("m_subPart", m_subPart);
	constant("m_triangleIndex", m_triangleIndex);
	constant("m_pad", m_pad);
	;
	class_<btQuantizedBvhNodeData>("btQuantizedBvhNodeData")
	constant("m_quantizedAabbMin", m_quantizedAabbMin);
	constant("m_quantizedAabbMax", m_quantizedAabbMax);
	constant("m_escapeIndexOrTriangleIndex", m_escapeIndexOrTriangleIndex);
	;
	class_<btQuantizedBvhFloatData>("btQuantizedBvhFloatData")
	constant("m_bvhAabbMin", m_bvhAabbMin);
	constant("m_bvhAabbMax", m_bvhAabbMax);
	constant("m_bvhQuantization", m_bvhQuantization);
	constant("m_curNodeIndex", m_curNodeIndex);
	constant("m_useQuantization", m_useQuantization);
	constant("m_numContiguousLeafNodes", m_numContiguousLeafNodes);
	constant("m_numQuantizedContiguousNodes", m_numQuantizedContiguousNodes);
	constant("m_contiguousNodesPtr", m_contiguousNodesPtr);
	constant("m_quantizedContiguousNodesPtr", m_quantizedContiguousNodesPtr);
	constant("m_subTreeInfoPtr", m_subTreeInfoPtr);
	constant("m_traversalMode", m_traversalMode);
	constant("m_numSubtreeHeaders", m_numSubtreeHeaders);
	;
	class_<btQuantizedBvhDoubleData>("btQuantizedBvhDoubleData")
	constant("m_bvhAabbMin", m_bvhAabbMin);
	constant("m_bvhAabbMax", m_bvhAabbMax);
	constant("m_bvhQuantization", m_bvhQuantization);
	constant("m_curNodeIndex", m_curNodeIndex);
	constant("m_useQuantization", m_useQuantization);
	constant("m_numContiguousLeafNodes", m_numContiguousLeafNodes);
	constant("m_numQuantizedContiguousNodes", m_numQuantizedContiguousNodes);
	constant("m_contiguousNodesPtr", m_contiguousNodesPtr);
	constant("m_quantizedContiguousNodesPtr", m_quantizedContiguousNodesPtr);
	constant("m_traversalMode", m_traversalMode);
	constant("m_numSubtreeHeaders", m_numSubtreeHeaders);
	constant("m_subTreeInfoPtr", m_subTreeInfoPtr);
	;
	class_<btSimpleBroadphaseProxy, base<btBroadphaseProxy>>("btSimpleBroadphaseProxy")
	constant("m_nextFree", m_nextFree);
	.constructor<r.q(const).btVector3,r.q(const).btVector3,int,p.void,int,int>()
	.function("SetNextFree", &btSimpleBroadphaseProxy::SetNextFree)
	.function("GetNextFree", &btSimpleBroadphaseProxy::GetNextFree)
	;
	class_<btSimpleBroadphase, base<btBroadphaseInterface>>("btSimpleBroadphase")
	.function("allocHandle", &btSimpleBroadphase::allocHandle)
	.function("freeHandle", &btSimpleBroadphase::freeHandle)
	.function("getSimpleProxyFromProxy", &btSimpleBroadphase::getSimpleProxyFromProxy)
	.function("getSimpleProxyFromProxy", &btSimpleBroadphase::getSimpleProxyFromProxy)
	.function("resetPool", &btSimpleBroadphase::resetPool)
	.function("validate", &btSimpleBroadphase::validate)
	.constructor<int,p.btOverlappingPairCache>()
	.constructor<int>()
	.class_function("aabbOverlap", &btSimpleBroadphase::aabbOverlap)
	.function("getOverlappingPairCache", select_overload<btOverlappingPairCache()>(&btSimpleBroadphase::getOverlappingPairCache))
	.function("getOverlappingPairCache", select_overload<q(const).btOverlappingPairCache()const>(&btSimpleBroadphase::getOverlappingPairCache))
	.function("testAabbOverlap", &btSimpleBroadphase::testAabbOverlap)
	;
	class_<btActivatingCollisionAlgorithm, base<btCollisionAlgorithm>>("btActivatingCollisionAlgorithm")
	.constructor<r.q(const).btCollisionAlgorithmConstructionInfo>()
	.constructor<r.q(const).btCollisionAlgorithmConstructionInfo,p.q(const).btCollisionObjectWrapper,p.q(const).btCollisionObjectWrapper>()
	;
	class_<btCollisionAlgorithmCreateFunc>("btCollisionAlgorithmCreateFunc")
	constant("m_swapped", m_swapped);
	.function("CreateCollisionAlgorithm", &btCollisionAlgorithmCreateFunc::CreateCollisionAlgorithm)
	;
	class_<btBox2dBox2dCollisionAlgorithm, base<btActivatingCollisionAlgorithm>>("btBox2dBox2dCollisionAlgorithm")
	.constructor<r.q(const).btCollisionAlgorithmConstructionInfo>()
	.constructor<p.btPersistentManifold,r.q(const).btCollisionAlgorithmConstructionInfo,p.q(const).btCollisionObjectWrapper,p.q(const).btCollisionObjectWrapper>()
	;
	class_<btBoxBoxCollisionAlgorithm, base<btActivatingCollisionAlgorithm>>("btBoxBoxCollisionAlgorithm")
	.constructor<r.q(const).btCollisionAlgorithmConstructionInfo>()
	.constructor<p.btPersistentManifold,r.q(const).btCollisionAlgorithmConstructionInfo,p.q(const).btCollisionObjectWrapper,p.q(const).btCollisionObjectWrapper>()
	;
	class_<btDiscreteCollisionDetectorInterface>("btDiscreteCollisionDetectorInterface")
	.function("getClosestPoints_r.q(const).btDiscreteCollisionDetectorInterface::ClosestPointInput_r.btDiscreteCollisionDetectorInterface::Result_p.btIDebugDraw_bool", select_overload<void(r.q(const).btDiscreteCollisionDetectorInterface::ClosestPointInput, r.btDiscreteCollisionDetectorInterface::Result, p.btIDebugDraw, bool)>(&btDiscreteCollisionDetectorInterface::getClosestPoints))
	.function("getClosestPoints_r.q(const).btDiscreteCollisionDetectorInterface::ClosestPointInput_r.btDiscreteCollisionDetectorInterface::Result_p.btIDebugDraw", select_overload<void(r.q(const).btDiscreteCollisionDetectorInterface::ClosestPointInput, r.btDiscreteCollisionDetectorInterface::Result, p.btIDebugDraw)>(&btDiscreteCollisionDetectorInterface::getClosestPoints))
	;
	class_<btBoxBoxDetector, base<btDiscreteCollisionDetectorInterface>>("btBoxBoxDetector")
	constant("m_box1", m_box1);
	constant("m_box2", m_box2);
	.constructor<p.q(const).btBoxShape,p.q(const).btBoxShape>()
	.function("getClosestPoints_r.q(const).btDiscreteCollisionDetectorInterface::ClosestPointInput_r.btDiscreteCollisionDetectorInterface::Result_p.btIDebugDraw_bool", select_overload<void(r.q(const).btDiscreteCollisionDetectorInterface::ClosestPointInput, r.btDiscreteCollisionDetectorInterface::Result, p.btIDebugDraw, bool)>(&btBoxBoxDetector::getClosestPoints))
	.function("getClosestPoints_r.q(const).btDiscreteCollisionDetectorInterface::ClosestPointInput_r.btDiscreteCollisionDetectorInterface::Result_p.btIDebugDraw", select_overload<void(r.q(const).btDiscreteCollisionDetectorInterface::ClosestPointInput, r.btDiscreteCollisionDetectorInterface::Result, p.btIDebugDraw)>(&btBoxBoxDetector::getClosestPoints))
	;
	class_<btCollisionConfiguration>("btCollisionConfiguration")
	.function("getPersistentManifoldPool", &btCollisionConfiguration::getPersistentManifoldPool)
	.function("getCollisionAlgorithmPool", &btCollisionConfiguration::getCollisionAlgorithmPool)
	.function("getCollisionAlgorithmCreateFunc", &btCollisionConfiguration::getCollisionAlgorithmCreateFunc)
	.function("getClosestPointsAlgorithmCreateFunc", &btCollisionConfiguration::getClosestPointsAlgorithmCreateFunc)
	;
	function("btAabbSupport", &btAabbSupport);
	class_<btTransformUtil>("btTransformUtil")
	.class_function("integrateTransform", &btTransformUtil::integrateTransform)
	.class_function("calculateVelocityQuaternion", &btTransformUtil::calculateVelocityQuaternion)
	.class_function("calculateDiffAxisAngleQuaternion", &btTransformUtil::calculateDiffAxisAngleQuaternion)
	.class_function("calculateVelocity", &btTransformUtil::calculateVelocity)
	.class_function("calculateDiffAxisAngle", &btTransformUtil::calculateDiffAxisAngle)
	;
	class_<btConvexSeparatingDistanceUtil>("btConvexSeparatingDistanceUtil")
	.constructor<btScalar,btScalar>()
	.function("getConservativeSeparatingDistance", &btConvexSeparatingDistanceUtil::getConservativeSeparatingDistance)
	.function("updateSeparatingDistance", &btConvexSeparatingDistanceUtil::updateSeparatingDistance)
	.function("initSeparatingDistance", &btConvexSeparatingDistanceUtil::initSeparatingDistance)
	;
	class_<btConstraintRow>("btConstraintRow")
	constant("m_normal", m_normal);
	constant("m_rhs", m_rhs);
	constant("m_jacDiagInv", m_jacDiagInv);
	constant("m_lowerLimit", m_lowerLimit);
	constant("m_upperLimit", m_upperLimit);
	constant("m_accumImpulse", m_accumImpulse);
	;
	enum_<btContactPointFlags>("btContactPointFlags")
		.value("BT_CONTACT_FLAG_LATERAL_FRICTION_INITIALIZED", BT_CONTACT_FLAG_LATERAL_FRICTION_INITIALIZED)
		.value("BT_CONTACT_FLAG_HAS_CONTACT_CFM", BT_CONTACT_FLAG_HAS_CONTACT_CFM)
		.value("BT_CONTACT_FLAG_HAS_CONTACT_ERP", BT_CONTACT_FLAG_HAS_CONTACT_ERP)
		.value("BT_CONTACT_FLAG_CONTACT_STIFFNESS_DAMPING", BT_CONTACT_FLAG_CONTACT_STIFFNESS_DAMPING)
		;
	class_<btManifoldPoint>("btManifoldPoint")
	.constructor<r.q(const).btVector3,r.q(const).btVector3,r.q(const).btVector3,btScalar>()
	.function("getDistance", &btManifoldPoint::getDistance)
	.function("getLifeTime", &btManifoldPoint::getLifeTime)
	.function("getPositionWorldOnA", &btManifoldPoint::getPositionWorldOnA)
	.function("getPositionWorldOnB", &btManifoldPoint::getPositionWorldOnB)
	.function("setDistance", &btManifoldPoint::setDistance)
	.function("getAppliedImpulse", &btManifoldPoint::getAppliedImpulse)
	.function("__str__", &btManifoldPoint::__str__)
	.function("__concat__", &btManifoldPoint::__concat__)
	;
	constant("gContactBreakingThreshold", gContactBreakingThreshold);
	constant("gContactDestroyedCallback", gContactDestroyedCallback);
	constant("gContactProcessedCallback", gContactProcessedCallback);
	enum_<btContactManifoldTypes>("btContactManifoldTypes")
		.value("MIN_CONTACT_MANIFOLD_TYPE", MIN_CONTACT_MANIFOLD_TYPE)
		.value("BT_PERSISTENT_MANIFOLD_TYPE", BT_PERSISTENT_MANIFOLD_TYPE)
		;
	class_<btPersistentManifold, base<btTypedObject>>("btPersistentManifold")
	.function("sortCachedPoints", &btPersistentManifold::sortCachedPoints)
	.function("findContactPoint", &btPersistentManifold::findContactPoint)
	.constructor<p.q(const).btCollisionObject,p.q(const).btCollisionObject,int,btScalar,btScalar>()
	.function("getBody0", &btPersistentManifold::getBody0)
	.function("getBody1", &btPersistentManifold::getBody1)
	.function("setBodies", &btPersistentManifold::setBodies)
	.function("clearUserCache", &btPersistentManifold::clearUserCache)
	.function("getNumContacts", &btPersistentManifold::getNumContacts)
	.function("setNumContacts", &btPersistentManifold::setNumContacts)
	.function("getContactPoint_int", select_overload<q(const).btManifoldPoint(int)const>(&btPersistentManifold::getContactPoint))
	.function("getContactPoint_int", select_overload<btManifoldPoint(int)>(&btPersistentManifold::getContactPoint))
	.function("getContactBreakingThreshold", &btPersistentManifold::getContactBreakingThreshold)
	.function("getContactProcessingThreshold", &btPersistentManifold::getContactProcessingThreshold)
	.function("setContactBreakingThreshold", &btPersistentManifold::setContactBreakingThreshold)
	.function("setContactProcessingThreshold", &btPersistentManifold::setContactProcessingThreshold)
	.function("getCacheEntry", &btPersistentManifold::getCacheEntry)
	.function("addManifoldPoint_r.q(const).btManifoldPoint_bool", select_overload<int(r.q(const).btManifoldPoint, bool)>(&btPersistentManifold::addManifoldPoint))
	.function("addManifoldPoint_r.q(const).btManifoldPoint", select_overload<int(r.q(const).btManifoldPoint)>(&btPersistentManifold::addManifoldPoint))
	.function("removeContactPoint", &btPersistentManifold::removeContactPoint)
	.function("replaceContactPoint", &btPersistentManifold::replaceContactPoint)
	.function("validContactDistance", &btPersistentManifold::validContactDistance)
	.function("refreshContactPoints", &btPersistentManifold::refreshContactPoints)
	.function("clearManifold", &btPersistentManifold::clearManifold)
	;
	class_<btMotionState>("btMotionState")
	.function("getWorldTransform", &btMotionState::getWorldTransform)
	.function("setWorldTransform", &btMotionState::setWorldTransform)
	;
	class_<btCollisionObject>("btCollisionObject")
	enum_<btCollisionObject::CollisionFlags>("btCollisionObject::CollisionFlags")
		;
	enum_<btCollisionObject::CollisionObjectTypes>("btCollisionObject::CollisionObjectTypes")
		;
	enum_<btCollisionObject::AnisotropicFrictionFlags>("btCollisionObject::AnisotropicFrictionFlags")
		;
	.function("mergesSimulationIslands", &btCollisionObject::mergesSimulationIslands)
	.function("getAnisotropicFriction", &btCollisionObject::getAnisotropicFriction)
	.function("setAnisotropicFriction_r.q(const).btVector3_int", select_overload<void(r.q(const).btVector3, int)>(&btCollisionObject::setAnisotropicFriction))
	.function("setAnisotropicFriction_r.q(const).btVector3", select_overload<void(r.q(const).btVector3)>(&btCollisionObject::setAnisotropicFriction))
	.function("hasAnisotropicFriction_int", select_overload<bool(int)const>(&btCollisionObject::hasAnisotropicFriction))
	.function("hasAnisotropicFriction", select_overload<bool()const>(&btCollisionObject::hasAnisotropicFriction))
	.function("setContactProcessingThreshold", &btCollisionObject::setContactProcessingThreshold)
	.function("getContactProcessingThreshold", &btCollisionObject::getContactProcessingThreshold)
	.function("isStaticObject", &btCollisionObject::isStaticObject)
	.function("isKinematicObject", &btCollisionObject::isKinematicObject)
	.function("isStaticOrKinematicObject", &btCollisionObject::isStaticOrKinematicObject)
	.function("hasContactResponse", &btCollisionObject::hasContactResponse)
	.function("setCollisionShape", &btCollisionObject::setCollisionShape)
	.function("getCollisionShape", select_overload<q(const).btCollisionShape()const>(&btCollisionObject::getCollisionShape))
	.function("getCollisionShape", select_overload<btCollisionShape()>(&btCollisionObject::getCollisionShape))
	.function("setIgnoreCollisionCheck", &btCollisionObject::setIgnoreCollisionCheck)
	.function("checkCollideWithOverride", &btCollisionObject::checkCollideWithOverride)
	.function("internalGetExtensionPointer", &btCollisionObject::internalGetExtensionPointer)
	.function("internalSetExtensionPointer", &btCollisionObject::internalSetExtensionPointer)
	.function("getActivationState", &btCollisionObject::getActivationState)
	.function("setActivationState", &btCollisionObject::setActivationState)
	.function("setDeactivationTime", &btCollisionObject::setDeactivationTime)
	.function("getDeactivationTime", &btCollisionObject::getDeactivationTime)
	.function("forceActivationState", &btCollisionObject::forceActivationState)
	.function("activate_bool", select_overload<void(bool)const>(&btCollisionObject::activate))
	.function("activate", select_overload<void()const>(&btCollisionObject::activate))
	.function("isActive", &btCollisionObject::isActive)
	.function("setRestitution", &btCollisionObject::setRestitution)
	.function("getRestitution", &btCollisionObject::getRestitution)
	.function("setFriction", &btCollisionObject::setFriction)
	.function("getFriction", &btCollisionObject::getFriction)
	.function("setRollingFriction", &btCollisionObject::setRollingFriction)
	.function("getRollingFriction", &btCollisionObject::getRollingFriction)
	.function("setSpinningFriction", &btCollisionObject::setSpinningFriction)
	.function("getSpinningFriction", &btCollisionObject::getSpinningFriction)
	.function("setContactStiffnessAndDamping", &btCollisionObject::setContactStiffnessAndDamping)
	.function("getContactStiffness", &btCollisionObject::getContactStiffness)
	.function("getContactDamping", &btCollisionObject::getContactDamping)
	.function("getInternalType", &btCollisionObject::getInternalType)
	.function("getWorldTransform", select_overload<btTransform()>(&btCollisionObject::getWorldTransform))
	.function("getWorldTransform", select_overload<q(const).btTransform()const>(&btCollisionObject::getWorldTransform))
	.function("setWorldTransform", &btCollisionObject::setWorldTransform)
	.function("getBroadphaseHandle", select_overload<btBroadphaseProxy()>(&btCollisionObject::getBroadphaseHandle))
	.function("getBroadphaseHandle", select_overload<q(const).btBroadphaseProxy()const>(&btCollisionObject::getBroadphaseHandle))
	.function("setBroadphaseHandle", &btCollisionObject::setBroadphaseHandle)
	.function("getInterpolationWorldTransform", select_overload<q(const).btTransform()const>(&btCollisionObject::getInterpolationWorldTransform))
	.function("getInterpolationWorldTransform", select_overload<btTransform()>(&btCollisionObject::getInterpolationWorldTransform))
	.function("setInterpolationWorldTransform", &btCollisionObject::setInterpolationWorldTransform)
	.function("setInterpolationLinearVelocity", &btCollisionObject::setInterpolationLinearVelocity)
	.function("setInterpolationAngularVelocity", &btCollisionObject::setInterpolationAngularVelocity)
	.function("getInterpolationLinearVelocity", &btCollisionObject::getInterpolationLinearVelocity)
	.function("getInterpolationAngularVelocity", &btCollisionObject::getInterpolationAngularVelocity)
	.function("getIslandTag", &btCollisionObject::getIslandTag)
	.function("setIslandTag", &btCollisionObject::setIslandTag)
	.function("getCompanionId", &btCollisionObject::getCompanionId)
	.function("setCompanionId", &btCollisionObject::setCompanionId)
	.function("getWorldArrayIndex", &btCollisionObject::getWorldArrayIndex)
	.function("setWorldArrayIndex", &btCollisionObject::setWorldArrayIndex)
	.function("getHitFraction", &btCollisionObject::getHitFraction)
	.function("setHitFraction", &btCollisionObject::setHitFraction)
	.function("getCollisionFlags", &btCollisionObject::getCollisionFlags)
	.function("setCollisionFlags", &btCollisionObject::setCollisionFlags)
	.function("getCcdSweptSphereRadius", &btCollisionObject::getCcdSweptSphereRadius)
	.function("setCcdSweptSphereRadius", &btCollisionObject::setCcdSweptSphereRadius)
	.function("getCcdMotionThreshold", &btCollisionObject::getCcdMotionThreshold)
	.function("getCcdSquareMotionThreshold", &btCollisionObject::getCcdSquareMotionThreshold)
	.function("setCcdMotionThreshold", &btCollisionObject::setCcdMotionThreshold)
	.function("getUserPointer", &btCollisionObject::getUserPointer)
	.function("getUserIndex", &btCollisionObject::getUserIndex)
	.function("getUserIndex2", &btCollisionObject::getUserIndex2)
	.function("setUserPointer", &btCollisionObject::setUserPointer)
	.function("setUserIndex", &btCollisionObject::setUserIndex)
	.function("setUserIndex2", &btCollisionObject::setUserIndex2)
	.function("getUpdateRevisionInternal", &btCollisionObject::getUpdateRevisionInternal)
	.function("setCustomDebugColor", &btCollisionObject::setCustomDebugColor)
	.function("removeCustomDebugColor", &btCollisionObject::removeCustomDebugColor)
	.function("getCustomDebugColor", &btCollisionObject::getCustomDebugColor)
	.function("checkCollideWith", &btCollisionObject::checkCollideWith)
	.function("calculateSerializeBufferSize", &btCollisionObject::calculateSerializeBufferSize)
	.function("serialize", &btCollisionObject::serialize)
	.function("serializeSingleObject", &btCollisionObject::serializeSingleObject)
	;
	class_<btCollisionObjectDoubleData>("btCollisionObjectDoubleData")
	constant("m_broadphaseHandle", m_broadphaseHandle);
	constant("m_collisionShape", m_collisionShape);
	constant("m_rootCollisionShape", m_rootCollisionShape);
	constant("m_name", m_name);
	constant("m_worldTransform", m_worldTransform);
	constant("m_interpolationWorldTransform", m_interpolationWorldTransform);
	constant("m_interpolationLinearVelocity", m_interpolationLinearVelocity);
	constant("m_interpolationAngularVelocity", m_interpolationAngularVelocity);
	constant("m_anisotropicFriction", m_anisotropicFriction);
	constant("m_contactProcessingThreshold", m_contactProcessingThreshold);
	constant("m_deactivationTime", m_deactivationTime);
	constant("m_friction", m_friction);
	constant("m_rollingFriction", m_rollingFriction);
	constant("m_contactDamping", m_contactDamping);
	constant("m_contactStiffness", m_contactStiffness);
	constant("m_restitution", m_restitution);
	constant("m_hitFraction", m_hitFraction);
	constant("m_ccdSweptSphereRadius", m_ccdSweptSphereRadius);
	constant("m_ccdMotionThreshold", m_ccdMotionThreshold);
	constant("m_hasAnisotropicFriction", m_hasAnisotropicFriction);
	constant("m_collisionFlags", m_collisionFlags);
	constant("m_islandTag1", m_islandTag1);
	constant("m_companionId", m_companionId);
	constant("m_activationState1", m_activationState1);
	constant("m_internalType", m_internalType);
	constant("m_checkCollideWith", m_checkCollideWith);
	constant("m_padding", m_padding);
	;
	class_<btCollisionObjectFloatData>("btCollisionObjectFloatData")
	constant("m_broadphaseHandle", m_broadphaseHandle);
	constant("m_collisionShape", m_collisionShape);
	constant("m_rootCollisionShape", m_rootCollisionShape);
	constant("m_name", m_name);
	constant("m_worldTransform", m_worldTransform);
	constant("m_interpolationWorldTransform", m_interpolationWorldTransform);
	constant("m_interpolationLinearVelocity", m_interpolationLinearVelocity);
	constant("m_interpolationAngularVelocity", m_interpolationAngularVelocity);
	constant("m_anisotropicFriction", m_anisotropicFriction);
	constant("m_contactProcessingThreshold", m_contactProcessingThreshold);
	constant("m_deactivationTime", m_deactivationTime);
	constant("m_friction", m_friction);
	constant("m_rollingFriction", m_rollingFriction);
	constant("m_contactDamping", m_contactDamping);
	constant("m_contactStiffness", m_contactStiffness);
	constant("m_restitution", m_restitution);
	constant("m_hitFraction", m_hitFraction);
	constant("m_ccdSweptSphereRadius", m_ccdSweptSphereRadius);
	constant("m_ccdMotionThreshold", m_ccdMotionThreshold);
	constant("m_hasAnisotropicFriction", m_hasAnisotropicFriction);
	constant("m_collisionFlags", m_collisionFlags);
	constant("m_islandTag1", m_islandTag1);
	constant("m_companionId", m_companionId);
	constant("m_activationState1", m_activationState1);
	constant("m_internalType", m_internalType);
	constant("m_checkCollideWith", m_checkCollideWith);
	constant("m_padding", m_padding);
	;
	constant("gContactAddedCallback", gContactAddedCallback);
	class_<btManifoldResult, base<btDiscreteCollisionDetectorInterface::Result>>("btManifoldResult")
	.constructor<p.q(const).btCollisionObjectWrapper,p.q(const).btCollisionObjectWrapper>()
	.function("setPersistentManifold", &btManifoldResult::setPersistentManifold)
	.function("getPersistentManifold", select_overload<q(const).btPersistentManifold()const>(&btManifoldResult::getPersistentManifold))
	.function("getPersistentManifold", select_overload<btPersistentManifold()>(&btManifoldResult::getPersistentManifold))
	.function("setShapeIdentifiersA", &btManifoldResult::setShapeIdentifiersA)
	.function("setShapeIdentifiersB", &btManifoldResult::setShapeIdentifiersB)
	.function("addContactPoint", &btManifoldResult::addContactPoint)
	.function("refreshContactPoints", &btManifoldResult::refreshContactPoints)
	.function("getBody0Wrap", &btManifoldResult::getBody0Wrap)
	.function("getBody1Wrap", &btManifoldResult::getBody1Wrap)
	.function("setBody0Wrap", &btManifoldResult::setBody0Wrap)
	.function("setBody1Wrap", &btManifoldResult::setBody1Wrap)
	.function("getBody0Internal", &btManifoldResult::getBody0Internal)
	.function("getBody1Internal", &btManifoldResult::getBody1Internal)
	.class_function("calculateCombinedRestitution", &btManifoldResult::calculateCombinedRestitution)
	.class_function("calculateCombinedFriction", &btManifoldResult::calculateCombinedFriction)
	.class_function("calculateCombinedRollingFriction", &btManifoldResult::calculateCombinedRollingFriction)
	.class_function("calculateCombinedSpinningFriction", &btManifoldResult::calculateCombinedSpinningFriction)
	.class_function("calculateCombinedContactDamping", &btManifoldResult::calculateCombinedContactDamping)
	.class_function("calculateCombinedContactStiffness", &btManifoldResult::calculateCombinedContactStiffness)
	;
	class_<btCollisionDispatcher, base<btDispatcher>>("btCollisionDispatcher")
	enum_<btCollisionDispatcher::DispatcherFlags>("btCollisionDispatcher::DispatcherFlags")
		;
	.function("getDispatcherFlags", &btCollisionDispatcher::getDispatcherFlags)
	.function("setDispatcherFlags", &btCollisionDispatcher::setDispatcherFlags)
	.function("registerCollisionCreateFunc", &btCollisionDispatcher::registerCollisionCreateFunc)
	.function("registerClosestPointsCreateFunc", &btCollisionDispatcher::registerClosestPointsCreateFunc)
	.function("getManifoldByIndexInternal_int", select_overload<btPersistentManifold(int)>(&btCollisionDispatcher::getManifoldByIndexInternal))
	.function("getManifoldByIndexInternal_int", select_overload<q(const).btPersistentManifold(int)const>(&btCollisionDispatcher::getManifoldByIndexInternal))
	.constructor<p.btCollisionConfiguration>()
	.function("setNearCallback", &btCollisionDispatcher::setNearCallback)
	.function("getNearCallback", &btCollisionDispatcher::getNearCallback)
	.class_function("defaultNearCallback", &btCollisionDispatcher::defaultNearCallback)
	.function("getCollisionConfiguration", select_overload<btCollisionConfiguration()>(&btCollisionDispatcher::getCollisionConfiguration))
	.function("getCollisionConfiguration", select_overload<q(const).btCollisionConfiguration()const>(&btCollisionDispatcher::getCollisionConfiguration))
	.function("setCollisionConfiguration", &btCollisionDispatcher::setCollisionConfiguration)
	.function("getInternalManifoldPool", select_overload<btPoolAllocator()>(&btCollisionDispatcher::getInternalManifoldPool))
	.function("getInternalManifoldPool", select_overload<q(const).btPoolAllocator()const>(&btCollisionDispatcher::getInternalManifoldPool))
	;
	class_<btCollisionWorld>("btCollisionWorld")
	.function("serializeCollisionObjects", &btCollisionWorld::serializeCollisionObjects)
	.constructor<p.btDispatcher,p.btBroadphaseInterface,p.btCollisionConfiguration>()
	.function("setBroadphase", &btCollisionWorld::setBroadphase)
	.function("getBroadphase", select_overload<q(const).btBroadphaseInterface()const>(&btCollisionWorld::getBroadphase))
	.function("getBroadphase", select_overload<btBroadphaseInterface()>(&btCollisionWorld::getBroadphase))
	.function("getPairCache", &btCollisionWorld::getPairCache)
	.function("getDispatcher", select_overload<btDispatcher()>(&btCollisionWorld::getDispatcher))
	.function("getDispatcher", select_overload<q(const).btDispatcher()const>(&btCollisionWorld::getDispatcher))
	.function("updateSingleAabb", &btCollisionWorld::updateSingleAabb)
	.function("updateAabbs", &btCollisionWorld::updateAabbs)
	.function("computeOverlappingPairs", &btCollisionWorld::computeOverlappingPairs)
	.function("setDebugDrawer", &btCollisionWorld::setDebugDrawer)
	.function("getDebugDrawer", &btCollisionWorld::getDebugDrawer)
	.function("debugDrawWorld", &btCollisionWorld::debugDrawWorld)
	.function("debugDrawObject", &btCollisionWorld::debugDrawObject)
	.function("getNumCollisionObjects", &btCollisionWorld::getNumCollisionObjects)
	.function("rayTest", &btCollisionWorld::rayTest)
	.function("convexSweepTest_p.q(const).btConvexShape_r.q(const).btTransform_r.q(const).btTransform_r.btCollisionWorld::ConvexResultCallback_btScalar", select_overload<void(p.q(const).btConvexShape, r.q(const).btTransform, r.q(const).btTransform, r.btCollisionWorld::ConvexResultCallback, btScalar)const>(&btCollisionWorld::convexSweepTest))
	.function("convexSweepTest_p.q(const).btConvexShape_r.q(const).btTransform_r.q(const).btTransform_r.btCollisionWorld::ConvexResultCallback", select_overload<void(p.q(const).btConvexShape, r.q(const).btTransform, r.q(const).btTransform, r.btCollisionWorld::ConvexResultCallback)const>(&btCollisionWorld::convexSweepTest))
	.function("contactTest", &btCollisionWorld::contactTest)
	.function("contactPairTest", &btCollisionWorld::contactPairTest)
	.class_function("rayTestSingle", &btCollisionWorld::rayTestSingle)
	.class_function("rayTestSingleInternal", &btCollisionWorld::rayTestSingleInternal)
	.class_function("objectQuerySingle", &btCollisionWorld::objectQuerySingle)
	.class_function("objectQuerySingleInternal", &btCollisionWorld::objectQuerySingleInternal)
	.function("addCollisionObject_p.btCollisionObject_int_int", select_overload<void(p.btCollisionObject, int, int)>(&btCollisionWorld::addCollisionObject))
	.function("addCollisionObject_p.btCollisionObject_int", select_overload<void(p.btCollisionObject, int)>(&btCollisionWorld::addCollisionObject))
	.function("addCollisionObject_p.btCollisionObject", select_overload<void(p.btCollisionObject)>(&btCollisionWorld::addCollisionObject))
	.function("getCollisionObjectArray", select_overload<btCollisionObjectArray()>(&btCollisionWorld::getCollisionObjectArray))
	.function("getCollisionObjectArray", select_overload<q(const).btCollisionObjectArray()const>(&btCollisionWorld::getCollisionObjectArray))
	.function("removeCollisionObject", &btCollisionWorld::removeCollisionObject)
	.function("performDiscreteCollisionDetection", &btCollisionWorld::performDiscreteCollisionDetection)
	.function("getDispatchInfo", select_overload<btDispatcherInfo()>(&btCollisionWorld::getDispatchInfo))
	.function("getDispatchInfo", select_overload<q(const).btDispatcherInfo()const>(&btCollisionWorld::getDispatchInfo))
	.function("getForceUpdateAllAabbs", &btCollisionWorld::getForceUpdateAllAabbs)
	.function("setForceUpdateAllAabbs", &btCollisionWorld::setForceUpdateAllAabbs)
	.function("serialize", &btCollisionWorld::serialize)
	;
	constant("gCompoundChildShapePairCallback", gCompoundChildShapePairCallback);
	class_<btCompoundCollisionAlgorithm, base<btActivatingCollisionAlgorithm>>("btCompoundCollisionAlgorithm")
	.function("removeChildAlgorithms", &btCompoundCollisionAlgorithm::removeChildAlgorithms)
	.function("preallocateChildAlgorithms", &btCompoundCollisionAlgorithm::preallocateChildAlgorithms)
	.constructor<r.q(const).btCollisionAlgorithmConstructionInfo,p.q(const).btCollisionObjectWrapper,p.q(const).btCollisionObjectWrapper,bool>()
	.function("getChildAlgorithm", &btCompoundCollisionAlgorithm::getChildAlgorithm)
	;
	constant("BT_SIMPLE_NULL_PAIR", BT_SIMPLE_NULL_PAIR);
	class_<btSimplePair>("btSimplePair")
	.constructor<int,int>()
	constant("m_indexA", m_indexA);
	constant("m_indexB", m_indexB);
	;
	constant("gOverlappingSimplePairs", gOverlappingSimplePairs);
	constant("gRemoveSimplePairs", gRemoveSimplePairs);
	constant("gAddedSimplePairs", gAddedSimplePairs);
	constant("gFindSimplePairs", gFindSimplePairs);
	class_<btHashedSimplePairCache>("btHashedSimplePairCache")
	.function("removeAllPairs", &btHashedSimplePairCache::removeAllPairs)
	.function("removeOverlappingPair", &btHashedSimplePairCache::removeOverlappingPair)
	.function("addOverlappingPair", &btHashedSimplePairCache::addOverlappingPair)
	.function("getOverlappingPairArrayPtr", select_overload<btSimplePair()>(&btHashedSimplePairCache::getOverlappingPairArrayPtr))
	.function("getOverlappingPairArrayPtr", select_overload<q(const).btSimplePair()const>(&btHashedSimplePairCache::getOverlappingPairArrayPtr))
	.function("getOverlappingPairArray", select_overload<btSimplePairArray()>(&btHashedSimplePairCache::getOverlappingPairArray))
	.function("getOverlappingPairArray", select_overload<q(const).btSimplePairArray()const>(&btHashedSimplePairCache::getOverlappingPairArray))
	.function("findPair", &btHashedSimplePairCache::findPair)
	.function("GetCount", &btHashedSimplePairCache::GetCount)
	.function("getNumOverlappingPairs", &btHashedSimplePairCache::getNumOverlappingPairs)
	.function("internalAddPair", &btHashedSimplePairCache::internalAddPair)
	.function("growTables", &btHashedSimplePairCache::growTables)
	.function("equalsPair", &btHashedSimplePairCache::equalsPair)
	.function("getHash", &btHashedSimplePairCache::getHash)
	.function("internalFindPair", &btHashedSimplePairCache::internalFindPair)
	;
	constant("gCompoundCompoundChildShapePairCallback", gCompoundCompoundChildShapePairCallback);
	class_<btCompoundCompoundCollisionAlgorithm, base<btCompoundCollisionAlgorithm>>("btCompoundCompoundCollisionAlgorithm")
	.function("removeChildAlgorithms", &btCompoundCompoundCollisionAlgorithm::removeChildAlgorithms)
	.constructor<r.q(const).btCollisionAlgorithmConstructionInfo,p.q(const).btCollisionObjectWrapper,p.q(const).btCollisionObjectWrapper,bool>()
	;
	class_<btUsageBitfield>("btUsageBitfield")
	.function("reset", &btUsageBitfield::reset)
	constant("usedVertexA", usedVertexA);
	constant("usedVertexB", usedVertexB);
	constant("usedVertexC", usedVertexC);
	constant("usedVertexD", usedVertexD);
	constant("unused1", unused1);
	constant("unused2", unused2);
	constant("unused3", unused3);
	constant("unused4", unused4);
	;
	class_<btSubSimplexClosestResult>("btSubSimplexClosestResult")
	constant("m_closestPointOnSimplex", m_closestPointOnSimplex);
	constant("m_usedVertices", m_usedVertices);
	constant("m_barycentricCoords", m_barycentricCoords);
	constant("m_degenerate", m_degenerate);
	.function("reset", &btSubSimplexClosestResult::reset)
	.function("isValid", &btSubSimplexClosestResult::isValid)
	.function("setBarycentricCoordinates_btScalar_btScalar_btScalar_btScalar", select_overload<void(btScalar, btScalar, btScalar, btScalar)>(&btSubSimplexClosestResult::setBarycentricCoordinates))
	.function("setBarycentricCoordinates_btScalar_btScalar_btScalar", select_overload<void(btScalar, btScalar, btScalar)>(&btSubSimplexClosestResult::setBarycentricCoordinates))
	.function("setBarycentricCoordinates_btScalar_btScalar", select_overload<void(btScalar, btScalar)>(&btSubSimplexClosestResult::setBarycentricCoordinates))
	.function("setBarycentricCoordinates_btScalar", select_overload<void(btScalar)>(&btSubSimplexClosestResult::setBarycentricCoordinates))
	.function("setBarycentricCoordinates", select_overload<void()>(&btSubSimplexClosestResult::setBarycentricCoordinates))
	;
	class_<btVoronoiSimplexSolver>("btVoronoiSimplexSolver")
	.function("removeVertex", &btVoronoiSimplexSolver::removeVertex)
	.function("reduceVertices", &btVoronoiSimplexSolver::reduceVertices)
	.function("updateClosestVectorAndPoints", &btVoronoiSimplexSolver::updateClosestVectorAndPoints)
	.function("closestPtPointTetrahedron", &btVoronoiSimplexSolver::closestPtPointTetrahedron)
	.function("pointOutsideOfPlane", &btVoronoiSimplexSolver::pointOutsideOfPlane)
	.function("closestPtPointTriangle", &btVoronoiSimplexSolver::closestPtPointTriangle)
	.function("reset", &btVoronoiSimplexSolver::reset)
	.function("addVertex", &btVoronoiSimplexSolver::addVertex)
	.function("setEqualVertexThreshold", &btVoronoiSimplexSolver::setEqualVertexThreshold)
	.function("getEqualVertexThreshold", &btVoronoiSimplexSolver::getEqualVertexThreshold)
	.function("closest", &btVoronoiSimplexSolver::closest)
	.function("maxVertex", &btVoronoiSimplexSolver::maxVertex)
	.function("fullSimplex", &btVoronoiSimplexSolver::fullSimplex)
	.function("getSimplex", &btVoronoiSimplexSolver::getSimplex)
	.function("inSimplex", &btVoronoiSimplexSolver::inSimplex)
	.function("backup_closest", &btVoronoiSimplexSolver::backup_closest)
	.function("emptySimplex", &btVoronoiSimplexSolver::emptySimplex)
	.function("compute_points", &btVoronoiSimplexSolver::compute_points)
	.function("numVertices", &btVoronoiSimplexSolver::numVertices)
	;
	class_<btGjkPairDetector, base<btDiscreteCollisionDetectorInterface>>("btGjkPairDetector")
	.constructor<p.q(const).btConvexShape,p.q(const).btConvexShape,p.btVoronoiSimplexSolver,p.btConvexPenetrationDepthSolver>()
	.constructor<p.q(const).btConvexShape,p.q(const).btConvexShape,int,int,btScalar,btScalar,p.btVoronoiSimplexSolver,p.btConvexPenetrationDepthSolver>()
	.function("getClosestPoints_r.q(const).btDiscreteCollisionDetectorInterface::ClosestPointInput_r.btDiscreteCollisionDetectorInterface::Result_p.btIDebugDraw_bool", select_overload<void(r.q(const).btDiscreteCollisionDetectorInterface::ClosestPointInput, r.btDiscreteCollisionDetectorInterface::Result, p.btIDebugDraw, bool)>(&btGjkPairDetector::getClosestPoints))
	.function("getClosestPoints_r.q(const).btDiscreteCollisionDetectorInterface::ClosestPointInput_r.btDiscreteCollisionDetectorInterface::Result_p.btIDebugDraw", select_overload<void(r.q(const).btDiscreteCollisionDetectorInterface::ClosestPointInput, r.btDiscreteCollisionDetectorInterface::Result, p.btIDebugDraw)>(&btGjkPairDetector::getClosestPoints))
	.function("getClosestPointsNonVirtual", &btGjkPairDetector::getClosestPointsNonVirtual)
	.function("setMinkowskiA", &btGjkPairDetector::setMinkowskiA)
	.function("setMinkowskiB", &btGjkPairDetector::setMinkowskiB)
	.function("setCachedSeperatingAxis", &btGjkPairDetector::setCachedSeperatingAxis)
	.function("getCachedSeparatingAxis", &btGjkPairDetector::getCachedSeparatingAxis)
	.function("getCachedSeparatingDistance", &btGjkPairDetector::getCachedSeparatingDistance)
	.function("setPenetrationDepthSolver", &btGjkPairDetector::setPenetrationDepthSolver)
	.function("setIgnoreMargin", &btGjkPairDetector::setIgnoreMargin)
	;
	class_<btConvex2dConvex2dAlgorithm, base<btActivatingCollisionAlgorithm>>("btConvex2dConvex2dAlgorithm")
	.constructor<p.btPersistentManifold,r.q(const).btCollisionAlgorithmConstructionInfo,p.q(const).btCollisionObjectWrapper,p.q(const).btCollisionObjectWrapper,p.btVoronoiSimplexSolver,p.btConvexPenetrationDepthSolver,int,int>()
	.function("setLowLevelOfDetail", &btConvex2dConvex2dAlgorithm::setLowLevelOfDetail)
	.function("getManifold", &btConvex2dConvex2dAlgorithm::getManifold)
	;
	class_<btTriangleCallback>("btTriangleCallback")
	.function("processTriangle", &btTriangleCallback::processTriangle)
	;
	class_<btInternalTriangleIndexCallback>("btInternalTriangleIndexCallback")
	.function("internalProcessTriangleIndex", &btInternalTriangleIndexCallback::internalProcessTriangleIndex)
	;
	class_<btConvexTriangleCallback, base<btTriangleCallback>>("btConvexTriangleCallback")
	.constructor<p.btDispatcher,p.q(const).btCollisionObjectWrapper,p.q(const).btCollisionObjectWrapper,bool>()
	.function("setTimeStepAndCounters", &btConvexTriangleCallback::setTimeStepAndCounters)
	.function("clearWrapperData", &btConvexTriangleCallback::clearWrapperData)
	.function("clearCache", &btConvexTriangleCallback::clearCache)
	.function("getAabbMin", &btConvexTriangleCallback::getAabbMin)
	.function("getAabbMax", &btConvexTriangleCallback::getAabbMax)
	;
	class_<btConvexConcaveCollisionAlgorithm, base<btActivatingCollisionAlgorithm>>("btConvexConcaveCollisionAlgorithm")
	.constructor<r.q(const).btCollisionAlgorithmConstructionInfo,p.q(const).btCollisionObjectWrapper,p.q(const).btCollisionObjectWrapper,bool>()
	.function("clearCache", &btConvexConcaveCollisionAlgorithm::clearCache)
	;
	class_<btPolyhedralContactClipping>("btPolyhedralContactClipping")
	.class_function("clipHullAgainstHull", &btPolyhedralContactClipping::clipHullAgainstHull)
	.class_function("clipFaceAgainstHull", &btPolyhedralContactClipping::clipFaceAgainstHull)
	.class_function("findSeparatingAxis", &btPolyhedralContactClipping::findSeparatingAxis)
	.class_function("clipFace", &btPolyhedralContactClipping::clipFace)
	;
	class_<btConvexConvexAlgorithm, base<btActivatingCollisionAlgorithm>>("btConvexConvexAlgorithm")
	.constructor<p.btPersistentManifold,r.q(const).btCollisionAlgorithmConstructionInfo,p.q(const).btCollisionObjectWrapper,p.q(const).btCollisionObjectWrapper,p.btConvexPenetrationDepthSolver,int,int>()
	.function("setLowLevelOfDetail", &btConvexConvexAlgorithm::setLowLevelOfDetail)
	.function("getManifold", &btConvexConvexAlgorithm::getManifold)
	;
	class_<btConvexPlaneCollisionAlgorithm, base<btCollisionAlgorithm>>("btConvexPlaneCollisionAlgorithm")
	.constructor<p.btPersistentManifold,r.q(const).btCollisionAlgorithmConstructionInfo,p.q(const).btCollisionObjectWrapper,p.q(const).btCollisionObjectWrapper,bool,int,int>()
	.function("collideSingleContact", &btConvexPlaneCollisionAlgorithm::collideSingleContact)
	;
	class_<btDefaultCollisionConstructionInfo>("btDefaultCollisionConstructionInfo")
	constant("m_persistentManifoldPool", m_persistentManifoldPool);
	constant("m_collisionAlgorithmPool", m_collisionAlgorithmPool);
	constant("m_defaultMaxPersistentManifoldPoolSize", m_defaultMaxPersistentManifoldPoolSize);
	constant("m_defaultMaxCollisionAlgorithmPoolSize", m_defaultMaxCollisionAlgorithmPoolSize);
	constant("m_customCollisionAlgorithmMaxElementSize", m_customCollisionAlgorithmMaxElementSize);
	constant("m_useEpaPenetrationAlgorithm", m_useEpaPenetrationAlgorithm);
	;
	class_<btDefaultCollisionConfiguration, base<btCollisionConfiguration>>("btDefaultCollisionConfiguration")
	.constructor<r.q(const).btDefaultCollisionConstructionInfo>()
	.function("setConvexConvexMultipointIterations_int_int", select_overload<void(int, int)>(&btDefaultCollisionConfiguration::setConvexConvexMultipointIterations))
	.function("setConvexConvexMultipointIterations_int", select_overload<void(int)>(&btDefaultCollisionConfiguration::setConvexConvexMultipointIterations))
	.function("setConvexConvexMultipointIterations", select_overload<void()>(&btDefaultCollisionConfiguration::setConvexConvexMultipointIterations))
	.function("setPlaneConvexMultipointIterations_int_int", select_overload<void(int, int)>(&btDefaultCollisionConfiguration::setPlaneConvexMultipointIterations))
	.function("setPlaneConvexMultipointIterations_int", select_overload<void(int)>(&btDefaultCollisionConfiguration::setPlaneConvexMultipointIterations))
	.function("setPlaneConvexMultipointIterations", select_overload<void()>(&btDefaultCollisionConfiguration::setPlaneConvexMultipointIterations))
	;
	class_<btEmptyAlgorithm, base<btCollisionAlgorithm>>("btEmptyAlgorithm")
	.constructor<r.q(const).btCollisionAlgorithmConstructionInfo>()
	;
	class_<btGhostObject, base<btCollisionObject>>("btGhostObject")
	.function("convexSweepTest_p.q(const).btConvexShape_r.q(const).btTransform_r.q(const).btTransform_r.btCollisionWorld::ConvexResultCallback_btScalar", select_overload<void(p.q(const).btConvexShape, r.q(const).btTransform, r.q(const).btTransform, r.btCollisionWorld::ConvexResultCallback, btScalar)const>(&btGhostObject::convexSweepTest))
	.function("convexSweepTest_p.q(const).btConvexShape_r.q(const).btTransform_r.q(const).btTransform_r.btCollisionWorld::ConvexResultCallback", select_overload<void(p.q(const).btConvexShape, r.q(const).btTransform, r.q(const).btTransform, r.btCollisionWorld::ConvexResultCallback)const>(&btGhostObject::convexSweepTest))
	.function("rayTest", &btGhostObject::rayTest)
	.function("addOverlappingObjectInternal_p.btBroadphaseProxy_p.btBroadphaseProxy", select_overload<void(p.btBroadphaseProxy, p.btBroadphaseProxy)>(&btGhostObject::addOverlappingObjectInternal))
	.function("addOverlappingObjectInternal_p.btBroadphaseProxy", select_overload<void(p.btBroadphaseProxy)>(&btGhostObject::addOverlappingObjectInternal))
	.function("removeOverlappingObjectInternal_p.btBroadphaseProxy_p.btDispatcher_p.btBroadphaseProxy", select_overload<void(p.btBroadphaseProxy, p.btDispatcher, p.btBroadphaseProxy)>(&btGhostObject::removeOverlappingObjectInternal))
	.function("removeOverlappingObjectInternal_p.btBroadphaseProxy_p.btDispatcher", select_overload<void(p.btBroadphaseProxy, p.btDispatcher)>(&btGhostObject::removeOverlappingObjectInternal))
	.function("getNumOverlappingObjects", &btGhostObject::getNumOverlappingObjects)
	.function("getOverlappingObject_int", select_overload<btCollisionObject(int)>(&btGhostObject::getOverlappingObject))
	.function("getOverlappingObject_int", select_overload<q(const).btCollisionObject(int)const>(&btGhostObject::getOverlappingObject))
	.function("getOverlappingPairs", &btGhostObject::getOverlappingPairs)
	.function("getOverlappingPairs", &btGhostObject::getOverlappingPairs)
	.class_function("upcast", &btGhostObject::upcast)
	.class_function("upcast", &btGhostObject::upcast)
	;
	class_<btPairCachingGhostObject, base<btGhostObject>>("btPairCachingGhostObject")
	.function("addOverlappingObjectInternal_p.btBroadphaseProxy_p.btBroadphaseProxy", select_overload<void(p.btBroadphaseProxy, p.btBroadphaseProxy)>(&btPairCachingGhostObject::addOverlappingObjectInternal))
	.function("addOverlappingObjectInternal_p.btBroadphaseProxy", select_overload<void(p.btBroadphaseProxy)>(&btPairCachingGhostObject::addOverlappingObjectInternal))
	.function("removeOverlappingObjectInternal_p.btBroadphaseProxy_p.btDispatcher_p.btBroadphaseProxy", select_overload<void(p.btBroadphaseProxy, p.btDispatcher, p.btBroadphaseProxy)>(&btPairCachingGhostObject::removeOverlappingObjectInternal))
	.function("removeOverlappingObjectInternal_p.btBroadphaseProxy_p.btDispatcher", select_overload<void(p.btBroadphaseProxy, p.btDispatcher)>(&btPairCachingGhostObject::removeOverlappingObjectInternal))
	.function("getOverlappingPairCache", &btPairCachingGhostObject::getOverlappingPairCache)
	;
	class_<btGhostPairCallback, base<btOverlappingPairCallback>>("btGhostPairCallback")
	;
	constant("BT_HASH_NULL", BT_HASH_NULL);
	class_<btHashInt>("btHashInt")
	.constructor<int>()
	.function("getUid1", &btHashInt::getUid1)
	.function("setUid1", &btHashInt::setUid1)
	.function("equals", &btHashInt::equals)
	.function("getHash", &btHashInt::getHash)
	;
	class_<btHashPtr>("btHashPtr")
	.constructor<p.q(const).void>()
	.function("getPointer", &btHashPtr::getPointer)
	.function("equals", &btHashPtr::equals)
	.function("getHash", &btHashPtr::getHash)
	;
	constant("sBulletDNAstr", sBulletDNAstr);
	constant("sBulletDNAlen", sBulletDNAlen);
	constant("sBulletDNAstr64", sBulletDNAstr64);
	constant("sBulletDNAlen64", sBulletDNAlen64);
	function("btStrLen", &btStrLen);
	class_<btChunk>("btChunk")
	;
	enum_<btSerializationFlags>("btSerializationFlags")
		.value("BT_SERIALIZE_NO_BVH", BT_SERIALIZE_NO_BVH)
		.value("BT_SERIALIZE_NO_TRIANGLEINFOMAP", BT_SERIALIZE_NO_TRIANGLEINFOMAP)
		.value("BT_SERIALIZE_NO_DUPLICATE_ASSERT", BT_SERIALIZE_NO_DUPLICATE_ASSERT)
		;
	class_<btSerializer>("btSerializer")
	.function("getBufferPointer", &btSerializer::getBufferPointer)
	.function("getCurrentBufferSize", &btSerializer::getCurrentBufferSize)
	.function("allocate", &btSerializer::allocate)
	.function("finalizeChunk", &btSerializer::finalizeChunk)
	.function("findPointer", &btSerializer::findPointer)
	.function("getUniquePointer", &btSerializer::getUniquePointer)
	.function("startSerialization", &btSerializer::startSerialization)
	.function("finishSerialization", &btSerializer::finishSerialization)
	.function("findNameForPointer", &btSerializer::findNameForPointer)
	.function("registerNameForPointer", &btSerializer::registerNameForPointer)
	.function("serializeName", &btSerializer::serializeName)
	.function("getSerializationFlags", &btSerializer::getSerializationFlags)
	.function("setSerializationFlags", &btSerializer::setSerializationFlags)
	.function("getNumChunks", &btSerializer::getNumChunks)
	.function("getChunk", &btSerializer::getChunk)
	;
	class_<btPointerUid>("btPointerUid")
	;
	class_<btBulletSerializedArrays>("btBulletSerializedArrays")
	constant("m_bvhsDouble", m_bvhsDouble);
	constant("m_bvhsFloat", m_bvhsFloat);
	constant("m_colShapeData", m_colShapeData);
	constant("m_dynamicWorldInfoDataDouble", m_dynamicWorldInfoDataDouble);
	constant("m_dynamicWorldInfoDataFloat", m_dynamicWorldInfoDataFloat);
	constant("m_rigidBodyDataDouble", m_rigidBodyDataDouble);
	constant("m_rigidBodyDataFloat", m_rigidBodyDataFloat);
	constant("m_collisionObjectDataDouble", m_collisionObjectDataDouble);
	constant("m_collisionObjectDataFloat", m_collisionObjectDataFloat);
	constant("m_constraintDataFloat", m_constraintDataFloat);
	constant("m_constraintDataDouble", m_constraintDataDouble);
	constant("m_constraintData", m_constraintData);
	constant("m_softBodyFloatData", m_softBodyFloatData);
	constant("m_softBodyDoubleData", m_softBodyDoubleData);
	;
	class_<btDefaultSerializer, base<btSerializer>>("btDefaultSerializer")
	.function("findPointer", &btDefaultSerializer::findPointer)
	.function("writeDNA", &btDefaultSerializer::writeDNA)
	.function("getReverseType", &btDefaultSerializer::getReverseType)
	.function("initDNA", &btDefaultSerializer::initDNA)
	.constructor<int,p.unsigned char>()
	.constructor<int>()
	.class_function("getMemoryDnaSizeInBytes", &btDefaultSerializer::getMemoryDnaSizeInBytes)
	.class_function("getMemoryDna", &btDefaultSerializer::getMemoryDna)
	.function("insertHeader", &btDefaultSerializer::insertHeader)
	.function("writeHeader", &btDefaultSerializer::writeHeader)
	.function("internalAlloc", &btDefaultSerializer::internalAlloc)
	;
	class_<btTriangleInfo>("btTriangleInfo")
	constant("m_flags", m_flags);
	constant("m_edgeV0V1Angle", m_edgeV0V1Angle);
	constant("m_edgeV1V2Angle", m_edgeV1V2Angle);
	constant("m_edgeV2V0Angle", m_edgeV2V0Angle);
	;
	class_<btTriangleInfoMap, base<btInternalTriangleInfoMap>>("btTriangleInfoMap")
	constant("m_convexEpsilon", m_convexEpsilon);
	constant("m_planarEpsilon", m_planarEpsilon);
	constant("m_equalVertexThreshold", m_equalVertexThreshold);
	constant("m_edgeDistanceThreshold", m_edgeDistanceThreshold);
	constant("m_maxEdgeAngleThreshold", m_maxEdgeAngleThreshold);
	constant("m_zeroAreaThreshold", m_zeroAreaThreshold);
	.function("calculateSerializeBufferSize", &btTriangleInfoMap::calculateSerializeBufferSize)
	.function("serialize", &btTriangleInfoMap::serialize)
	.function("deSerialize", &btTriangleInfoMap::deSerialize)
	;
	class_<btTriangleInfoData>("btTriangleInfoData")
	constant("m_flags", m_flags);
	constant("m_edgeV0V1Angle", m_edgeV0V1Angle);
	constant("m_edgeV1V2Angle", m_edgeV1V2Angle);
	constant("m_edgeV2V0Angle", m_edgeV2V0Angle);
	;
	class_<btTriangleInfoMapData>("btTriangleInfoMapData")
	constant("m_hashTablePtr", m_hashTablePtr);
	constant("m_nextPtr", m_nextPtr);
	constant("m_valueArrayPtr", m_valueArrayPtr);
	constant("m_keyArrayPtr", m_keyArrayPtr);
	constant("m_convexEpsilon", m_convexEpsilon);
	constant("m_planarEpsilon", m_planarEpsilon);
	constant("m_equalVertexThreshold", m_equalVertexThreshold);
	constant("m_edgeDistanceThreshold", m_edgeDistanceThreshold);
	constant("m_zeroAreaThreshold", m_zeroAreaThreshold);
	constant("m_nextSize", m_nextSize);
	constant("m_hashTableSize", m_hashTableSize);
	constant("m_numValues", m_numValues);
	constant("m_numKeys", m_numKeys);
	constant("m_padding", m_padding);
	;
	enum_<btInternalEdgeAdjustFlags>("btInternalEdgeAdjustFlags")
		.value("BT_TRIANGLE_CONVEX_BACKFACE_MODE", BT_TRIANGLE_CONVEX_BACKFACE_MODE)
		.value("BT_TRIANGLE_CONCAVE_DOUBLE_SIDED", BT_TRIANGLE_CONCAVE_DOUBLE_SIDED)
		.value("BT_TRIANGLE_CONVEX_DOUBLE_SIDED", BT_TRIANGLE_CONVEX_DOUBLE_SIDED)
		;
	function("btGenerateInternalEdgeInfo", &btGenerateInternalEdgeInfo);
	function("btAdjustInternalEdgeContacts", &btAdjustInternalEdgeContacts);
	function("btAdjustInternalEdgeContacts", &btAdjustInternalEdgeContacts);
	class_<btElement>("btElement")
	constant("m_id", m_id);
	constant("m_sz", m_sz);
	;
	class_<btUnionFind>("btUnionFind")
	.function("sortIslands", &btUnionFind::sortIslands)
	.function("reset", &btUnionFind::reset)
	.function("getNumElements", &btUnionFind::getNumElements)
	.function("isRoot", &btUnionFind::isRoot)
	.function("getElement_int", select_overload<btElement(int)>(&btUnionFind::getElement))
	.function("getElement_int", select_overload<q(const).btElement(int)const>(&btUnionFind::getElement))
	.function("allocate", &btUnionFind::allocate)
	.function("Free", &btUnionFind::Free)
	.function("find_int_int", select_overload<int(int, int)>(&btUnionFind::find))
	.function("unite", &btUnionFind::unite)
	.function("find_int", select_overload<int(int)>(&btUnionFind::find))
	;
	class_<btSimulationIslandManager>("btSimulationIslandManager")
	.function("initUnionFind", &btSimulationIslandManager::initUnionFind)
	.function("getUnionFind", &btSimulationIslandManager::getUnionFind)
	.function("updateActivationState", &btSimulationIslandManager::updateActivationState)
	.function("storeIslandActivationState", &btSimulationIslandManager::storeIslandActivationState)
	.function("findUnions", &btSimulationIslandManager::findUnions)
	.function("buildAndProcessIslands", &btSimulationIslandManager::buildAndProcessIslands)
	.function("buildIslands", &btSimulationIslandManager::buildIslands)
	.function("getSplitIslands", &btSimulationIslandManager::getSplitIslands)
	.function("setSplitIslands", &btSimulationIslandManager::setSplitIslands)
	;
	class_<btSphereBoxCollisionAlgorithm, base<btActivatingCollisionAlgorithm>>("btSphereBoxCollisionAlgorithm")
	.constructor<p.btPersistentManifold,r.q(const).btCollisionAlgorithmConstructionInfo,p.q(const).btCollisionObjectWrapper,p.q(const).btCollisionObjectWrapper,bool>()
	.function("getSphereDistance", &btSphereBoxCollisionAlgorithm::getSphereDistance)
	.function("getSpherePenetration", &btSphereBoxCollisionAlgorithm::getSpherePenetration)
	;
	class_<btSphereSphereCollisionAlgorithm, base<btActivatingCollisionAlgorithm>>("btSphereSphereCollisionAlgorithm")
	.constructor<p.btPersistentManifold,r.q(const).btCollisionAlgorithmConstructionInfo,p.q(const).btCollisionObjectWrapper,p.q(const).btCollisionObjectWrapper>()
	.constructor<r.q(const).btCollisionAlgorithmConstructionInfo>()
	;
	class_<btSphereTriangleCollisionAlgorithm, base<btActivatingCollisionAlgorithm>>("btSphereTriangleCollisionAlgorithm")
	.constructor<p.btPersistentManifold,r.q(const).btCollisionAlgorithmConstructionInfo,p.q(const).btCollisionObjectWrapper,p.q(const).btCollisionObjectWrapper,bool>()
	.constructor<r.q(const).btCollisionAlgorithmConstructionInfo>()
	;
	class_<SphereTriangleDetector, base<btDiscreteCollisionDetectorInterface>>("SphereTriangleDetector")
	.function("getClosestPoints_r.q(const).btDiscreteCollisionDetectorInterface::ClosestPointInput_r.btDiscreteCollisionDetectorInterface::Result_p.btIDebugDraw_bool", select_overload<void(r.q(const).btDiscreteCollisionDetectorInterface::ClosestPointInput, r.btDiscreteCollisionDetectorInterface::Result, p.btIDebugDraw, bool)>(&SphereTriangleDetector::getClosestPoints))
	.function("getClosestPoints_r.q(const).btDiscreteCollisionDetectorInterface::ClosestPointInput_r.btDiscreteCollisionDetectorInterface::Result_p.btIDebugDraw", select_overload<void(r.q(const).btDiscreteCollisionDetectorInterface::ClosestPointInput, r.btDiscreteCollisionDetectorInterface::Result, p.btIDebugDraw)>(&SphereTriangleDetector::getClosestPoints))
	.constructor<p.btSphereShape,p.btTriangleShape,btScalar>()
	.function("collide", &SphereTriangleDetector::collide)
	.function("pointInTriangle", &SphereTriangleDetector::pointInTriangle)
	.function("facecontains", &SphereTriangleDetector::facecontains)
	;
	class_<btCollisionShape>("btCollisionShape")
	.function("getAabb", &btCollisionShape::getAabb)
	.function("getBoundingSphere", &btCollisionShape::getBoundingSphere)
	.function("getAngularMotionDisc", &btCollisionShape::getAngularMotionDisc)
	.function("getContactBreakingThreshold", &btCollisionShape::getContactBreakingThreshold)
	.function("calculateTemporalAabb", &btCollisionShape::calculateTemporalAabb)
	.function("isPolyhedral", &btCollisionShape::isPolyhedral)
	.function("isConvex2d", &btCollisionShape::isConvex2d)
	.function("isConvex", &btCollisionShape::isConvex)
	.function("isNonMoving", &btCollisionShape::isNonMoving)
	.function("isConcave", &btCollisionShape::isConcave)
	.function("isCompound", &btCollisionShape::isCompound)
	.function("isSoftBody", &btCollisionShape::isSoftBody)
	.function("isInfinite", &btCollisionShape::isInfinite)
	.function("setLocalScaling", &btCollisionShape::setLocalScaling)
	.function("getLocalScaling", &btCollisionShape::getLocalScaling)
	.function("calculateLocalInertia", &btCollisionShape::calculateLocalInertia)
	.function("getName", &btCollisionShape::getName)
	.function("getShapeType", &btCollisionShape::getShapeType)
	.function("getAnisotropicRollingFrictionDirection", &btCollisionShape::getAnisotropicRollingFrictionDirection)
	.function("setMargin", &btCollisionShape::setMargin)
	.function("getMargin", &btCollisionShape::getMargin)
	.function("setUserPointer", &btCollisionShape::setUserPointer)
	.function("getUserPointer", &btCollisionShape::getUserPointer)
	.function("setUserIndex", &btCollisionShape::setUserIndex)
	.function("getUserIndex", &btCollisionShape::getUserIndex)
	.function("calculateSerializeBufferSize", &btCollisionShape::calculateSerializeBufferSize)
	.function("serialize", &btCollisionShape::serialize)
	.function("serializeSingleShape", &btCollisionShape::serializeSingleShape)
	;
	class_<btCollisionShapeData>("btCollisionShapeData")
	constant("m_name", m_name);
	constant("m_shapeType", m_shapeType);
	constant("m_padding", m_padding);
	;
	class_<btConvexShape, base<btCollisionShape>>("btConvexShape")
	.function("localGetSupportingVertex", &btConvexShape::localGetSupportingVertex)
	.function("localGetSupportingVertexWithoutMargin", &btConvexShape::localGetSupportingVertexWithoutMargin)
	.function("localGetSupportVertexWithoutMarginNonVirtual", &btConvexShape::localGetSupportVertexWithoutMarginNonVirtual)
	.function("localGetSupportVertexNonVirtual", &btConvexShape::localGetSupportVertexNonVirtual)
	.function("getMarginNonVirtual", &btConvexShape::getMarginNonVirtual)
	.function("getAabbNonVirtual", &btConvexShape::getAabbNonVirtual)
	.function("project", &btConvexShape::project)
	.function("batchedUnitVectorGetSupportingVertexWithoutMargin", &btConvexShape::batchedUnitVectorGetSupportingVertexWithoutMargin)
	.function("getAabbSlow", &btConvexShape::getAabbSlow)
	.function("getNumPreferredPenetrationDirections", &btConvexShape::getNumPreferredPenetrationDirections)
	.function("getPreferredPenetrationDirection", &btConvexShape::getPreferredPenetrationDirection)
	;
	class_<btConvexInternalShape, base<btConvexShape>>("btConvexInternalShape")
	.function("getImplicitShapeDimensions", &btConvexInternalShape::getImplicitShapeDimensions)
	.function("setImplicitShapeDimensions", &btConvexInternalShape::setImplicitShapeDimensions)
	.function("setSafeMargin_btScalar_btScalar", select_overload<void(btScalar, btScalar)>(&btConvexInternalShape::setSafeMargin))
	.function("setSafeMargin_btScalar", select_overload<void(btScalar)>(&btConvexInternalShape::setSafeMargin))
	.function("setSafeMargin_r.q(const).btVector3_btScalar", select_overload<void(r.q(const).btVector3, btScalar)>(&btConvexInternalShape::setSafeMargin))
	.function("setSafeMargin_r.q(const).btVector3", select_overload<void(r.q(const).btVector3)>(&btConvexInternalShape::setSafeMargin))
	.function("getLocalScalingNV", &btConvexInternalShape::getLocalScalingNV)
	.function("getMarginNV", &btConvexInternalShape::getMarginNV)
	;
	class_<btConvexInternalShapeData>("btConvexInternalShapeData")
	constant("m_collisionShapeData", m_collisionShapeData);
	constant("m_localScaling", m_localScaling);
	constant("m_implicitShapeDimensions", m_implicitShapeDimensions);
	constant("m_collisionMargin", m_collisionMargin);
	constant("m_padding", m_padding);
	;
	class_<btConvexInternalAabbCachingShape, base<btConvexInternalShape>>("btConvexInternalAabbCachingShape")
	.function("setCachedLocalAabb", &btConvexInternalAabbCachingShape::setCachedLocalAabb)
	.function("getCachedLocalAabb", &btConvexInternalAabbCachingShape::getCachedLocalAabb)
	.function("getNonvirtualAabb", &btConvexInternalAabbCachingShape::getNonvirtualAabb)
	.function("recalcLocalAabb", &btConvexInternalAabbCachingShape::recalcLocalAabb)
	;
	class_<btPolyhedralConvexShape, base<btConvexInternalShape>>("btPolyhedralConvexShape")
	.function("initializePolyhedralFeatures_int", select_overload<bool(int)>(&btPolyhedralConvexShape::initializePolyhedralFeatures))
	.function("initializePolyhedralFeatures", select_overload<bool()>(&btPolyhedralConvexShape::initializePolyhedralFeatures))
	.function("getConvexPolyhedron", &btPolyhedralConvexShape::getConvexPolyhedron)
	.function("getNumVertices", &btPolyhedralConvexShape::getNumVertices)
	.function("getNumEdges", &btPolyhedralConvexShape::getNumEdges)
	.function("getEdge", &btPolyhedralConvexShape::getEdge)
	.function("getVertex", &btPolyhedralConvexShape::getVertex)
	.function("getNumPlanes", &btPolyhedralConvexShape::getNumPlanes)
	.function("getPlane", &btPolyhedralConvexShape::getPlane)
	;
	class_<btPolyhedralConvexAabbCachingShape, base<btPolyhedralConvexShape>>("btPolyhedralConvexAabbCachingShape")
	.function("setCachedLocalAabb", &btPolyhedralConvexAabbCachingShape::setCachedLocalAabb)
	.function("getCachedLocalAabb", &btPolyhedralConvexAabbCachingShape::getCachedLocalAabb)
	.function("getNonvirtualAabb", &btPolyhedralConvexAabbCachingShape::getNonvirtualAabb)
	.function("recalcLocalAabb", &btPolyhedralConvexAabbCachingShape::recalcLocalAabb)
	;
	class_<btBox2dShape, base<btPolyhedralConvexShape>>("btBox2dShape")
	.function("getHalfExtentsWithMargin", &btBox2dShape::getHalfExtentsWithMargin)
	.function("getHalfExtentsWithoutMargin", &btBox2dShape::getHalfExtentsWithoutMargin)
	.constructor<r.q(const).btVector3>()
	.function("getVertexCount", &btBox2dShape::getVertexCount)
	.function("getVertices", &btBox2dShape::getVertices)
	.function("getNormals", &btBox2dShape::getNormals)
	.function("getCentroid", &btBox2dShape::getCentroid)
	.function("getPlaneEquation", &btBox2dShape::getPlaneEquation)
	;
	class_<btBoxShape, base<btPolyhedralConvexShape>>("btBoxShape")
	.function("getHalfExtentsWithMargin", &btBoxShape::getHalfExtentsWithMargin)
	.function("getHalfExtentsWithoutMargin", &btBoxShape::getHalfExtentsWithoutMargin)
	.constructor<r.q(const).btVector3>()
	.function("getPlaneEquation", &btBoxShape::getPlaneEquation)
	;
	enum_<PHY_ScalarType>("PHY_ScalarType")
		.value("PHY_FLOAT", PHY_FLOAT)
		.value("PHY_DOUBLE", PHY_DOUBLE)
		.value("PHY_INTEGER", PHY_INTEGER)
		.value("PHY_SHORT", PHY_SHORT)
		.value("PHY_FIXEDPOINT88", PHY_FIXEDPOINT88)
		.value("PHY_UCHAR", PHY_UCHAR)
		;
	class_<btConcaveShape, base<btCollisionShape>>("btConcaveShape")
	.function("processAllTriangles", &btConcaveShape::processAllTriangles)
	;
	class_<btStridingMeshInterface>("btStridingMeshInterface")
	.function("InternalProcessAllTriangles", &btStridingMeshInterface::InternalProcessAllTriangles)
	.function("calculateAabbBruteForce", &btStridingMeshInterface::calculateAabbBruteForce)
	.function("getLockedVertexIndexBase_p.p.unsigned char_r.int_r.PHY_ScalarType_r.int_p.p.unsigned char_r.int_r.int_r.PHY_ScalarType_int", select_overload<void(p.p.unsigned char, r.int, r.PHY_ScalarType, r.int, p.p.unsigned char, r.int, r.int, r.PHY_ScalarType, int)>(&btStridingMeshInterface::getLockedVertexIndexBase))
	.function("getLockedVertexIndexBase_p.p.unsigned char_r.int_r.PHY_ScalarType_r.int_p.p.unsigned char_r.int_r.int_r.PHY_ScalarType", select_overload<void(p.p.unsigned char, r.int, r.PHY_ScalarType, r.int, p.p.unsigned char, r.int, r.int, r.PHY_ScalarType)>(&btStridingMeshInterface::getLockedVertexIndexBase))
	.function("getLockedReadOnlyVertexIndexBase_p.p.q(const).unsigned char_r.int_r.PHY_ScalarType_r.int_p.p.q(const).unsigned char_r.int_r.int_r.PHY_ScalarType_int", select_overload<void(p.p.q(const).unsigned char, r.int, r.PHY_ScalarType, r.int, p.p.q(const).unsigned char, r.int, r.int, r.PHY_ScalarType, int)const>(&btStridingMeshInterface::getLockedReadOnlyVertexIndexBase))
	.function("getLockedReadOnlyVertexIndexBase_p.p.q(const).unsigned char_r.int_r.PHY_ScalarType_r.int_p.p.q(const).unsigned char_r.int_r.int_r.PHY_ScalarType", select_overload<void(p.p.q(const).unsigned char, r.int, r.PHY_ScalarType, r.int, p.p.q(const).unsigned char, r.int, r.int, r.PHY_ScalarType)const>(&btStridingMeshInterface::getLockedReadOnlyVertexIndexBase))
	.function("unLockVertexBase", &btStridingMeshInterface::unLockVertexBase)
	.function("unLockReadOnlyVertexBase", &btStridingMeshInterface::unLockReadOnlyVertexBase)
	.function("getNumSubParts", &btStridingMeshInterface::getNumSubParts)
	.function("preallocateVertices", &btStridingMeshInterface::preallocateVertices)
	.function("preallocateIndices", &btStridingMeshInterface::preallocateIndices)
	.function("hasPremadeAabb", &btStridingMeshInterface::hasPremadeAabb)
	.function("setPremadeAabb", &btStridingMeshInterface::setPremadeAabb)
	.function("getPremadeAabb", &btStridingMeshInterface::getPremadeAabb)
	.function("getScaling", &btStridingMeshInterface::getScaling)
	.function("setScaling", &btStridingMeshInterface::setScaling)
	.function("calculateSerializeBufferSize", &btStridingMeshInterface::calculateSerializeBufferSize)
	.function("serialize", &btStridingMeshInterface::serialize)
	;
	class_<btIntIndexData>("btIntIndexData")
	constant("m_value", m_value);
	;
	class_<btShortIntIndexData>("btShortIntIndexData")
	constant("m_value", m_value);
	constant("m_pad", m_pad);
	;
	class_<btShortIntIndexTripletData>("btShortIntIndexTripletData")
	constant("m_values", m_values);
	constant("m_pad", m_pad);
	;
	class_<btCharIndexTripletData>("btCharIndexTripletData")
	constant("m_values", m_values);
	constant("m_pad", m_pad);
	;
	class_<btMeshPartData>("btMeshPartData")
	constant("m_vertices3f", m_vertices3f);
	constant("m_vertices3d", m_vertices3d);
	constant("m_indices32", m_indices32);
	constant("m_3indices16", m_3indices16);
	constant("m_3indices8", m_3indices8);
	constant("m_indices16", m_indices16);
	constant("m_numTriangles", m_numTriangles);
	constant("m_numVertices", m_numVertices);
	;
	class_<btStridingMeshInterfaceData>("btStridingMeshInterfaceData")
	constant("m_meshPartsPtr", m_meshPartsPtr);
	constant("m_scaling", m_scaling);
	constant("m_numMeshParts", m_numMeshParts);
	constant("m_padding", m_padding);
	;
	class_<btTriangleMeshShape, base<btConcaveShape>>("btTriangleMeshShape")
	.constructor<p.btStridingMeshInterface>()
	.function("localGetSupportingVertex", &btTriangleMeshShape::localGetSupportingVertex)
	.function("localGetSupportingVertexWithoutMargin", &btTriangleMeshShape::localGetSupportingVertexWithoutMargin)
	.function("recalcLocalAabb", &btTriangleMeshShape::recalcLocalAabb)
	.function("getMeshInterface", select_overload<btStridingMeshInterface()>(&btTriangleMeshShape::getMeshInterface))
	.function("getMeshInterface", select_overload<q(const).btStridingMeshInterface()const>(&btTriangleMeshShape::getMeshInterface))
	.function("getLocalAabbMin", &btTriangleMeshShape::getLocalAabbMin)
	.function("getLocalAabbMax", &btTriangleMeshShape::getLocalAabbMax)
	;
	class_<btOptimizedBvh, base<btQuantizedBvh>>("btOptimizedBvh")
	.function("build", &btOptimizedBvh::build)
	.function("refit", &btOptimizedBvh::refit)
	.function("refitPartial", &btOptimizedBvh::refitPartial)
	.function("updateBvhNodes", &btOptimizedBvh::updateBvhNodes)
	.function("serializeInPlace", &btOptimizedBvh::serializeInPlace)
	.class_function("deSerializeInPlace", &btOptimizedBvh::deSerializeInPlace)
	;
	class_<btBvhTriangleMeshShape, base<btTriangleMeshShape>>("btBvhTriangleMeshShape")
	.constructor<p.btStridingMeshInterface,bool,bool>()
	.constructor<p.btStridingMeshInterface,bool>()
	.constructor<p.btStridingMeshInterface,bool,r.q(const).btVector3,r.q(const).btVector3,bool>()
	.constructor<p.btStridingMeshInterface,bool,r.q(const).btVector3,r.q(const).btVector3>()
	.function("getOwnsBvh", &btBvhTriangleMeshShape::getOwnsBvh)
	.function("performRaycast", &btBvhTriangleMeshShape::performRaycast)
	.function("performConvexcast", &btBvhTriangleMeshShape::performConvexcast)
	.function("refitTree", &btBvhTriangleMeshShape::refitTree)
	.function("partialRefitTree", &btBvhTriangleMeshShape::partialRefitTree)
	.function("getOptimizedBvh", &btBvhTriangleMeshShape::getOptimizedBvh)
	.function("setOptimizedBvh_p.btOptimizedBvh_r.q(const).btVector3", select_overload<void(p.btOptimizedBvh, r.q(const).btVector3)>(&btBvhTriangleMeshShape::setOptimizedBvh))
	.function("setOptimizedBvh_p.btOptimizedBvh", select_overload<void(p.btOptimizedBvh)>(&btBvhTriangleMeshShape::setOptimizedBvh))
	.function("buildOptimizedBvh", &btBvhTriangleMeshShape::buildOptimizedBvh)
	.function("usesQuantizedAabbCompression", &btBvhTriangleMeshShape::usesQuantizedAabbCompression)
	.function("setTriangleInfoMap", &btBvhTriangleMeshShape::setTriangleInfoMap)
	.function("getTriangleInfoMap", select_overload<q(const).btTriangleInfoMap()const>(&btBvhTriangleMeshShape::getTriangleInfoMap))
	.function("getTriangleInfoMap", select_overload<btTriangleInfoMap()>(&btBvhTriangleMeshShape::getTriangleInfoMap))
	.function("serializeSingleBvh", &btBvhTriangleMeshShape::serializeSingleBvh)
	.function("serializeSingleTriangleInfoMap", &btBvhTriangleMeshShape::serializeSingleTriangleInfoMap)
	;
	class_<btTriangleMeshShapeData>("btTriangleMeshShapeData")
	constant("m_collisionShapeData", m_collisionShapeData);
	constant("m_meshInterface", m_meshInterface);
	constant("m_quantizedFloatBvh", m_quantizedFloatBvh);
	constant("m_quantizedDoubleBvh", m_quantizedDoubleBvh);
	constant("m_triangleInfoMap", m_triangleInfoMap);
	constant("m_collisionMargin", m_collisionMargin);
	constant("m_pad3", m_pad3);
	;
	class_<btCapsuleShape, base<btConvexInternalShape>>("btCapsuleShape")
	.constructor<btScalar,btScalar>()
	.function("getUpAxis", &btCapsuleShape::getUpAxis)
	.function("getRadius", &btCapsuleShape::getRadius)
	.function("getHalfHeight", &btCapsuleShape::getHalfHeight)
	.function("deSerializeFloat", &btCapsuleShape::deSerializeFloat)
	;
	class_<btCapsuleShapeX, base<btCapsuleShape>>("btCapsuleShapeX")
	.constructor<btScalar,btScalar>()
	;
	class_<btCapsuleShapeZ, base<btCapsuleShape>>("btCapsuleShapeZ")
	.constructor<btScalar,btScalar>()
	;
	class_<btCapsuleShapeData>("btCapsuleShapeData")
	constant("m_convexInternalShapeData", m_convexInternalShapeData);
	constant("m_upAxis", m_upAxis);
	constant("m_padding", m_padding);
	;
	class_<btCompoundShapeChild>("btCompoundShapeChild")
	constant("m_transform", m_transform);
	constant("m_childShape", m_childShape);
	constant("m_childShapeType", m_childShapeType);
	constant("m_childMargin", m_childMargin);
	constant("m_node", m_node);
	;
	class_<btCompoundShape, base<btCollisionShape>>("btCompoundShape")
	.constructor<bool,q(const).int>()
	.constructor<bool>()
	.function("addChildShape", &btCompoundShape::addChildShape)
	.function("removeChildShape", &btCompoundShape::removeChildShape)
	.function("removeChildShapeByIndex", &btCompoundShape::removeChildShapeByIndex)
	.function("getNumChildShapes", &btCompoundShape::getNumChildShapes)
	.function("getChildShape_int", select_overload<btCollisionShape(int)>(&btCompoundShape::getChildShape))
	.function("getChildShape_int", select_overload<q(const).btCollisionShape(int)const>(&btCompoundShape::getChildShape))
	.function("getChildTransform_int", select_overload<btTransform(int)>(&btCompoundShape::getChildTransform))
	.function("getChildTransform_int", select_overload<q(const).btTransform(int)const>(&btCompoundShape::getChildTransform))
	.function("updateChildTransform_int_r.q(const).btTransform_bool", select_overload<void(int, r.q(const).btTransform, bool)>(&btCompoundShape::updateChildTransform))
	.function("updateChildTransform_int_r.q(const).btTransform", select_overload<void(int, r.q(const).btTransform)>(&btCompoundShape::updateChildTransform))
	.function("getChildList", &btCompoundShape::getChildList)
	.function("recalculateLocalAabb", &btCompoundShape::recalculateLocalAabb)
	.function("getDynamicAabbTree", select_overload<q(const).btDbvt()const>(&btCompoundShape::getDynamicAabbTree))
	.function("getDynamicAabbTree", select_overload<btDbvt()>(&btCompoundShape::getDynamicAabbTree))
	.function("createAabbTreeFromChildren", &btCompoundShape::createAabbTreeFromChildren)
	.function("calculatePrincipalAxisTransform", &btCompoundShape::calculatePrincipalAxisTransform)
	.function("getUpdateRevision", &btCompoundShape::getUpdateRevision)
	;
	class_<btCompoundShapeChildData>("btCompoundShapeChildData")
	constant("m_transform", m_transform);
	constant("m_childShape", m_childShape);
	constant("m_childShapeType", m_childShapeType);
	constant("m_childMargin", m_childMargin);
	;
	class_<btCompoundShapeData>("btCompoundShapeData")
	constant("m_collisionShapeData", m_collisionShapeData);
	constant("m_childShapePtr", m_childShapePtr);
	constant("m_numChildShapes", m_numChildShapes);
	constant("m_collisionMargin", m_collisionMargin);
	;
	class_<btConeShape, base<btConvexInternalShape>>("btConeShape")
	.function("coneLocalSupport", &btConeShape::coneLocalSupport)
	.constructor<btScalar,btScalar>()
	.function("getRadius", &btConeShape::getRadius)
	.function("getHeight", &btConeShape::getHeight)
	.function("setRadius", &btConeShape::setRadius)
	.function("setHeight", &btConeShape::setHeight)
	.function("setConeUpIndex", &btConeShape::setConeUpIndex)
	.function("getConeUpIndex", &btConeShape::getConeUpIndex)
	;
	class_<btConeShapeX, base<btConeShape>>("btConeShapeX")
	.constructor<btScalar,btScalar>()
	;
	class_<btConeShapeZ, base<btConeShape>>("btConeShapeZ")
	.constructor<btScalar,btScalar>()
	;
	class_<btConeShapeData>("btConeShapeData")
	constant("m_convexInternalShapeData", m_convexInternalShapeData);
	constant("m_upIndex", m_upIndex);
	constant("m_padding", m_padding);
	;
	class_<btConvex2dShape, base<btConvexShape>>("btConvex2dShape")
	.constructor<p.btConvexShape>()
	.function("getChildShape", select_overload<btConvexShape()>(&btConvex2dShape::getChildShape))
	.function("getChildShape", select_overload<q(const).btConvexShape()const>(&btConvex2dShape::getChildShape))
	;
	class_<btConvexHullShape, base<btPolyhedralConvexAabbCachingShape>>("btConvexHullShape")
	.constructor<p.q(const).btScalar,int,int>()
	.constructor<p.q(const).btScalar,int>()
	.constructor<p.q(const).btScalar>()
	.function("addPoint_r.q(const).btVector3_bool", select_overload<void(r.q(const).btVector3, bool)>(&btConvexHullShape::addPoint))
	.function("addPoint_r.q(const).btVector3", select_overload<void(r.q(const).btVector3)>(&btConvexHullShape::addPoint))
	.function("getUnscaledPoints", select_overload<btVector3()>(&btConvexHullShape::getUnscaledPoints))
	.function("getUnscaledPoints", select_overload<q(const).btVector3()const>(&btConvexHullShape::getUnscaledPoints))
	.function("getPoints", &btConvexHullShape::getPoints)
	.function("optimizeConvexHull", &btConvexHullShape::optimizeConvexHull)
	.function("getScaledPoint", &btConvexHullShape::getScaledPoint)
	.function("getNumPoints", &btConvexHullShape::getNumPoints)
	;
	class_<btConvexHullShapeData>("btConvexHullShapeData")
	constant("m_convexInternalShapeData", m_convexInternalShapeData);
	constant("m_unscaledPointsFloatPtr", m_unscaledPointsFloatPtr);
	constant("m_unscaledPointsDoublePtr", m_unscaledPointsDoublePtr);
	constant("m_numUnscaledPoints", m_numUnscaledPoints);
	constant("m_padding3", m_padding3);
	;
	class_<btConvexPointCloudShape, base<btPolyhedralConvexAabbCachingShape>>("btConvexPointCloudShape")
	.constructor<p.btVector3,int,r.q(const).btVector3,bool>()
	.constructor<p.btVector3,int,r.q(const).btVector3>()
	.function("setPoints_p.btVector3_int_bool_r.q(const).btVector3", select_overload<void(p.btVector3, int, bool, r.q(const).btVector3)>(&btConvexPointCloudShape::setPoints))
	.function("setPoints_p.btVector3_int_bool", select_overload<void(p.btVector3, int, bool)>(&btConvexPointCloudShape::setPoints))
	.function("setPoints_p.btVector3_int", select_overload<void(p.btVector3, int)>(&btConvexPointCloudShape::setPoints))
	.function("getUnscaledPoints", select_overload<btVector3()>(&btConvexPointCloudShape::getUnscaledPoints))
	.function("getUnscaledPoints", select_overload<q(const).btVector3()const>(&btConvexPointCloudShape::getUnscaledPoints))
	.function("getNumPoints", &btConvexPointCloudShape::getNumPoints)
	.function("getScaledPoint", &btConvexPointCloudShape::getScaledPoint)
	;
	class_<btFace>("btFace")
	constant("m_indices", m_indices);
	constant("m_plane", m_plane);
	;
	class_<btConvexPolyhedron>("btConvexPolyhedron")
	.function("initialize", &btConvexPolyhedron::initialize)
	.function("testContainment", &btConvexPolyhedron::testContainment)
	.function("project", &btConvexPolyhedron::project)
	;
	class_<btConvexTriangleMeshShape, base<btPolyhedralConvexAabbCachingShape>>("btConvexTriangleMeshShape")
	.constructor<p.btStridingMeshInterface,bool>()
	.constructor<p.btStridingMeshInterface>()
	.function("getMeshInterface", select_overload<btStridingMeshInterface()>(&btConvexTriangleMeshShape::getMeshInterface))
	.function("getMeshInterface", select_overload<q(const).btStridingMeshInterface()const>(&btConvexTriangleMeshShape::getMeshInterface))
	.function("calculatePrincipalAxisTransform", &btConvexTriangleMeshShape::calculatePrincipalAxisTransform)
	;
	class_<btCylinderShape, base<btConvexInternalShape>>("btCylinderShape")
	.function("getHalfExtentsWithMargin", &btCylinderShape::getHalfExtentsWithMargin)
	.function("getHalfExtentsWithoutMargin", &btCylinderShape::getHalfExtentsWithoutMargin)
	.constructor<r.q(const).btVector3>()
	.function("getUpAxis", &btCylinderShape::getUpAxis)
	.function("getRadius", &btCylinderShape::getRadius)
	;
	class_<btCylinderShapeX, base<btCylinderShape>>("btCylinderShapeX")
	.constructor<r.q(const).btVector3>()
	;
	class_<btCylinderShapeZ, base<btCylinderShape>>("btCylinderShapeZ")
	.constructor<r.q(const).btVector3>()
	;
	class_<btCylinderShapeData>("btCylinderShapeData")
	constant("m_convexInternalShapeData", m_convexInternalShapeData);
	constant("m_upAxis", m_upAxis);
	constant("m_padding", m_padding);
	;
	class_<btEmptyShape, base<btConcaveShape>>("btEmptyShape")
	;
	class_<btHeightfieldTerrainShape, base<btConcaveShape>>("btHeightfieldTerrainShape")
	.function("getRawHeightFieldValue", &btHeightfieldTerrainShape::getRawHeightFieldValue)
	.function("quantizeWithClamp", &btHeightfieldTerrainShape::quantizeWithClamp)
	.function("getVertex", &btHeightfieldTerrainShape::getVertex)
	.function("initialize", &btHeightfieldTerrainShape::initialize)
	.constructor<int,int,p.q(const).void,btScalar,btScalar,btScalar,int,PHY_ScalarType,bool>()
	.constructor<int,int,p.q(const).void,btScalar,int,bool,bool>()
	.function("setUseDiamondSubdivision_bool", select_overload<void(bool)>(&btHeightfieldTerrainShape::setUseDiamondSubdivision))
	.function("setUseDiamondSubdivision", select_overload<void()>(&btHeightfieldTerrainShape::setUseDiamondSubdivision))
	.function("setUseZigzagSubdivision_bool", select_overload<void(bool)>(&btHeightfieldTerrainShape::setUseZigzagSubdivision))
	.function("setUseZigzagSubdivision", select_overload<void()>(&btHeightfieldTerrainShape::setUseZigzagSubdivision))
	;
	class_<btMaterial>("btMaterial")
	.constructor<btScalar,btScalar>()
	;
	class_<btMinkowskiSumShape, base<btConvexInternalShape>>("btMinkowskiSumShape")
	.constructor<p.q(const).btConvexShape,p.q(const).btConvexShape>()
	.function("setTransformA", &btMinkowskiSumShape::setTransformA)
	.function("setTransformB", &btMinkowskiSumShape::setTransformB)
	.function("getTransformA", &btMinkowskiSumShape::getTransformA)
	.function("GetTransformB", &btMinkowskiSumShape::GetTransformB)
	.function("getShapeA", &btMinkowskiSumShape::getShapeA)
	.function("getShapeB", &btMinkowskiSumShape::getShapeB)
	;
	class_<btMultimaterialTriangleMeshShape, base<btBvhTriangleMeshShape>>("btMultimaterialTriangleMeshShape")
	.constructor<p.btStridingMeshInterface,bool,bool>()
	.constructor<p.btStridingMeshInterface,bool>()
	.constructor<p.btStridingMeshInterface,bool,r.q(const).btVector3,r.q(const).btVector3,bool>()
	.constructor<p.btStridingMeshInterface,bool,r.q(const).btVector3,r.q(const).btVector3>()
	.function("getMaterialProperties", &btMultimaterialTriangleMeshShape::getMaterialProperties)
	;
	class_<btMultiSphereShape, base<btConvexInternalAabbCachingShape>>("btMultiSphereShape")
	.constructor<p.q(const).btVector3,p.q(const).btScalar,int>()
	.function("getSphereCount", &btMultiSphereShape::getSphereCount)
	.function("getSpherePosition", &btMultiSphereShape::getSpherePosition)
	.function("getSphereRadius", &btMultiSphereShape::getSphereRadius)
	;
	class_<btPositionAndRadius>("btPositionAndRadius")
	constant("m_pos", m_pos);
	constant("m_radius", m_radius);
	;
	class_<btMultiSphereShapeData>("btMultiSphereShapeData")
	constant("m_convexInternalShapeData", m_convexInternalShapeData);
	constant("m_localPositionArrayPtr", m_localPositionArrayPtr);
	constant("m_localPositionArraySize", m_localPositionArraySize);
	constant("m_padding", m_padding);
	;
	class_<btScaledBvhTriangleMeshShape, base<btConcaveShape>>("btScaledBvhTriangleMeshShape")
	.constructor<p.btBvhTriangleMeshShape,r.q(const).btVector3>()
	.function("getChildShape", select_overload<btBvhTriangleMeshShape()>(&btScaledBvhTriangleMeshShape::getChildShape))
	.function("getChildShape", select_overload<q(const).btBvhTriangleMeshShape()const>(&btScaledBvhTriangleMeshShape::getChildShape))
	;
	class_<btScaledTriangleMeshShapeData>("btScaledTriangleMeshShapeData")
	constant("m_trimeshShapeData", m_trimeshShapeData);
	constant("m_localScaling", m_localScaling);
	;
	class_<btShapeHull>("btShapeHull")
	.class_function("getUnitSpherePoints", &btShapeHull::getUnitSpherePoints)
	.constructor<p.q(const).btConvexShape>()
	.function("buildHull", &btShapeHull::buildHull)
	.function("numTriangles", &btShapeHull::numTriangles)
	.function("numVertices", &btShapeHull::numVertices)
	.function("numIndices", &btShapeHull::numIndices)
	.function("getVertexPointer", &btShapeHull::getVertexPointer)
	.function("getIndexPointer", &btShapeHull::getIndexPointer)
	;
	class_<btSphereShape, base<btConvexInternalShape>>("btSphereShape")
	.constructor<btScalar>()
	.function("getRadius", &btSphereShape::getRadius)
	.function("setUnscaledRadius", &btSphereShape::setUnscaledRadius)
	;
	class_<btStaticPlaneShape, base<btConcaveShape>>("btStaticPlaneShape")
	.constructor<r.q(const).btVector3,btScalar>()
	.function("getPlaneNormal", &btStaticPlaneShape::getPlaneNormal)
	.function("getPlaneConstant", &btStaticPlaneShape::getPlaneConstant)
	;
	class_<btStaticPlaneShapeData>("btStaticPlaneShapeData")
	constant("m_collisionShapeData", m_collisionShapeData);
	constant("m_localScaling", m_localScaling);
	constant("m_planeNormal", m_planeNormal);
	constant("m_planeConstant", m_planeConstant);
	constant("m_pad", m_pad);
	;
	class_<btBU_Simplex1to4, base<btPolyhedralConvexAabbCachingShape>>("btBU_Simplex1to4")
	.constructor<r.q(const).btVector3>()
	.constructor<r.q(const).btVector3,r.q(const).btVector3>()
	.constructor<r.q(const).btVector3,r.q(const).btVector3,r.q(const).btVector3>()
	.constructor<r.q(const).btVector3,r.q(const).btVector3,r.q(const).btVector3,r.q(const).btVector3>()
	.function("reset", &btBU_Simplex1to4::reset)
	.function("addVertex", &btBU_Simplex1to4::addVertex)
	.function("getIndex", &btBU_Simplex1to4::getIndex)
	;
	class_<btTriangle>("btTriangle")
	constant("m_vertex0", m_vertex0);
	constant("m_vertex1", m_vertex1);
	constant("m_vertex2", m_vertex2);
	constant("m_partId", m_partId);
	constant("m_triangleIndex", m_triangleIndex);
	;
	class_<btTriangleBuffer, base<btTriangleCallback>>("btTriangleBuffer")
	.function("getNumTriangles", &btTriangleBuffer::getNumTriangles)
	.function("getTriangle", &btTriangleBuffer::getTriangle)
	.function("clearBuffer", &btTriangleBuffer::clearBuffer)
	;
	class_<btIndexedMesh>("btIndexedMesh")
	constant("m_numTriangles", m_numTriangles);
	constant("m_triangleIndexBase", m_triangleIndexBase);
	constant("m_triangleIndexStride", m_triangleIndexStride);
	constant("m_numVertices", m_numVertices);
	constant("m_vertexBase", m_vertexBase);
	constant("m_vertexStride", m_vertexStride);
	constant("m_indexType", m_indexType);
	constant("m_vertexType", m_vertexType);
	;
	class_<btTriangleIndexVertexArray, base<btStridingMeshInterface>>("btTriangleIndexVertexArray")
	.constructor<int,p.int,int,int,p.btScalar,int>()
	.function("addIndexedMesh_r.q(const).btIndexedMesh_PHY_ScalarType", select_overload<void(r.q(const).btIndexedMesh, PHY_ScalarType)>(&btTriangleIndexVertexArray::addIndexedMesh))
	.function("addIndexedMesh_r.q(const).btIndexedMesh", select_overload<void(r.q(const).btIndexedMesh)>(&btTriangleIndexVertexArray::addIndexedMesh))
	.function("getLockedVertexIndexBase_p.p.unsigned char_r.int_r.PHY_ScalarType_r.int_p.p.unsigned char_r.int_r.int_r.PHY_ScalarType_int", select_overload<void(p.p.unsigned char, r.int, r.PHY_ScalarType, r.int, p.p.unsigned char, r.int, r.int, r.PHY_ScalarType, int)>(&btTriangleIndexVertexArray::getLockedVertexIndexBase))
	.function("getLockedVertexIndexBase_p.p.unsigned char_r.int_r.PHY_ScalarType_r.int_p.p.unsigned char_r.int_r.int_r.PHY_ScalarType", select_overload<void(p.p.unsigned char, r.int, r.PHY_ScalarType, r.int, p.p.unsigned char, r.int, r.int, r.PHY_ScalarType)>(&btTriangleIndexVertexArray::getLockedVertexIndexBase))
	.function("getLockedReadOnlyVertexIndexBase_p.p.q(const).unsigned char_r.int_r.PHY_ScalarType_r.int_p.p.q(const).unsigned char_r.int_r.int_r.PHY_ScalarType_int", select_overload<void(p.p.q(const).unsigned char, r.int, r.PHY_ScalarType, r.int, p.p.q(const).unsigned char, r.int, r.int, r.PHY_ScalarType, int)const>(&btTriangleIndexVertexArray::getLockedReadOnlyVertexIndexBase))
	.function("getLockedReadOnlyVertexIndexBase_p.p.q(const).unsigned char_r.int_r.PHY_ScalarType_r.int_p.p.q(const).unsigned char_r.int_r.int_r.PHY_ScalarType", select_overload<void(p.p.q(const).unsigned char, r.int, r.PHY_ScalarType, r.int, p.p.q(const).unsigned char, r.int, r.int, r.PHY_ScalarType)const>(&btTriangleIndexVertexArray::getLockedReadOnlyVertexIndexBase))
	.function("getIndexedMeshArray", select_overload<IndexedMeshArray()>(&btTriangleIndexVertexArray::getIndexedMeshArray))
	.function("getIndexedMeshArray", select_overload<q(const).IndexedMeshArray()const>(&btTriangleIndexVertexArray::getIndexedMeshArray))
	;
	class_<btMaterialProperties>("btMaterialProperties")
	constant("m_numMaterials", m_numMaterials);
	constant("m_materialBase", m_materialBase);
	constant("m_materialStride", m_materialStride);
	constant("m_materialType", m_materialType);
	constant("m_numTriangles", m_numTriangles);
	constant("m_triangleMaterialsBase", m_triangleMaterialsBase);
	constant("m_triangleMaterialStride", m_triangleMaterialStride);
	constant("m_triangleType", m_triangleType);
	;
	class_<btTriangleIndexVertexMaterialArray, base<btTriangleIndexVertexArray>>("btTriangleIndexVertexMaterialArray")
	.constructor<int,p.int,int,int,p.btScalar,int,int,p.unsigned char,int,p.int,int>()
	.function("addMaterialProperties_r.q(const).btMaterialProperties_PHY_ScalarType", select_overload<void(r.q(const).btMaterialProperties, PHY_ScalarType)>(&btTriangleIndexVertexMaterialArray::addMaterialProperties))
	.function("addMaterialProperties_r.q(const).btMaterialProperties", select_overload<void(r.q(const).btMaterialProperties)>(&btTriangleIndexVertexMaterialArray::addMaterialProperties))
	.function("getLockedMaterialBase_p.p.unsigned char_r.int_r.PHY_ScalarType_r.int_p.p.unsigned char_r.int_r.int_r.PHY_ScalarType_int", select_overload<void(p.p.unsigned char, r.int, r.PHY_ScalarType, r.int, p.p.unsigned char, r.int, r.int, r.PHY_ScalarType, int)>(&btTriangleIndexVertexMaterialArray::getLockedMaterialBase))
	.function("getLockedMaterialBase_p.p.unsigned char_r.int_r.PHY_ScalarType_r.int_p.p.unsigned char_r.int_r.int_r.PHY_ScalarType", select_overload<void(p.p.unsigned char, r.int, r.PHY_ScalarType, r.int, p.p.unsigned char, r.int, r.int, r.PHY_ScalarType)>(&btTriangleIndexVertexMaterialArray::getLockedMaterialBase))
	.function("getLockedReadOnlyMaterialBase_p.p.q(const).unsigned char_r.int_r.PHY_ScalarType_r.int_p.p.q(const).unsigned char_r.int_r.int_r.PHY_ScalarType_int", select_overload<void(p.p.q(const).unsigned char, r.int, r.PHY_ScalarType, r.int, p.p.q(const).unsigned char, r.int, r.int, r.PHY_ScalarType, int)>(&btTriangleIndexVertexMaterialArray::getLockedReadOnlyMaterialBase))
	.function("getLockedReadOnlyMaterialBase_p.p.q(const).unsigned char_r.int_r.PHY_ScalarType_r.int_p.p.q(const).unsigned char_r.int_r.int_r.PHY_ScalarType", select_overload<void(p.p.q(const).unsigned char, r.int, r.PHY_ScalarType, r.int, p.p.q(const).unsigned char, r.int, r.int, r.PHY_ScalarType)>(&btTriangleIndexVertexMaterialArray::getLockedReadOnlyMaterialBase))
	;
	class_<btTriangleMesh, base<btTriangleIndexVertexArray>>("btTriangleMesh")
	.constructor<bool,bool>()
	.constructor<bool>()
	.function("getUse32bitIndices", &btTriangleMesh::getUse32bitIndices)
	.function("getUse4componentVertices", &btTriangleMesh::getUse4componentVertices)
	.function("addTriangle_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3_bool", select_overload<void(r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3, bool)>(&btTriangleMesh::addTriangle))
	.function("addTriangle_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3", select_overload<void(r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3)>(&btTriangleMesh::addTriangle))
	.function("addTriangleIndices", &btTriangleMesh::addTriangleIndices)
	.function("getNumTriangles", &btTriangleMesh::getNumTriangles)
	.function("findOrAddVertex", &btTriangleMesh::findOrAddVertex)
	.function("addIndex", &btTriangleMesh::addIndex)
	;
	class_<btTriangleShape, base<btPolyhedralConvexShape>>("btTriangleShape")
	.function("getVertexPtr_int", select_overload<btVector3(int)>(&btTriangleShape::getVertexPtr))
	.function("getVertexPtr_int", select_overload<q(const).btVector3(int)const>(&btTriangleShape::getVertexPtr))
	.constructor<r.q(const).btVector3,r.q(const).btVector3,r.q(const).btVector3>()
	.function("calcNormal", &btTriangleShape::calcNormal)
	.function("getPlaneEquation", &btTriangleShape::getPlaneEquation)
	;
	class_<btUniformScalingShape, base<btConvexShape>>("btUniformScalingShape")
	.constructor<p.btConvexShape,btScalar>()
	.function("getUniformScalingFactor", &btUniformScalingShape::getUniformScalingFactor)
	.function("getChildShape", select_overload<btConvexShape()>(&btUniformScalingShape::getChildShape))
	.function("getChildShape", select_overload<q(const).btConvexShape()const>(&btUniformScalingShape::getChildShape))
	;
	class_<btIDebugDraw>("btIDebugDraw")
	enum_<btIDebugDraw::DebugDrawModes>("btIDebugDraw::DebugDrawModes")
		;
	.function("getDefaultColors", &btIDebugDraw::getDefaultColors)
	.function("setDefaultColors", &btIDebugDraw::setDefaultColors)
	.function("drawLine_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3", select_overload<void(r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3)>(&btIDebugDraw::drawLine))
	.function("drawLine_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3", select_overload<void(r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3)>(&btIDebugDraw::drawLine))
	.function("drawSphere_btScalar_r.q(const).btTransform_r.q(const).btVector3", select_overload<void(btScalar, r.q(const).btTransform, r.q(const).btVector3)>(&btIDebugDraw::drawSphere))
	.function("drawSphere_r.q(const).btVector3_btScalar_r.q(const).btVector3", select_overload<void(r.q(const).btVector3, btScalar, r.q(const).btVector3)>(&btIDebugDraw::drawSphere))
	.function("drawTriangle_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3_btScalar", select_overload<void(r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3, btScalar)>(&btIDebugDraw::drawTriangle))
	.function("drawTriangle_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3_btScalar", select_overload<void(r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3, btScalar)>(&btIDebugDraw::drawTriangle))
	.function("drawContactPoint", &btIDebugDraw::drawContactPoint)
	.function("reportErrorWarning", &btIDebugDraw::reportErrorWarning)
	.function("draw3dText", &btIDebugDraw::draw3dText)
	.function("setDebugMode", &btIDebugDraw::setDebugMode)
	.function("getDebugMode", &btIDebugDraw::getDebugMode)
	.function("drawAabb", &btIDebugDraw::drawAabb)
	.function("drawTransform", &btIDebugDraw::drawTransform)
	.function("drawArc_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3_btScalar_btScalar_btScalar_btScalar_r.q(const).btVector3_bool_btScalar", select_overload<void(r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3, btScalar, btScalar, btScalar, btScalar, r.q(const).btVector3, bool, btScalar)>(&btIDebugDraw::drawArc))
	.function("drawArc_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3_btScalar_btScalar_btScalar_btScalar_r.q(const).btVector3_bool", select_overload<void(r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3, btScalar, btScalar, btScalar, btScalar, r.q(const).btVector3, bool)>(&btIDebugDraw::drawArc))
	.function("drawSpherePatch_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3_btScalar_btScalar_btScalar_btScalar_btScalar_r.q(const).btVector3_btScalar_bool", select_overload<void(r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3, btScalar, btScalar, btScalar, btScalar, btScalar, r.q(const).btVector3, btScalar, bool)>(&btIDebugDraw::drawSpherePatch))
	.function("drawSpherePatch_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3_btScalar_btScalar_btScalar_btScalar_btScalar_r.q(const).btVector3_btScalar", select_overload<void(r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3, btScalar, btScalar, btScalar, btScalar, btScalar, r.q(const).btVector3, btScalar)>(&btIDebugDraw::drawSpherePatch))
	.function("drawSpherePatch_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3_btScalar_btScalar_btScalar_btScalar_btScalar_r.q(const).btVector3", select_overload<void(r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3, btScalar, btScalar, btScalar, btScalar, btScalar, r.q(const).btVector3)>(&btIDebugDraw::drawSpherePatch))
	.function("drawBox_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3", select_overload<void(r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3)>(&btIDebugDraw::drawBox))
	.function("drawBox_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btTransform_r.q(const).btVector3", select_overload<void(r.q(const).btVector3, r.q(const).btVector3, r.q(const).btTransform, r.q(const).btVector3)>(&btIDebugDraw::drawBox))
	.function("drawCapsule", &btIDebugDraw::drawCapsule)
	.function("drawCylinder", &btIDebugDraw::drawCylinder)
	.function("drawCone", &btIDebugDraw::drawCone)
	.function("drawPlane", &btIDebugDraw::drawPlane)
	.function("flushLines", &btIDebugDraw::flushLines)
	;
	class_<btConvexCast>("btConvexCast")
	.function("calcTimeOfImpact", &btConvexCast::calcTimeOfImpact)
	;
	class_<btContinuousConvexCollision, base<btConvexCast>>("btContinuousConvexCollision")
	.function("computeClosestPoints", &btContinuousConvexCollision::computeClosestPoints)
	.constructor<p.q(const).btConvexShape,p.q(const).btConvexShape,p.btVoronoiSimplexSolver,p.btConvexPenetrationDepthSolver>()
	.constructor<p.q(const).btConvexShape,p.q(const).btStaticPlaneShape>()
	;
	class_<btConvexPenetrationDepthSolver>("btConvexPenetrationDepthSolver")
	.function("calcPenDepth", &btConvexPenetrationDepthSolver::calcPenDepth)
	;
	class_<btGjkConvexCast, base<btConvexCast>>("btGjkConvexCast")
	.constructor<p.q(const).btConvexShape,p.q(const).btConvexShape,p.btVoronoiSimplexSolver>()
	;
	class_<btGjkEpaSolver2>("btGjkEpaSolver2")
	.class_function("StackSizeRequirement", &btGjkEpaSolver2::StackSizeRequirement)
	.class_function("Distance", &btGjkEpaSolver2::Distance)
	.class_function("Penetration", &btGjkEpaSolver2::Penetration)
	.class_function("Penetration", &btGjkEpaSolver2::Penetration)
	.class_function("SignedDistance", &btGjkEpaSolver2::SignedDistance)
	.class_function("SignedDistance", &btGjkEpaSolver2::SignedDistance)
	;
	class_<btGjkEpaPenetrationDepthSolver, base<btConvexPenetrationDepthSolver>>("btGjkEpaPenetrationDepthSolver")
	;
	class_<btMinkowskiPenetrationDepthSolver, base<btConvexPenetrationDepthSolver>>("btMinkowskiPenetrationDepthSolver")
	.class_function("getPenetrationDirections", &btMinkowskiPenetrationDepthSolver::getPenetrationDirections)
	;
	class_<btPointCollector, base<btDiscreteCollisionDetectorInterface::Result>>("btPointCollector")
	constant("m_normalOnBInWorld", m_normalOnBInWorld);
	constant("m_pointInWorld", m_pointInWorld);
	constant("m_distance", m_distance);
	constant("m_hasResult", m_hasResult);
	.function("setShapeIdentifiersA", &btPointCollector::setShapeIdentifiersA)
	.function("setShapeIdentifiersB", &btPointCollector::setShapeIdentifiersB)
	.function("addContactPoint", &btPointCollector::addContactPoint)
	;
	class_<btTriangleRaycastCallback, base<btTriangleCallback>>("btTriangleRaycastCallback")
	enum_<btTriangleRaycastCallback::EFlags>("btTriangleRaycastCallback::EFlags")
		;
	.constructor<r.q(const).btVector3,r.q(const).btVector3,unsigned int>()
	.constructor<r.q(const).btVector3,r.q(const).btVector3>()
	.function("reportHit", &btTriangleRaycastCallback::reportHit)
	;
	class_<btTriangleConvexcastCallback, base<btTriangleCallback>>("btTriangleConvexcastCallback")
	.constructor<p.q(const).btConvexShape,r.q(const).btTransform,r.q(const).btTransform,r.q(const).btTransform,q(const).btScalar>()
	.function("reportHit", &btTriangleConvexcastCallback::reportHit)
	;
	class_<btSubsimplexConvexCast, base<btConvexCast>>("btSubsimplexConvexCast")
	.constructor<p.q(const).btConvexShape,p.q(const).btConvexShape,p.btVoronoiSimplexSolver>()
	;
	constant("gDeactivationTime", gDeactivationTime);
	constant("gDisableDeactivation", gDisableDeactivation);
	enum_<btRigidBodyFlags>("btRigidBodyFlags")
		.value("BT_DISABLE_WORLD_GRAVITY", BT_DISABLE_WORLD_GRAVITY)
		.value("BT_ENABLE_GYROSCOPIC_FORCE_EXPLICIT", BT_ENABLE_GYROSCOPIC_FORCE_EXPLICIT)
		.value("BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_WORLD", BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_WORLD)
		.value("BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY", BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY)
		.value("BT_ENABLE_GYROPSCOPIC_FORCE", BT_ENABLE_GYROPSCOPIC_FORCE)
		;
	class_<btRigidBody, base<btCollisionObject>>("btRigidBody")
	.constructor<r.q(const).btRigidBody::btRigidBodyConstructionInfo>()
	.constructor<btScalar,p.btMotionState,p.btCollisionShape,r.q(const).btVector3>()
	.constructor<btScalar,p.btMotionState,p.btCollisionShape>()
	.function("setupRigidBody", &btRigidBody::setupRigidBody)
	.function("proceedToTransform", &btRigidBody::proceedToTransform)
	.class_function("upcast", &btRigidBody::upcast)
	.class_function("upcast", &btRigidBody::upcast)
	.function("predictIntegratedTransform", &btRigidBody::predictIntegratedTransform)
	.function("saveKinematicState", &btRigidBody::saveKinematicState)
	.function("applyGravity", &btRigidBody::applyGravity)
	.function("setGravity", &btRigidBody::setGravity)
	.function("getGravity", &btRigidBody::getGravity)
	.function("setDamping", &btRigidBody::setDamping)
	.function("getLinearDamping", &btRigidBody::getLinearDamping)
	.function("getAngularDamping", &btRigidBody::getAngularDamping)
	.function("getLinearSleepingThreshold", &btRigidBody::getLinearSleepingThreshold)
	.function("getAngularSleepingThreshold", &btRigidBody::getAngularSleepingThreshold)
	.function("applyDamping", &btRigidBody::applyDamping)
	.function("getCollisionShape", select_overload<q(const).btCollisionShape()const>(&btRigidBody::getCollisionShape))
	.function("getCollisionShape", select_overload<btCollisionShape()>(&btRigidBody::getCollisionShape))
	.function("setMassProps", &btRigidBody::setMassProps)
	.function("getLinearFactor", &btRigidBody::getLinearFactor)
	.function("setLinearFactor", &btRigidBody::setLinearFactor)
	.function("getInvMass", &btRigidBody::getInvMass)
	.function("getInvInertiaTensorWorld", &btRigidBody::getInvInertiaTensorWorld)
	.function("integrateVelocities", &btRigidBody::integrateVelocities)
	.function("setCenterOfMassTransform", &btRigidBody::setCenterOfMassTransform)
	.function("applyCentralForce", &btRigidBody::applyCentralForce)
	.function("getTotalForce", &btRigidBody::getTotalForce)
	.function("getTotalTorque", &btRigidBody::getTotalTorque)
	.function("getInvInertiaDiagLocal", &btRigidBody::getInvInertiaDiagLocal)
	.function("setInvInertiaDiagLocal", &btRigidBody::setInvInertiaDiagLocal)
	.function("setSleepingThresholds", &btRigidBody::setSleepingThresholds)
	.function("applyTorque", &btRigidBody::applyTorque)
	.function("applyForce", &btRigidBody::applyForce)
	.function("applyCentralImpulse", &btRigidBody::applyCentralImpulse)
	.function("applyTorqueImpulse", &btRigidBody::applyTorqueImpulse)
	.function("applyImpulse", &btRigidBody::applyImpulse)
	.function("clearForces", &btRigidBody::clearForces)
	.function("updateInertiaTensor", &btRigidBody::updateInertiaTensor)
	.function("getCenterOfMassPosition", &btRigidBody::getCenterOfMassPosition)
	.function("getOrientation", &btRigidBody::getOrientation)
	.function("getCenterOfMassTransform", &btRigidBody::getCenterOfMassTransform)
	.function("getLinearVelocity", &btRigidBody::getLinearVelocity)
	.function("getAngularVelocity", &btRigidBody::getAngularVelocity)
	.function("setLinearVelocity", &btRigidBody::setLinearVelocity)
	.function("setAngularVelocity", &btRigidBody::setAngularVelocity)
	.function("getVelocityInLocalPoint", &btRigidBody::getVelocityInLocalPoint)
	.function("translate", &btRigidBody::translate)
	.function("getAabb", &btRigidBody::getAabb)
	.function("computeImpulseDenominator", &btRigidBody::computeImpulseDenominator)
	.function("computeAngularImpulseDenominator", &btRigidBody::computeAngularImpulseDenominator)
	.function("updateDeactivation", &btRigidBody::updateDeactivation)
	.function("wantsSleeping", &btRigidBody::wantsSleeping)
	.function("getBroadphaseProxy", select_overload<q(const).btBroadphaseProxy()const>(&btRigidBody::getBroadphaseProxy))
	.function("getBroadphaseProxy", select_overload<btBroadphaseProxy()>(&btRigidBody::getBroadphaseProxy))
	.function("setNewBroadphaseProxy", &btRigidBody::setNewBroadphaseProxy)
	.function("getMotionState", select_overload<btMotionState()>(&btRigidBody::getMotionState))
	.function("getMotionState", select_overload<q(const).btMotionState()const>(&btRigidBody::getMotionState))
	.function("setMotionState", &btRigidBody::setMotionState)
	.function("setAngularFactor_r.q(const).btVector3", select_overload<void(r.q(const).btVector3)>(&btRigidBody::setAngularFactor))
	.function("setAngularFactor_btScalar", select_overload<void(btScalar)>(&btRigidBody::setAngularFactor))
	.function("getAngularFactor", &btRigidBody::getAngularFactor)
	.function("isInWorld", &btRigidBody::isInWorld)
	.function("addConstraintRef", &btRigidBody::addConstraintRef)
	.function("removeConstraintRef", &btRigidBody::removeConstraintRef)
	.function("getConstraintRef", &btRigidBody::getConstraintRef)
	.function("getNumConstraintRefs", &btRigidBody::getNumConstraintRefs)
	.function("setFlags", &btRigidBody::setFlags)
	.function("getFlags", &btRigidBody::getFlags)
	.function("computeGyroscopicImpulseImplicit_World", &btRigidBody::computeGyroscopicImpulseImplicit_World)
	.function("computeGyroscopicImpulseImplicit_Body", &btRigidBody::computeGyroscopicImpulseImplicit_Body)
	.function("computeGyroscopicForceExplicit", &btRigidBody::computeGyroscopicForceExplicit)
	.function("getLocalInertia", &btRigidBody::getLocalInertia)
	;
	class_<btRigidBodyFloatData>("btRigidBodyFloatData")
	constant("m_collisionObjectData", m_collisionObjectData);
	constant("m_invInertiaTensorWorld", m_invInertiaTensorWorld);
	constant("m_linearVelocity", m_linearVelocity);
	constant("m_angularVelocity", m_angularVelocity);
	constant("m_angularFactor", m_angularFactor);
	constant("m_linearFactor", m_linearFactor);
	constant("m_gravity", m_gravity);
	constant("m_gravity_acceleration", m_gravity_acceleration);
	constant("m_invInertiaLocal", m_invInertiaLocal);
	constant("m_totalForce", m_totalForce);
	constant("m_totalTorque", m_totalTorque);
	constant("m_inverseMass", m_inverseMass);
	constant("m_linearDamping", m_linearDamping);
	constant("m_angularDamping", m_angularDamping);
	constant("m_additionalDampingFactor", m_additionalDampingFactor);
	constant("m_additionalLinearDampingThresholdSqr", m_additionalLinearDampingThresholdSqr);
	constant("m_additionalAngularDampingThresholdSqr", m_additionalAngularDampingThresholdSqr);
	constant("m_additionalAngularDampingFactor", m_additionalAngularDampingFactor);
	constant("m_linearSleepingThreshold", m_linearSleepingThreshold);
	constant("m_angularSleepingThreshold", m_angularSleepingThreshold);
	constant("m_additionalDamping", m_additionalDamping);
	;
	class_<btRigidBodyDoubleData>("btRigidBodyDoubleData")
	constant("m_collisionObjectData", m_collisionObjectData);
	constant("m_invInertiaTensorWorld", m_invInertiaTensorWorld);
	constant("m_linearVelocity", m_linearVelocity);
	constant("m_angularVelocity", m_angularVelocity);
	constant("m_angularFactor", m_angularFactor);
	constant("m_linearFactor", m_linearFactor);
	constant("m_gravity", m_gravity);
	constant("m_gravity_acceleration", m_gravity_acceleration);
	constant("m_invInertiaLocal", m_invInertiaLocal);
	constant("m_totalForce", m_totalForce);
	constant("m_totalTorque", m_totalTorque);
	constant("m_inverseMass", m_inverseMass);
	constant("m_linearDamping", m_linearDamping);
	constant("m_angularDamping", m_angularDamping);
	constant("m_additionalDampingFactor", m_additionalDampingFactor);
	constant("m_additionalLinearDampingThresholdSqr", m_additionalLinearDampingThresholdSqr);
	constant("m_additionalAngularDampingThresholdSqr", m_additionalAngularDampingThresholdSqr);
	constant("m_additionalAngularDampingFactor", m_additionalAngularDampingFactor);
	constant("m_linearSleepingThreshold", m_linearSleepingThreshold);
	constant("m_angularSleepingThreshold", m_angularSleepingThreshold);
	constant("m_additionalDamping", m_additionalDamping);
	constant("m_padding", m_padding);
	;
	class_<btActionInterface>("btActionInterface")
	.class_function("getFixedBody", &btActionInterface::getFixedBody)
	.function("updateAction", &btActionInterface::updateAction)
	.function("debugDraw", &btActionInterface::debugDraw)
	;
	class_<btCharacterControllerInterface, base<btActionInterface>>("btCharacterControllerInterface")
	.function("setWalkDirection", &btCharacterControllerInterface::setWalkDirection)
	.function("setVelocityForTimeInterval", &btCharacterControllerInterface::setVelocityForTimeInterval)
	.function("reset", &btCharacterControllerInterface::reset)
	.function("warp", &btCharacterControllerInterface::warp)
	.function("preStep", &btCharacterControllerInterface::preStep)
	.function("playerStep", &btCharacterControllerInterface::playerStep)
	.function("canJump", &btCharacterControllerInterface::canJump)
	.function("jump_r.q(const).btVector3", select_overload<void(r.q(const).btVector3)>(&btCharacterControllerInterface::jump))
	.function("jump", select_overload<void()>(&btCharacterControllerInterface::jump))
	.function("onGround", &btCharacterControllerInterface::onGround)
	.function("setUpInterpolate", &btCharacterControllerInterface::setUpInterpolate)
	;
	class_<btKinematicCharacterController, base<btCharacterControllerInterface>>("btKinematicCharacterController")
	.class_function("getUpAxisDirections", &btKinematicCharacterController::getUpAxisDirections)
	.function("computeReflectionDirection", &btKinematicCharacterController::computeReflectionDirection)
	.function("parallelComponent", &btKinematicCharacterController::parallelComponent)
	.function("perpindicularComponent", &btKinematicCharacterController::perpindicularComponent)
	.function("recoverFromPenetration", &btKinematicCharacterController::recoverFromPenetration)
	.function("stepUp", &btKinematicCharacterController::stepUp)
	.function("updateTargetPositionBasedOnCollision", &btKinematicCharacterController::updateTargetPositionBasedOnCollision)
	.function("updateTargetPositionBasedOnCollision", &btKinematicCharacterController::updateTargetPositionBasedOnCollision)
	.function("updateTargetPositionBasedOnCollision", &btKinematicCharacterController::updateTargetPositionBasedOnCollision)
	.function("stepForwardAndStrafe", &btKinematicCharacterController::stepForwardAndStrafe)
	.function("stepDown", &btKinematicCharacterController::stepDown)
	.function("needsCollision", &btKinematicCharacterController::needsCollision)
	.function("setUpVector", &btKinematicCharacterController::setUpVector)
	.function("getRotation", &btKinematicCharacterController::getRotation)
	.constructor<p.btPairCachingGhostObject,p.btConvexShape,btScalar,r.q(const).btVector3>()
	.constructor<p.btPairCachingGhostObject,p.btConvexShape,btScalar>()
	.function("setUp", &btKinematicCharacterController::setUp)
	.function("getUp", &btKinematicCharacterController::getUp)
	.function("setAngularVelocity", &btKinematicCharacterController::setAngularVelocity)
	.function("getAngularVelocity", &btKinematicCharacterController::getAngularVelocity)
	.function("setLinearVelocity", &btKinematicCharacterController::setLinearVelocity)
	.function("getLinearVelocity", &btKinematicCharacterController::getLinearVelocity)
	.function("setLinearDamping", &btKinematicCharacterController::setLinearDamping)
	.function("getLinearDamping", &btKinematicCharacterController::getLinearDamping)
	.function("setAngularDamping", &btKinematicCharacterController::setAngularDamping)
	.function("getAngularDamping", &btKinematicCharacterController::getAngularDamping)
	.function("setStepHeight", &btKinematicCharacterController::setStepHeight)
	.function("getStepHeight", &btKinematicCharacterController::getStepHeight)
	.function("setFallSpeed", &btKinematicCharacterController::setFallSpeed)
	.function("getFallSpeed", &btKinematicCharacterController::getFallSpeed)
	.function("setJumpSpeed", &btKinematicCharacterController::setJumpSpeed)
	.function("getJumpSpeed", &btKinematicCharacterController::getJumpSpeed)
	.function("setMaxJumpHeight", &btKinematicCharacterController::setMaxJumpHeight)
	.function("jump_r.q(const).btVector3", select_overload<void(r.q(const).btVector3)>(&btKinematicCharacterController::jump))
	.function("jump", select_overload<void()>(&btKinematicCharacterController::jump))
	.function("applyImpulse", &btKinematicCharacterController::applyImpulse)
	.function("setGravity", &btKinematicCharacterController::setGravity)
	.function("getGravity", &btKinematicCharacterController::getGravity)
	.function("setMaxSlope", &btKinematicCharacterController::setMaxSlope)
	.function("getMaxSlope", &btKinematicCharacterController::getMaxSlope)
	.function("setMaxPenetrationDepth", &btKinematicCharacterController::setMaxPenetrationDepth)
	.function("getMaxPenetrationDepth", &btKinematicCharacterController::getMaxPenetrationDepth)
	.function("getGhostObject", &btKinematicCharacterController::getGhostObject)
	.function("setUseGhostSweepTest", &btKinematicCharacterController::setUseGhostSweepTest)
	;
	class_<btJacobianEntry>("btJacobianEntry")
	.constructor<r.q(const).btMatrix3x3,r.q(const).btMatrix3x3,r.q(const).btVector3,r.q(const).btVector3,r.q(const).btVector3,r.q(const).btVector3,q(const).btScalar,r.q(const).btVector3,q(const).btScalar>()
	.constructor<r.q(const).btVector3,r.q(const).btMatrix3x3,r.q(const).btMatrix3x3,r.q(const).btVector3,r.q(const).btVector3>()
	.constructor<r.q(const).btVector3,r.q(const).btVector3,r.q(const).btVector3,r.q(const).btVector3>()
	.constructor<r.q(const).btMatrix3x3,r.q(const).btVector3,r.q(const).btVector3,r.q(const).btVector3,r.q(const).btVector3,q(const).btScalar>()
	.function("getDiagonal", &btJacobianEntry::getDiagonal)
	.function("getNonDiagonal_r.q(const).btJacobianEntry_q(const).btScalar", select_overload<btScalar(r.q(const).btJacobianEntry, q(const).btScalar)const>(&btJacobianEntry::getNonDiagonal))
	.function("getNonDiagonal_r.q(const).btJacobianEntry_q(const).btScalar_q(const).btScalar", select_overload<btScalar(r.q(const).btJacobianEntry, q(const).btScalar, q(const).btScalar)const>(&btJacobianEntry::getNonDiagonal))
	.function("getRelativeVelocity", &btJacobianEntry::getRelativeVelocity)
	;
	class_<btSolverBody>("btSolverBody")
	constant("m_worldTransform", m_worldTransform);
	constant("m_deltaLinearVelocity", m_deltaLinearVelocity);
	constant("m_deltaAngularVelocity", m_deltaAngularVelocity);
	constant("m_angularFactor", m_angularFactor);
	constant("m_linearFactor", m_linearFactor);
	constant("m_invMass", m_invMass);
	constant("m_pushVelocity", m_pushVelocity);
	constant("m_turnVelocity", m_turnVelocity);
	constant("m_linearVelocity", m_linearVelocity);
	constant("m_angularVelocity", m_angularVelocity);
	constant("m_externalForceImpulse", m_externalForceImpulse);
	constant("m_externalTorqueImpulse", m_externalTorqueImpulse);
	constant("m_originalBody", m_originalBody);
	.function("setWorldTransform", &btSolverBody::setWorldTransform)
	.function("getWorldTransform", &btSolverBody::getWorldTransform)
	.function("getVelocityInLocalPointNoDelta", &btSolverBody::getVelocityInLocalPointNoDelta)
	.function("getVelocityInLocalPointObsolete", &btSolverBody::getVelocityInLocalPointObsolete)
	.function("getAngularVelocity", &btSolverBody::getAngularVelocity)
	.function("applyImpulse", &btSolverBody::applyImpulse)
	.function("internalApplyPushImpulse", &btSolverBody::internalApplyPushImpulse)
	.function("getDeltaLinearVelocity", &btSolverBody::getDeltaLinearVelocity)
	.function("getDeltaAngularVelocity", &btSolverBody::getDeltaAngularVelocity)
	.function("getPushVelocity", &btSolverBody::getPushVelocity)
	.function("getTurnVelocity", &btSolverBody::getTurnVelocity)
	.function("internalGetDeltaLinearVelocity", &btSolverBody::internalGetDeltaLinearVelocity)
	.function("internalGetDeltaAngularVelocity", &btSolverBody::internalGetDeltaAngularVelocity)
	.function("internalGetAngularFactor", &btSolverBody::internalGetAngularFactor)
	.function("internalGetInvMass", &btSolverBody::internalGetInvMass)
	.function("internalSetInvMass", &btSolverBody::internalSetInvMass)
	.function("internalGetPushVelocity", &btSolverBody::internalGetPushVelocity)
	.function("internalGetTurnVelocity", &btSolverBody::internalGetTurnVelocity)
	.function("internalGetVelocityInLocalPointObsolete", &btSolverBody::internalGetVelocityInLocalPointObsolete)
	.function("internalGetAngularVelocity", &btSolverBody::internalGetAngularVelocity)
	.function("internalApplyImpulse", &btSolverBody::internalApplyImpulse)
	.function("writebackVelocity", &btSolverBody::writebackVelocity)
	.function("writebackVelocityAndTransform", &btSolverBody::writebackVelocityAndTransform)
	;
	class_<btSolverConstraint>("btSolverConstraint")
	constant("m_relpos1CrossNormal", m_relpos1CrossNormal);
	constant("m_contactNormal1", m_contactNormal1);
	constant("m_relpos2CrossNormal", m_relpos2CrossNormal);
	constant("m_contactNormal2", m_contactNormal2);
	constant("m_angularComponentA", m_angularComponentA);
	constant("m_angularComponentB", m_angularComponentB);
	constant("m_appliedPushImpulse", m_appliedPushImpulse);
	constant("m_appliedImpulse", m_appliedImpulse);
	constant("m_friction", m_friction);
	constant("m_jacDiagABInv", m_jacDiagABInv);
	constant("m_rhs", m_rhs);
	constant("m_cfm", m_cfm);
	constant("m_lowerLimit", m_lowerLimit);
	constant("m_upperLimit", m_upperLimit);
	constant("m_rhsPenetration", m_rhsPenetration);
	constant("m_overrideNumSolverIterations", m_overrideNumSolverIterations);
	constant("m_frictionIndex", m_frictionIndex);
	constant("m_solverBodyIdA", m_solverBodyIdA);
	constant("m_solverBodyIdB", m_solverBodyIdB);
	enum_<btSolverConstraint::btSolverConstraintType>("btSolverConstraint::btSolverConstraintType")
		.value("BT_SOLVER_CONTACT_1D", btSolverConstraint::BT_SOLVER_CONTACT_1D)
		.value("BT_SOLVER_FRICTION_1D", btSolverConstraint::BT_SOLVER_FRICTION_1D)
		;
	;
	enum_<btTypedConstraintType>("btTypedConstraintType")
		.value("POINT2POINT_CONSTRAINT_TYPE", POINT2POINT_CONSTRAINT_TYPE)
		.value("HINGE_CONSTRAINT_TYPE", HINGE_CONSTRAINT_TYPE)
		.value("CONETWIST_CONSTRAINT_TYPE", CONETWIST_CONSTRAINT_TYPE)
		.value("D6_CONSTRAINT_TYPE", D6_CONSTRAINT_TYPE)
		.value("SLIDER_CONSTRAINT_TYPE", SLIDER_CONSTRAINT_TYPE)
		.value("CONTACT_CONSTRAINT_TYPE", CONTACT_CONSTRAINT_TYPE)
		.value("D6_SPRING_CONSTRAINT_TYPE", D6_SPRING_CONSTRAINT_TYPE)
		.value("GEAR_CONSTRAINT_TYPE", GEAR_CONSTRAINT_TYPE)
		.value("FIXED_CONSTRAINT_TYPE", FIXED_CONSTRAINT_TYPE)
		.value("D6_SPRING_2_CONSTRAINT_TYPE", D6_SPRING_2_CONSTRAINT_TYPE)
		.value("MAX_CONSTRAINT_TYPE", MAX_CONSTRAINT_TYPE)
		;
	enum_<btConstraintParams>("btConstraintParams")
		.value("BT_CONSTRAINT_ERP", BT_CONSTRAINT_ERP)
		.value("BT_CONSTRAINT_STOP_ERP", BT_CONSTRAINT_STOP_ERP)
		.value("BT_CONSTRAINT_CFM", BT_CONSTRAINT_CFM)
		.value("BT_CONSTRAINT_STOP_CFM", BT_CONSTRAINT_STOP_CFM)
		;
	class_<btJointFeedback>("btJointFeedback")
	constant("m_appliedForceBodyA", m_appliedForceBodyA);
	constant("m_appliedTorqueBodyA", m_appliedTorqueBodyA);
	constant("m_appliedForceBodyB", m_appliedForceBodyB);
	constant("m_appliedTorqueBodyB", m_appliedTorqueBodyB);
	;
	class_<btTypedConstraint, base<btTypedObject>>("btTypedConstraint")
	.function("getMotorFactor", &btTypedConstraint::getMotorFactor)
	.constructor<btTypedConstraintType,r.btRigidBody>()
	.constructor<btTypedConstraintType,r.btRigidBody,r.btRigidBody>()
	.class_function("getFixedBody", &btTypedConstraint::getFixedBody)
	.function("getOverrideNumSolverIterations", &btTypedConstraint::getOverrideNumSolverIterations)
	.function("setOverrideNumSolverIterations", &btTypedConstraint::setOverrideNumSolverIterations)
	.function("buildJacobian", &btTypedConstraint::buildJacobian)
	.function("setupSolverConstraint", &btTypedConstraint::setupSolverConstraint)
	.function("getInfo1", &btTypedConstraint::getInfo1)
	.function("getInfo2", &btTypedConstraint::getInfo2)
	.function("internalSetAppliedImpulse", &btTypedConstraint::internalSetAppliedImpulse)
	.function("internalGetAppliedImpulse", &btTypedConstraint::internalGetAppliedImpulse)
	.function("getBreakingImpulseThreshold", &btTypedConstraint::getBreakingImpulseThreshold)
	.function("setBreakingImpulseThreshold", &btTypedConstraint::setBreakingImpulseThreshold)
	.function("isEnabled", &btTypedConstraint::isEnabled)
	.function("setEnabled", &btTypedConstraint::setEnabled)
	.function("solveConstraintObsolete", &btTypedConstraint::solveConstraintObsolete)
	.function("getRigidBodyA", select_overload<q(const).btRigidBody()const>(&btTypedConstraint::getRigidBodyA))
	.function("getRigidBodyB", select_overload<q(const).btRigidBody()const>(&btTypedConstraint::getRigidBodyB))
	.function("getRigidBodyA", select_overload<btRigidBody()>(&btTypedConstraint::getRigidBodyA))
	.function("getRigidBodyB", select_overload<btRigidBody()>(&btTypedConstraint::getRigidBodyB))
	.function("getUserConstraintType", &btTypedConstraint::getUserConstraintType)
	.function("setUserConstraintType", &btTypedConstraint::setUserConstraintType)
	.function("setUserConstraintId", &btTypedConstraint::setUserConstraintId)
	.function("getUserConstraintId", &btTypedConstraint::getUserConstraintId)
	.function("setUserConstraintPtr", &btTypedConstraint::setUserConstraintPtr)
	.function("getUserConstraintPtr", &btTypedConstraint::getUserConstraintPtr)
	.function("setJointFeedback", &btTypedConstraint::setJointFeedback)
	.function("getJointFeedback", select_overload<q(const).btJointFeedback()const>(&btTypedConstraint::getJointFeedback))
	.function("getJointFeedback", select_overload<btJointFeedback()>(&btTypedConstraint::getJointFeedback))
	.function("getUid", &btTypedConstraint::getUid)
	.function("needsFeedback", &btTypedConstraint::needsFeedback)
	.function("enableFeedback", &btTypedConstraint::enableFeedback)
	.function("getAppliedImpulse", &btTypedConstraint::getAppliedImpulse)
	.function("getConstraintType", &btTypedConstraint::getConstraintType)
	.function("setDbgDrawSize", &btTypedConstraint::setDbgDrawSize)
	.function("getDbgDrawSize", &btTypedConstraint::getDbgDrawSize)
	.function("setParam_int_btScalar_int", select_overload<void(int, btScalar, int)>(&btTypedConstraint::setParam))
	.function("setParam_int_btScalar", select_overload<void(int, btScalar)>(&btTypedConstraint::setParam))
	.function("getParam_int_int", select_overload<btScalar(int, int)const>(&btTypedConstraint::getParam))
	.function("getParam_int", select_overload<btScalar(int)const>(&btTypedConstraint::getParam))
	.function("calculateSerializeBufferSize", &btTypedConstraint::calculateSerializeBufferSize)
	.function("serialize", &btTypedConstraint::serialize)
	;
	function("btAdjustAngleToLimits", &btAdjustAngleToLimits);
	class_<btTypedConstraintFloatData>("btTypedConstraintFloatData")
	constant("m_rbA", m_rbA);
	constant("m_rbB", m_rbB);
	constant("m_name", m_name);
	constant("m_objectType", m_objectType);
	constant("m_userConstraintType", m_userConstraintType);
	constant("m_userConstraintId", m_userConstraintId);
	constant("m_needsFeedback", m_needsFeedback);
	constant("m_appliedImpulse", m_appliedImpulse);
	constant("m_dbgDrawSize", m_dbgDrawSize);
	constant("m_disableCollisionsBetweenLinkedBodies", m_disableCollisionsBetweenLinkedBodies);
	constant("m_overrideNumSolverIterations", m_overrideNumSolverIterations);
	constant("m_breakingImpulseThreshold", m_breakingImpulseThreshold);
	constant("m_isEnabled", m_isEnabled);
	;
	class_<btTypedConstraintData>("btTypedConstraintData")
	constant("m_rbA", m_rbA);
	constant("m_rbB", m_rbB);
	constant("m_name", m_name);
	constant("m_objectType", m_objectType);
	constant("m_userConstraintType", m_userConstraintType);
	constant("m_userConstraintId", m_userConstraintId);
	constant("m_needsFeedback", m_needsFeedback);
	constant("m_appliedImpulse", m_appliedImpulse);
	constant("m_dbgDrawSize", m_dbgDrawSize);
	constant("m_disableCollisionsBetweenLinkedBodies", m_disableCollisionsBetweenLinkedBodies);
	constant("m_overrideNumSolverIterations", m_overrideNumSolverIterations);
	constant("m_breakingImpulseThreshold", m_breakingImpulseThreshold);
	constant("m_isEnabled", m_isEnabled);
	;
	class_<btTypedConstraintDoubleData>("btTypedConstraintDoubleData")
	constant("m_rbA", m_rbA);
	constant("m_rbB", m_rbB);
	constant("m_name", m_name);
	constant("m_objectType", m_objectType);
	constant("m_userConstraintType", m_userConstraintType);
	constant("m_userConstraintId", m_userConstraintId);
	constant("m_needsFeedback", m_needsFeedback);
	constant("m_appliedImpulse", m_appliedImpulse);
	constant("m_dbgDrawSize", m_dbgDrawSize);
	constant("m_disableCollisionsBetweenLinkedBodies", m_disableCollisionsBetweenLinkedBodies);
	constant("m_overrideNumSolverIterations", m_overrideNumSolverIterations);
	constant("m_breakingImpulseThreshold", m_breakingImpulseThreshold);
	constant("m_isEnabled", m_isEnabled);
	constant("padding", padding);
	;
	class_<btAngularLimit>("btAngularLimit")
	.function("set_btScalar_btScalar_btScalar_btScalar_btScalar", select_overload<void(btScalar, btScalar, btScalar, btScalar, btScalar)>(&btAngularLimit::set))
	.function("set_btScalar_btScalar_btScalar_btScalar", select_overload<void(btScalar, btScalar, btScalar, btScalar)>(&btAngularLimit::set))
	.function("set_btScalar_btScalar_btScalar", select_overload<void(btScalar, btScalar, btScalar)>(&btAngularLimit::set))
	.function("set_btScalar_btScalar", select_overload<void(btScalar, btScalar)>(&btAngularLimit::set))
	.function("test", &btAngularLimit::test)
	.function("getSoftness", &btAngularLimit::getSoftness)
	.function("getBiasFactor", &btAngularLimit::getBiasFactor)
	.function("getRelaxationFactor", &btAngularLimit::getRelaxationFactor)
	.function("getCorrection", &btAngularLimit::getCorrection)
	.function("getSign", &btAngularLimit::getSign)
	.function("getHalfRange", &btAngularLimit::getHalfRange)
	.function("isLimit", &btAngularLimit::isLimit)
	.function("fit", &btAngularLimit::fit)
	.function("getError", &btAngularLimit::getError)
	.function("getLow", &btAngularLimit::getLow)
	.function("getHigh", &btAngularLimit::getHigh)
	;
	enum_<btConeTwistFlags>("btConeTwistFlags")
		.value("BT_CONETWIST_FLAGS_LIN_CFM", BT_CONETWIST_FLAGS_LIN_CFM)
		.value("BT_CONETWIST_FLAGS_LIN_ERP", BT_CONETWIST_FLAGS_LIN_ERP)
		.value("BT_CONETWIST_FLAGS_ANG_CFM", BT_CONETWIST_FLAGS_ANG_CFM)
		;
	class_<btConeTwistConstraint, base<btTypedConstraint>>("btConeTwistConstraint")
	.function("init", &btConeTwistConstraint::init)
	.function("computeConeLimitInfo", &btConeTwistConstraint::computeConeLimitInfo)
	.function("computeTwistLimitInfo", &btConeTwistConstraint::computeTwistLimitInfo)
	.function("adjustSwingAxisToUseEllipseNormal", &btConeTwistConstraint::adjustSwingAxisToUseEllipseNormal)
	.constructor<r.btRigidBody,r.btRigidBody,r.q(const).btTransform,r.q(const).btTransform>()
	.constructor<r.btRigidBody,r.q(const).btTransform>()
	.function("getInfo1NonVirtual", &btConeTwistConstraint::getInfo1NonVirtual)
	.function("getInfo2NonVirtual", &btConeTwistConstraint::getInfo2NonVirtual)
	.function("updateRHS", &btConeTwistConstraint::updateRHS)
	.function("getRigidBodyA", &btConeTwistConstraint::getRigidBodyA)
	.function("getRigidBodyB", &btConeTwistConstraint::getRigidBodyB)
	.function("setAngularOnly", &btConeTwistConstraint::setAngularOnly)
	.function("getAngularOnly", &btConeTwistConstraint::getAngularOnly)
	.function("setLimit_int_btScalar", select_overload<void(int, btScalar)>(&btConeTwistConstraint::setLimit))
	.function("getLimit", &btConeTwistConstraint::getLimit)
	.function("setLimit_btScalar_btScalar_btScalar_btScalar_btScalar_btScalar", select_overload<void(btScalar, btScalar, btScalar, btScalar, btScalar, btScalar)>(&btConeTwistConstraint::setLimit))
	.function("setLimit_btScalar_btScalar_btScalar_btScalar_btScalar", select_overload<void(btScalar, btScalar, btScalar, btScalar, btScalar)>(&btConeTwistConstraint::setLimit))
	.function("setLimit_btScalar_btScalar_btScalar_btScalar", select_overload<void(btScalar, btScalar, btScalar, btScalar)>(&btConeTwistConstraint::setLimit))
	.function("setLimit_btScalar_btScalar_btScalar", select_overload<void(btScalar, btScalar, btScalar)>(&btConeTwistConstraint::setLimit))
	.function("getAFrame", &btConeTwistConstraint::getAFrame)
	.function("getBFrame", &btConeTwistConstraint::getBFrame)
	.function("getSolveTwistLimit", &btConeTwistConstraint::getSolveTwistLimit)
	.function("getSolveSwingLimit", &btConeTwistConstraint::getSolveSwingLimit)
	.function("getTwistLimitSign", &btConeTwistConstraint::getTwistLimitSign)
	.function("calcAngleInfo", &btConeTwistConstraint::calcAngleInfo)
	.function("calcAngleInfo2", &btConeTwistConstraint::calcAngleInfo2)
	.function("getSwingSpan1", &btConeTwistConstraint::getSwingSpan1)
	.function("getSwingSpan2", &btConeTwistConstraint::getSwingSpan2)
	.function("getTwistSpan", &btConeTwistConstraint::getTwistSpan)
	.function("getLimitSoftness", &btConeTwistConstraint::getLimitSoftness)
	.function("getBiasFactor", &btConeTwistConstraint::getBiasFactor)
	.function("getRelaxationFactor", &btConeTwistConstraint::getRelaxationFactor)
	.function("getTwistAngle", &btConeTwistConstraint::getTwistAngle)
	.function("isPastSwingLimit", &btConeTwistConstraint::isPastSwingLimit)
	.function("getDamping", &btConeTwistConstraint::getDamping)
	.function("setDamping", &btConeTwistConstraint::setDamping)
	.function("enableMotor", &btConeTwistConstraint::enableMotor)
	.function("isMotorEnabled", &btConeTwistConstraint::isMotorEnabled)
	.function("getMaxMotorImpulse", &btConeTwistConstraint::getMaxMotorImpulse)
	.function("isMaxMotorImpulseNormalized", &btConeTwistConstraint::isMaxMotorImpulseNormalized)
	.function("setMaxMotorImpulse", &btConeTwistConstraint::setMaxMotorImpulse)
	.function("setMaxMotorImpulseNormalized", &btConeTwistConstraint::setMaxMotorImpulseNormalized)
	.function("getFixThresh", &btConeTwistConstraint::getFixThresh)
	.function("setFixThresh", &btConeTwistConstraint::setFixThresh)
	.function("setMotorTarget", &btConeTwistConstraint::setMotorTarget)
	.function("getMotorTarget", &btConeTwistConstraint::getMotorTarget)
	.function("setMotorTargetInConstraintSpace", &btConeTwistConstraint::setMotorTargetInConstraintSpace)
	.function("GetPointForAngle", &btConeTwistConstraint::GetPointForAngle)
	.function("setParam_int_btScalar_int", select_overload<void(int, btScalar, int)>(&btConeTwistConstraint::setParam))
	.function("setParam_int_btScalar", select_overload<void(int, btScalar)>(&btConeTwistConstraint::setParam))
	.function("setFrames", &btConeTwistConstraint::setFrames)
	.function("getFrameOffsetA", &btConeTwistConstraint::getFrameOffsetA)
	.function("getFrameOffsetB", &btConeTwistConstraint::getFrameOffsetB)
	.function("getParam_int_int", select_overload<btScalar(int, int)const>(&btConeTwistConstraint::getParam))
	.function("getParam_int", select_overload<btScalar(int)const>(&btConeTwistConstraint::getParam))
	.function("getFlags", &btConeTwistConstraint::getFlags)
	;
	class_<btConeTwistConstraintDoubleData>("btConeTwistConstraintDoubleData")
	constant("m_typeConstraintData", m_typeConstraintData);
	constant("m_rbAFrame", m_rbAFrame);
	constant("m_rbBFrame", m_rbBFrame);
	constant("m_swingSpan1", m_swingSpan1);
	constant("m_swingSpan2", m_swingSpan2);
	constant("m_twistSpan", m_twistSpan);
	constant("m_limitSoftness", m_limitSoftness);
	constant("m_biasFactor", m_biasFactor);
	constant("m_relaxationFactor", m_relaxationFactor);
	constant("m_damping", m_damping);
	;
	class_<btConeTwistConstraintData>("btConeTwistConstraintData")
	constant("m_typeConstraintData", m_typeConstraintData);
	constant("m_rbAFrame", m_rbAFrame);
	constant("m_rbBFrame", m_rbBFrame);
	constant("m_swingSpan1", m_swingSpan1);
	constant("m_swingSpan2", m_swingSpan2);
	constant("m_twistSpan", m_twistSpan);
	constant("m_limitSoftness", m_limitSoftness);
	constant("m_biasFactor", m_biasFactor);
	constant("m_relaxationFactor", m_relaxationFactor);
	constant("m_damping", m_damping);
	constant("m_pad", m_pad);
	;
	enum_<btConstraintSolverType>("btConstraintSolverType")
		.value("BT_SEQUENTIAL_IMPULSE_SOLVER", BT_SEQUENTIAL_IMPULSE_SOLVER)
		.value("BT_MLCP_SOLVER", BT_MLCP_SOLVER)
		.value("BT_NNCG_SOLVER", BT_NNCG_SOLVER)
		;
	class_<btConstraintSolver>("btConstraintSolver")
	.function("prepareSolve", &btConstraintSolver::prepareSolve)
	.function("solveGroup", &btConstraintSolver::solveGroup)
	.function("allSolved", &btConstraintSolver::allSolved)
	.function("reset", &btConstraintSolver::reset)
	.function("getSolverType", &btConstraintSolver::getSolverType)
	;
	class_<btContactConstraint, base<btTypedConstraint>>("btContactConstraint")
	.constructor<p.btPersistentManifold,r.btRigidBody,r.btRigidBody>()
	.function("setContactManifold", &btContactConstraint::setContactManifold)
	.function("getContactManifold", select_overload<btPersistentManifold()>(&btContactConstraint::getContactManifold))
	.function("getContactManifold", select_overload<q(const).btPersistentManifold()const>(&btContactConstraint::getContactManifold))
	;
	function("resolveSingleCollision", &resolveSingleCollision);
	function("resolveSingleBilateral", &resolveSingleBilateral);
	enum_<btSolverMode>("btSolverMode")
		.value("SOLVER_RANDMIZE_ORDER", SOLVER_RANDMIZE_ORDER)
		.value("SOLVER_FRICTION_SEPARATE", SOLVER_FRICTION_SEPARATE)
		.value("SOLVER_USE_WARMSTARTING", SOLVER_USE_WARMSTARTING)
		.value("SOLVER_USE_2_FRICTION_DIRECTIONS", SOLVER_USE_2_FRICTION_DIRECTIONS)
		.value("SOLVER_ENABLE_FRICTION_DIRECTION_CACHING", SOLVER_ENABLE_FRICTION_DIRECTION_CACHING)
		.value("SOLVER_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION", SOLVER_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION)
		.value("SOLVER_CACHE_FRIENDLY", SOLVER_CACHE_FRIENDLY)
		.value("SOLVER_SIMD", SOLVER_SIMD)
		.value("SOLVER_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS", SOLVER_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS)
		.value("SOLVER_ALLOW_ZERO_LENGTH_FRICTION_DIRECTIONS", SOLVER_ALLOW_ZERO_LENGTH_FRICTION_DIRECTIONS)
		;
	class_<btContactSolverInfoData>("btContactSolverInfoData")
	constant("m_tau", m_tau);
	constant("m_damping", m_damping);
	constant("m_friction", m_friction);
	constant("m_timeStep", m_timeStep);
	constant("m_restitution", m_restitution);
	constant("m_numIterations", m_numIterations);
	constant("m_maxErrorReduction", m_maxErrorReduction);
	constant("m_sor", m_sor);
	constant("m_erp", m_erp);
	constant("m_erp2", m_erp2);
	constant("m_globalCfm", m_globalCfm);
	constant("m_splitImpulse", m_splitImpulse);
	constant("m_splitImpulsePenetrationThreshold", m_splitImpulsePenetrationThreshold);
	constant("m_splitImpulseTurnErp", m_splitImpulseTurnErp);
	constant("m_linearSlop", m_linearSlop);
	constant("m_warmstartingFactor", m_warmstartingFactor);
	constant("m_solverMode", m_solverMode);
	constant("m_restingContactRestitutionThreshold", m_restingContactRestitutionThreshold);
	constant("m_minimumSolverBatchSize", m_minimumSolverBatchSize);
	constant("m_maxGyroscopicForce", m_maxGyroscopicForce);
	constant("m_singleAxisRollingFrictionThreshold", m_singleAxisRollingFrictionThreshold);
	constant("m_leastSquaresResidualThreshold", m_leastSquaresResidualThreshold);
	;
	class_<btContactSolverInfo, base<btContactSolverInfoData>>("btContactSolverInfo")
	;
	class_<btContactSolverInfoDoubleData>("btContactSolverInfoDoubleData")
	constant("m_tau", m_tau);
	constant("m_damping", m_damping);
	constant("m_friction", m_friction);
	constant("m_timeStep", m_timeStep);
	constant("m_restitution", m_restitution);
	constant("m_maxErrorReduction", m_maxErrorReduction);
	constant("m_sor", m_sor);
	constant("m_erp", m_erp);
	constant("m_erp2", m_erp2);
	constant("m_globalCfm", m_globalCfm);
	constant("m_splitImpulsePenetrationThreshold", m_splitImpulsePenetrationThreshold);
	constant("m_splitImpulseTurnErp", m_splitImpulseTurnErp);
	constant("m_linearSlop", m_linearSlop);
	constant("m_warmstartingFactor", m_warmstartingFactor);
	constant("m_maxGyroscopicForce", m_maxGyroscopicForce);
	constant("m_singleAxisRollingFrictionThreshold", m_singleAxisRollingFrictionThreshold);
	constant("m_numIterations", m_numIterations);
	constant("m_solverMode", m_solverMode);
	constant("m_restingContactRestitutionThreshold", m_restingContactRestitutionThreshold);
	constant("m_minimumSolverBatchSize", m_minimumSolverBatchSize);
	constant("m_splitImpulse", m_splitImpulse);
	constant("m_padding", m_padding);
	;
	class_<btContactSolverInfoFloatData>("btContactSolverInfoFloatData")
	constant("m_tau", m_tau);
	constant("m_damping", m_damping);
	constant("m_friction", m_friction);
	constant("m_timeStep", m_timeStep);
	constant("m_restitution", m_restitution);
	constant("m_maxErrorReduction", m_maxErrorReduction);
	constant("m_sor", m_sor);
	constant("m_erp", m_erp);
	constant("m_erp2", m_erp2);
	constant("m_globalCfm", m_globalCfm);
	constant("m_splitImpulsePenetrationThreshold", m_splitImpulsePenetrationThreshold);
	constant("m_splitImpulseTurnErp", m_splitImpulseTurnErp);
	constant("m_linearSlop", m_linearSlop);
	constant("m_warmstartingFactor", m_warmstartingFactor);
	constant("m_maxGyroscopicForce", m_maxGyroscopicForce);
	constant("m_singleAxisRollingFrictionThreshold", m_singleAxisRollingFrictionThreshold);
	constant("m_numIterations", m_numIterations);
	constant("m_solverMode", m_solverMode);
	constant("m_restingContactRestitutionThreshold", m_restingContactRestitutionThreshold);
	constant("m_minimumSolverBatchSize", m_minimumSolverBatchSize);
	constant("m_splitImpulse", m_splitImpulse);
	constant("m_padding", m_padding);
	;
	enum_<RotateOrder>("RotateOrder")
		.value("RO_XYZ", RO_XYZ)
		.value("RO_XZY", RO_XZY)
		.value("RO_YXZ", RO_YXZ)
		.value("RO_YZX", RO_YZX)
		.value("RO_ZXY", RO_ZXY)
		.value("RO_ZYX", RO_ZYX)
		;
	class_<btRotationalLimitMotor2>("btRotationalLimitMotor2")
	.constructor<r.q(const).btRotationalLimitMotor2>()
	.function("isLimited", &btRotationalLimitMotor2::isLimited)
	.function("testLimitValue", &btRotationalLimitMotor2::testLimitValue)
	;
	class_<btTranslationalLimitMotor2>("btTranslationalLimitMotor2")
	.constructor<r.q(const).btTranslationalLimitMotor2>()
	.function("isLimited", &btTranslationalLimitMotor2::isLimited)
	.function("testLimitValue", &btTranslationalLimitMotor2::testLimitValue)
	;
	enum_<bt6DofFlags2>("bt6DofFlags2")
		.value("BT_6DOF_FLAGS_CFM_STOP2", BT_6DOF_FLAGS_CFM_STOP2)
		.value("BT_6DOF_FLAGS_ERP_STOP2", BT_6DOF_FLAGS_ERP_STOP2)
		.value("BT_6DOF_FLAGS_CFM_MOTO2", BT_6DOF_FLAGS_CFM_MOTO2)
		.value("BT_6DOF_FLAGS_ERP_MOTO2", BT_6DOF_FLAGS_ERP_MOTO2)
		;
	class_<btGeneric6DofSpring2Constraint, base<btTypedConstraint>>("btGeneric6DofSpring2Constraint")
	.function("setAngularLimits", &btGeneric6DofSpring2Constraint::setAngularLimits)
	.function("setLinearLimits", &btGeneric6DofSpring2Constraint::setLinearLimits)
	.function("calculateLinearInfo", &btGeneric6DofSpring2Constraint::calculateLinearInfo)
	.function("calculateAngleInfo", &btGeneric6DofSpring2Constraint::calculateAngleInfo)
	.function("testAngularLimitMotor", &btGeneric6DofSpring2Constraint::testAngularLimitMotor)
	.function("calculateJacobi", &btGeneric6DofSpring2Constraint::calculateJacobi)
	.function("get_limit_motor_info2", &btGeneric6DofSpring2Constraint::get_limit_motor_info2)
	.function("get_limit_motor_info2", &btGeneric6DofSpring2Constraint::get_limit_motor_info2)
	.constructor<r.btRigidBody,r.btRigidBody,r.q(const).btTransform,r.q(const).btTransform,RotateOrder>()
	.constructor<r.btRigidBody,r.btRigidBody,r.q(const).btTransform,r.q(const).btTransform>()
	.constructor<r.btRigidBody,r.q(const).btTransform,RotateOrder>()
	.constructor<r.btRigidBody,r.q(const).btTransform>()
	.function("getRotationalLimitMotor", &btGeneric6DofSpring2Constraint::getRotationalLimitMotor)
	.function("getTranslationalLimitMotor", &btGeneric6DofSpring2Constraint::getTranslationalLimitMotor)
	.function("calculateTransforms_r.q(const).btTransform_r.q(const).btTransform", select_overload<void(r.q(const).btTransform, r.q(const).btTransform)>(&btGeneric6DofSpring2Constraint::calculateTransforms))
	.function("calculateTransforms", select_overload<void()>(&btGeneric6DofSpring2Constraint::calculateTransforms))
	.function("getCalculatedTransformA", &btGeneric6DofSpring2Constraint::getCalculatedTransformA)
	.function("getCalculatedTransformB", &btGeneric6DofSpring2Constraint::getCalculatedTransformB)
	.function("getFrameOffsetA", select_overload<q(const).btTransform()const>(&btGeneric6DofSpring2Constraint::getFrameOffsetA))
	.function("getFrameOffsetB", select_overload<q(const).btTransform()const>(&btGeneric6DofSpring2Constraint::getFrameOffsetB))
	.function("getFrameOffsetA", select_overload<btTransform()>(&btGeneric6DofSpring2Constraint::getFrameOffsetA))
	.function("getFrameOffsetB", select_overload<btTransform()>(&btGeneric6DofSpring2Constraint::getFrameOffsetB))
	.function("getAxis", &btGeneric6DofSpring2Constraint::getAxis)
	.function("getAngle", &btGeneric6DofSpring2Constraint::getAngle)
	.function("getRelativePivotPosition", &btGeneric6DofSpring2Constraint::getRelativePivotPosition)
	.function("setFrames", &btGeneric6DofSpring2Constraint::setFrames)
	.function("setLinearLowerLimit", &btGeneric6DofSpring2Constraint::setLinearLowerLimit)
	.function("getLinearLowerLimit", &btGeneric6DofSpring2Constraint::getLinearLowerLimit)
	.function("setLinearUpperLimit", &btGeneric6DofSpring2Constraint::setLinearUpperLimit)
	.function("getLinearUpperLimit", &btGeneric6DofSpring2Constraint::getLinearUpperLimit)
	.function("setAngularLowerLimit", &btGeneric6DofSpring2Constraint::setAngularLowerLimit)
	.function("setAngularLowerLimitReversed", &btGeneric6DofSpring2Constraint::setAngularLowerLimitReversed)
	.function("getAngularLowerLimit", &btGeneric6DofSpring2Constraint::getAngularLowerLimit)
	.function("getAngularLowerLimitReversed", &btGeneric6DofSpring2Constraint::getAngularLowerLimitReversed)
	.function("setAngularUpperLimit", &btGeneric6DofSpring2Constraint::setAngularUpperLimit)
	.function("setAngularUpperLimitReversed", &btGeneric6DofSpring2Constraint::setAngularUpperLimitReversed)
	.function("getAngularUpperLimit", &btGeneric6DofSpring2Constraint::getAngularUpperLimit)
	.function("getAngularUpperLimitReversed", &btGeneric6DofSpring2Constraint::getAngularUpperLimitReversed)
	.function("setLimit", &btGeneric6DofSpring2Constraint::setLimit)
	.function("setLimitReversed", &btGeneric6DofSpring2Constraint::setLimitReversed)
	.function("isLimited", &btGeneric6DofSpring2Constraint::isLimited)
	.function("setRotationOrder", &btGeneric6DofSpring2Constraint::setRotationOrder)
	.function("getRotationOrder", &btGeneric6DofSpring2Constraint::getRotationOrder)
	.function("setAxis", &btGeneric6DofSpring2Constraint::setAxis)
	.function("setBounce", &btGeneric6DofSpring2Constraint::setBounce)
	.function("enableMotor", &btGeneric6DofSpring2Constraint::enableMotor)
	.function("setServo", &btGeneric6DofSpring2Constraint::setServo)
	.function("setTargetVelocity", &btGeneric6DofSpring2Constraint::setTargetVelocity)
	.function("setServoTarget", &btGeneric6DofSpring2Constraint::setServoTarget)
	.function("setMaxMotorForce", &btGeneric6DofSpring2Constraint::setMaxMotorForce)
	.function("enableSpring", &btGeneric6DofSpring2Constraint::enableSpring)
	.function("setStiffness_int_btScalar_bool", select_overload<void(int, btScalar, bool)>(&btGeneric6DofSpring2Constraint::setStiffness))
	.function("setStiffness_int_btScalar", select_overload<void(int, btScalar)>(&btGeneric6DofSpring2Constraint::setStiffness))
	.function("setDamping_int_btScalar_bool", select_overload<void(int, btScalar, bool)>(&btGeneric6DofSpring2Constraint::setDamping))
	.function("setDamping_int_btScalar", select_overload<void(int, btScalar)>(&btGeneric6DofSpring2Constraint::setDamping))
	.function("setEquilibriumPoint", select_overload<void()>(&btGeneric6DofSpring2Constraint::setEquilibriumPoint))
	.function("setEquilibriumPoint_int", select_overload<void(int)>(&btGeneric6DofSpring2Constraint::setEquilibriumPoint))
	.function("setEquilibriumPoint_int_btScalar", select_overload<void(int, btScalar)>(&btGeneric6DofSpring2Constraint::setEquilibriumPoint))
	.function("setParam_int_btScalar_int", select_overload<void(int, btScalar, int)>(&btGeneric6DofSpring2Constraint::setParam))
	.function("setParam_int_btScalar", select_overload<void(int, btScalar)>(&btGeneric6DofSpring2Constraint::setParam))
	.function("getParam_int_int", select_overload<btScalar(int, int)const>(&btGeneric6DofSpring2Constraint::getParam))
	.function("getParam_int", select_overload<btScalar(int)const>(&btGeneric6DofSpring2Constraint::getParam))
	.class_function("btGetMatrixElem", &btGeneric6DofSpring2Constraint::btGetMatrixElem)
	.class_function("matrixToEulerXYZ", &btGeneric6DofSpring2Constraint::matrixToEulerXYZ)
	.class_function("matrixToEulerXZY", &btGeneric6DofSpring2Constraint::matrixToEulerXZY)
	.class_function("matrixToEulerYXZ", &btGeneric6DofSpring2Constraint::matrixToEulerYXZ)
	.class_function("matrixToEulerYZX", &btGeneric6DofSpring2Constraint::matrixToEulerYZX)
	.class_function("matrixToEulerZXY", &btGeneric6DofSpring2Constraint::matrixToEulerZXY)
	.class_function("matrixToEulerZYX", &btGeneric6DofSpring2Constraint::matrixToEulerZYX)
	;
	class_<btGeneric6DofSpring2ConstraintData>("btGeneric6DofSpring2ConstraintData")
	constant("m_typeConstraintData", m_typeConstraintData);
	constant("m_rbAFrame", m_rbAFrame);
	constant("m_rbBFrame", m_rbBFrame);
	constant("m_linearUpperLimit", m_linearUpperLimit);
	constant("m_linearLowerLimit", m_linearLowerLimit);
	constant("m_linearBounce", m_linearBounce);
	constant("m_linearStopERP", m_linearStopERP);
	constant("m_linearStopCFM", m_linearStopCFM);
	constant("m_linearMotorERP", m_linearMotorERP);
	constant("m_linearMotorCFM", m_linearMotorCFM);
	constant("m_linearTargetVelocity", m_linearTargetVelocity);
	constant("m_linearMaxMotorForce", m_linearMaxMotorForce);
	constant("m_linearServoTarget", m_linearServoTarget);
	constant("m_linearSpringStiffness", m_linearSpringStiffness);
	constant("m_linearSpringDamping", m_linearSpringDamping);
	constant("m_linearEquilibriumPoint", m_linearEquilibriumPoint);
	constant("m_linearEnableMotor", m_linearEnableMotor);
	constant("m_linearServoMotor", m_linearServoMotor);
	constant("m_linearEnableSpring", m_linearEnableSpring);
	constant("m_linearSpringStiffnessLimited", m_linearSpringStiffnessLimited);
	constant("m_linearSpringDampingLimited", m_linearSpringDampingLimited);
	constant("m_padding1", m_padding1);
	constant("m_angularUpperLimit", m_angularUpperLimit);
	constant("m_angularLowerLimit", m_angularLowerLimit);
	constant("m_angularBounce", m_angularBounce);
	constant("m_angularStopERP", m_angularStopERP);
	constant("m_angularStopCFM", m_angularStopCFM);
	constant("m_angularMotorERP", m_angularMotorERP);
	constant("m_angularMotorCFM", m_angularMotorCFM);
	constant("m_angularTargetVelocity", m_angularTargetVelocity);
	constant("m_angularMaxMotorForce", m_angularMaxMotorForce);
	constant("m_angularServoTarget", m_angularServoTarget);
	constant("m_angularSpringStiffness", m_angularSpringStiffness);
	constant("m_angularSpringDamping", m_angularSpringDamping);
	constant("m_angularEquilibriumPoint", m_angularEquilibriumPoint);
	constant("m_angularEnableMotor", m_angularEnableMotor);
	constant("m_angularServoMotor", m_angularServoMotor);
	constant("m_angularEnableSpring", m_angularEnableSpring);
	constant("m_angularSpringStiffnessLimited", m_angularSpringStiffnessLimited);
	constant("m_angularSpringDampingLimited", m_angularSpringDampingLimited);
	constant("m_rotateOrder", m_rotateOrder);
	;
	class_<btGeneric6DofSpring2ConstraintDoubleData2>("btGeneric6DofSpring2ConstraintDoubleData2")
	constant("m_typeConstraintData", m_typeConstraintData);
	constant("m_rbAFrame", m_rbAFrame);
	constant("m_rbBFrame", m_rbBFrame);
	constant("m_linearUpperLimit", m_linearUpperLimit);
	constant("m_linearLowerLimit", m_linearLowerLimit);
	constant("m_linearBounce", m_linearBounce);
	constant("m_linearStopERP", m_linearStopERP);
	constant("m_linearStopCFM", m_linearStopCFM);
	constant("m_linearMotorERP", m_linearMotorERP);
	constant("m_linearMotorCFM", m_linearMotorCFM);
	constant("m_linearTargetVelocity", m_linearTargetVelocity);
	constant("m_linearMaxMotorForce", m_linearMaxMotorForce);
	constant("m_linearServoTarget", m_linearServoTarget);
	constant("m_linearSpringStiffness", m_linearSpringStiffness);
	constant("m_linearSpringDamping", m_linearSpringDamping);
	constant("m_linearEquilibriumPoint", m_linearEquilibriumPoint);
	constant("m_linearEnableMotor", m_linearEnableMotor);
	constant("m_linearServoMotor", m_linearServoMotor);
	constant("m_linearEnableSpring", m_linearEnableSpring);
	constant("m_linearSpringStiffnessLimited", m_linearSpringStiffnessLimited);
	constant("m_linearSpringDampingLimited", m_linearSpringDampingLimited);
	constant("m_padding1", m_padding1);
	constant("m_angularUpperLimit", m_angularUpperLimit);
	constant("m_angularLowerLimit", m_angularLowerLimit);
	constant("m_angularBounce", m_angularBounce);
	constant("m_angularStopERP", m_angularStopERP);
	constant("m_angularStopCFM", m_angularStopCFM);
	constant("m_angularMotorERP", m_angularMotorERP);
	constant("m_angularMotorCFM", m_angularMotorCFM);
	constant("m_angularTargetVelocity", m_angularTargetVelocity);
	constant("m_angularMaxMotorForce", m_angularMaxMotorForce);
	constant("m_angularServoTarget", m_angularServoTarget);
	constant("m_angularSpringStiffness", m_angularSpringStiffness);
	constant("m_angularSpringDamping", m_angularSpringDamping);
	constant("m_angularEquilibriumPoint", m_angularEquilibriumPoint);
	constant("m_angularEnableMotor", m_angularEnableMotor);
	constant("m_angularServoMotor", m_angularServoMotor);
	constant("m_angularEnableSpring", m_angularEnableSpring);
	constant("m_angularSpringStiffnessLimited", m_angularSpringStiffnessLimited);
	constant("m_angularSpringDampingLimited", m_angularSpringDampingLimited);
	constant("m_rotateOrder", m_rotateOrder);
	;
	class_<btFixedConstraint, base<btGeneric6DofSpring2Constraint>>("btFixedConstraint")
	.constructor<r.btRigidBody,r.btRigidBody,r.q(const).btTransform,r.q(const).btTransform>()
	;
	class_<btGearConstraint, base<btTypedConstraint>>("btGearConstraint")
	.constructor<r.btRigidBody,r.btRigidBody,r.q(const).btVector3,r.q(const).btVector3,btScalar>()
	.constructor<r.btRigidBody,r.btRigidBody,r.q(const).btVector3,r.q(const).btVector3>()
	.function("setAxisA", &btGearConstraint::setAxisA)
	.function("setAxisB", &btGearConstraint::setAxisB)
	.function("setRatio", &btGearConstraint::setRatio)
	.function("getAxisA", &btGearConstraint::getAxisA)
	.function("getAxisB", &btGearConstraint::getAxisB)
	.function("getRatio", &btGearConstraint::getRatio)
	.function("setParam_int_btScalar_int", select_overload<void(int, btScalar, int)>(&btGearConstraint::setParam))
	.function("setParam_int_btScalar", select_overload<void(int, btScalar)>(&btGearConstraint::setParam))
	.function("getParam_int_int", select_overload<btScalar(int, int)const>(&btGearConstraint::getParam))
	.function("getParam_int", select_overload<btScalar(int)const>(&btGearConstraint::getParam))
	;
	class_<btGearConstraintFloatData>("btGearConstraintFloatData")
	constant("m_typeConstraintData", m_typeConstraintData);
	constant("m_axisInA", m_axisInA);
	constant("m_axisInB", m_axisInB);
	constant("m_ratio", m_ratio);
	constant("m_padding", m_padding);
	;
	class_<btGearConstraintDoubleData>("btGearConstraintDoubleData")
	constant("m_typeConstraintData", m_typeConstraintData);
	constant("m_axisInA", m_axisInA);
	constant("m_axisInB", m_axisInB);
	constant("m_ratio", m_ratio);
	;
	class_<btRotationalLimitMotor>("btRotationalLimitMotor")
	.constructor<r.q(const).btRotationalLimitMotor>()
	.function("isLimited", &btRotationalLimitMotor::isLimited)
	.function("needApplyTorques", &btRotationalLimitMotor::needApplyTorques)
	.function("testLimitValue", &btRotationalLimitMotor::testLimitValue)
	.function("solveAngularLimits", &btRotationalLimitMotor::solveAngularLimits)
	;
	class_<btTranslationalLimitMotor>("btTranslationalLimitMotor")
	.constructor<r.q(const).btTranslationalLimitMotor>()
	.function("isLimited", &btTranslationalLimitMotor::isLimited)
	.function("needApplyForce", &btTranslationalLimitMotor::needApplyForce)
	.function("testLimitValue", &btTranslationalLimitMotor::testLimitValue)
	.function("solveLinearAxis", &btTranslationalLimitMotor::solveLinearAxis)
	;
	enum_<bt6DofFlags>("bt6DofFlags")
		.value("BT_6DOF_FLAGS_CFM_NORM", BT_6DOF_FLAGS_CFM_NORM)
		.value("BT_6DOF_FLAGS_CFM_STOP", BT_6DOF_FLAGS_CFM_STOP)
		.value("BT_6DOF_FLAGS_ERP_STOP", BT_6DOF_FLAGS_ERP_STOP)
		;
	class_<btGeneric6DofConstraint, base<btTypedConstraint>>("btGeneric6DofConstraint")
	.function("setAngularLimits", &btGeneric6DofConstraint::setAngularLimits)
	.function("setLinearLimits", &btGeneric6DofConstraint::setLinearLimits)
	.function("buildLinearJacobian", &btGeneric6DofConstraint::buildLinearJacobian)
	.function("buildAngularJacobian", &btGeneric6DofConstraint::buildAngularJacobian)
	.function("calculateLinearInfo", &btGeneric6DofConstraint::calculateLinearInfo)
	.function("calculateAngleInfo", &btGeneric6DofConstraint::calculateAngleInfo)
	.constructor<r.btRigidBody,r.btRigidBody,r.q(const).btTransform,r.q(const).btTransform,bool>()
	.constructor<r.btRigidBody,r.q(const).btTransform,bool>()
	.function("calculateTransforms_r.q(const).btTransform_r.q(const).btTransform", select_overload<void(r.q(const).btTransform, r.q(const).btTransform)>(&btGeneric6DofConstraint::calculateTransforms))
	.function("calculateTransforms", select_overload<void()>(&btGeneric6DofConstraint::calculateTransforms))
	.function("getCalculatedTransformA", &btGeneric6DofConstraint::getCalculatedTransformA)
	.function("getCalculatedTransformB", &btGeneric6DofConstraint::getCalculatedTransformB)
	.function("getFrameOffsetA", select_overload<q(const).btTransform()const>(&btGeneric6DofConstraint::getFrameOffsetA))
	.function("getFrameOffsetB", select_overload<q(const).btTransform()const>(&btGeneric6DofConstraint::getFrameOffsetB))
	.function("getFrameOffsetA", select_overload<btTransform()>(&btGeneric6DofConstraint::getFrameOffsetA))
	.function("getFrameOffsetB", select_overload<btTransform()>(&btGeneric6DofConstraint::getFrameOffsetB))
	.function("getInfo1NonVirtual", &btGeneric6DofConstraint::getInfo1NonVirtual)
	.function("getInfo2NonVirtual", &btGeneric6DofConstraint::getInfo2NonVirtual)
	.function("updateRHS", &btGeneric6DofConstraint::updateRHS)
	.function("getAxis", &btGeneric6DofConstraint::getAxis)
	.function("getAngle", &btGeneric6DofConstraint::getAngle)
	.function("getRelativePivotPosition", &btGeneric6DofConstraint::getRelativePivotPosition)
	.function("setFrames", &btGeneric6DofConstraint::setFrames)
	.function("testAngularLimitMotor", &btGeneric6DofConstraint::testAngularLimitMotor)
	.function("setLinearLowerLimit", &btGeneric6DofConstraint::setLinearLowerLimit)
	.function("getLinearLowerLimit", &btGeneric6DofConstraint::getLinearLowerLimit)
	.function("setLinearUpperLimit", &btGeneric6DofConstraint::setLinearUpperLimit)
	.function("getLinearUpperLimit", &btGeneric6DofConstraint::getLinearUpperLimit)
	.function("setAngularLowerLimit", &btGeneric6DofConstraint::setAngularLowerLimit)
	.function("getAngularLowerLimit", &btGeneric6DofConstraint::getAngularLowerLimit)
	.function("setAngularUpperLimit", &btGeneric6DofConstraint::setAngularUpperLimit)
	.function("getAngularUpperLimit", &btGeneric6DofConstraint::getAngularUpperLimit)
	.function("getRotationalLimitMotor", &btGeneric6DofConstraint::getRotationalLimitMotor)
	.function("getTranslationalLimitMotor", &btGeneric6DofConstraint::getTranslationalLimitMotor)
	.function("setLimit", &btGeneric6DofConstraint::setLimit)
	.function("isLimited", &btGeneric6DofConstraint::isLimited)
	.function("calcAnchorPos", &btGeneric6DofConstraint::calcAnchorPos)
	.function("get_limit_motor_info2_p.btRotationalLimitMotor_r.q(const).btTransform_r.q(const).btTransform_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3_p.btTypedConstraint::btConstraintInfo2_int_r.btVector3_int_int", select_overload<int(p.btRotationalLimitMotor, r.q(const).btTransform, r.q(const).btTransform, r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3, p.btTypedConstraint::btConstraintInfo2, int, r.btVector3, int, int)>(&btGeneric6DofConstraint::get_limit_motor_info2))
	.function("get_limit_motor_info2_p.btRotationalLimitMotor_r.q(const).btTransform_r.q(const).btTransform_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3_p.btTypedConstraint::btConstraintInfo2_int_r.btVector3_int", select_overload<int(p.btRotationalLimitMotor, r.q(const).btTransform, r.q(const).btTransform, r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3, p.btTypedConstraint::btConstraintInfo2, int, r.btVector3, int)>(&btGeneric6DofConstraint::get_limit_motor_info2))
	.function("getUseFrameOffset", &btGeneric6DofConstraint::getUseFrameOffset)
	.function("setUseFrameOffset", &btGeneric6DofConstraint::setUseFrameOffset)
	.function("getUseLinearReferenceFrameA", &btGeneric6DofConstraint::getUseLinearReferenceFrameA)
	.function("setUseLinearReferenceFrameA", &btGeneric6DofConstraint::setUseLinearReferenceFrameA)
	.function("setParam_int_btScalar_int", select_overload<void(int, btScalar, int)>(&btGeneric6DofConstraint::setParam))
	.function("setParam_int_btScalar", select_overload<void(int, btScalar)>(&btGeneric6DofConstraint::setParam))
	.function("getParam_int_int", select_overload<btScalar(int, int)const>(&btGeneric6DofConstraint::getParam))
	.function("getParam_int", select_overload<btScalar(int)const>(&btGeneric6DofConstraint::getParam))
	.function("setAxis", &btGeneric6DofConstraint::setAxis)
	.function("getFlags", &btGeneric6DofConstraint::getFlags)
	;
	class_<btGeneric6DofConstraintData>("btGeneric6DofConstraintData")
	constant("m_typeConstraintData", m_typeConstraintData);
	constant("m_rbAFrame", m_rbAFrame);
	constant("m_rbBFrame", m_rbBFrame);
	constant("m_linearUpperLimit", m_linearUpperLimit);
	constant("m_linearLowerLimit", m_linearLowerLimit);
	constant("m_angularUpperLimit", m_angularUpperLimit);
	constant("m_angularLowerLimit", m_angularLowerLimit);
	constant("m_useLinearReferenceFrameA", m_useLinearReferenceFrameA);
	constant("m_useOffsetForConstraintFrame", m_useOffsetForConstraintFrame);
	;
	class_<btGeneric6DofConstraintDoubleData2>("btGeneric6DofConstraintDoubleData2")
	constant("m_typeConstraintData", m_typeConstraintData);
	constant("m_rbAFrame", m_rbAFrame);
	constant("m_rbBFrame", m_rbBFrame);
	constant("m_linearUpperLimit", m_linearUpperLimit);
	constant("m_linearLowerLimit", m_linearLowerLimit);
	constant("m_angularUpperLimit", m_angularUpperLimit);
	constant("m_angularLowerLimit", m_angularLowerLimit);
	constant("m_useLinearReferenceFrameA", m_useLinearReferenceFrameA);
	constant("m_useOffsetForConstraintFrame", m_useOffsetForConstraintFrame);
	;
	class_<btGeneric6DofSpringConstraint, base<btGeneric6DofConstraint>>("btGeneric6DofSpringConstraint")
	.function("init", &btGeneric6DofSpringConstraint::init)
	.function("internalUpdateSprings", &btGeneric6DofSpringConstraint::internalUpdateSprings)
	.constructor<r.btRigidBody,r.btRigidBody,r.q(const).btTransform,r.q(const).btTransform,bool>()
	.constructor<r.btRigidBody,r.q(const).btTransform,bool>()
	.function("enableSpring", &btGeneric6DofSpringConstraint::enableSpring)
	.function("setStiffness", &btGeneric6DofSpringConstraint::setStiffness)
	.function("setDamping", &btGeneric6DofSpringConstraint::setDamping)
	.function("setEquilibriumPoint", select_overload<void()>(&btGeneric6DofSpringConstraint::setEquilibriumPoint))
	.function("setEquilibriumPoint_int", select_overload<void(int)>(&btGeneric6DofSpringConstraint::setEquilibriumPoint))
	.function("setEquilibriumPoint_int_btScalar", select_overload<void(int, btScalar)>(&btGeneric6DofSpringConstraint::setEquilibriumPoint))
	.function("isSpringEnabled", &btGeneric6DofSpringConstraint::isSpringEnabled)
	.function("getStiffness", &btGeneric6DofSpringConstraint::getStiffness)
	.function("getDamping", &btGeneric6DofSpringConstraint::getDamping)
	.function("getEquilibriumPoint", &btGeneric6DofSpringConstraint::getEquilibriumPoint)
	.function("setAxis", &btGeneric6DofSpringConstraint::setAxis)
	;
	class_<btGeneric6DofSpringConstraintData>("btGeneric6DofSpringConstraintData")
	constant("m_6dofData", m_6dofData);
	constant("m_springEnabled", m_springEnabled);
	constant("m_equilibriumPoint", m_equilibriumPoint);
	constant("m_springStiffness", m_springStiffness);
	constant("m_springDamping", m_springDamping);
	;
	class_<btGeneric6DofSpringConstraintDoubleData2>("btGeneric6DofSpringConstraintDoubleData2")
	constant("m_6dofData", m_6dofData);
	constant("m_springEnabled", m_springEnabled);
	constant("m_equilibriumPoint", m_equilibriumPoint);
	constant("m_springStiffness", m_springStiffness);
	constant("m_springDamping", m_springDamping);
	;
	class_<btHinge2Constraint, base<btGeneric6DofSpring2Constraint>>("btHinge2Constraint")
	.constructor<r.btRigidBody,r.btRigidBody,r.btVector3,r.btVector3,r.btVector3>()
	.function("getAnchor", &btHinge2Constraint::getAnchor)
	.function("getAnchor2", &btHinge2Constraint::getAnchor2)
	.function("getAxis1", &btHinge2Constraint::getAxis1)
	.function("getAxis2", &btHinge2Constraint::getAxis2)
	.function("getAngle1", &btHinge2Constraint::getAngle1)
	.function("getAngle2", &btHinge2Constraint::getAngle2)
	.function("setUpperLimit", &btHinge2Constraint::setUpperLimit)
	.function("setLowerLimit", &btHinge2Constraint::setLowerLimit)
	;
	enum_<btHingeFlags>("btHingeFlags")
		.value("BT_HINGE_FLAGS_CFM_STOP", BT_HINGE_FLAGS_CFM_STOP)
		.value("BT_HINGE_FLAGS_ERP_STOP", BT_HINGE_FLAGS_ERP_STOP)
		.value("BT_HINGE_FLAGS_CFM_NORM", BT_HINGE_FLAGS_CFM_NORM)
		.value("BT_HINGE_FLAGS_ERP_NORM", BT_HINGE_FLAGS_ERP_NORM)
		;
	class_<btHingeConstraint, base<btTypedConstraint>>("btHingeConstraint")
	.constructor<r.btRigidBody,r.btRigidBody,r.q(const).btVector3,r.q(const).btVector3,r.q(const).btVector3,r.q(const).btVector3,bool>()
	.constructor<r.btRigidBody,r.btRigidBody,r.q(const).btVector3,r.q(const).btVector3,r.q(const).btVector3,r.q(const).btVector3>()
	.constructor<r.btRigidBody,r.q(const).btVector3,r.q(const).btVector3,bool>()
	.constructor<r.btRigidBody,r.q(const).btVector3,r.q(const).btVector3>()
	.constructor<r.btRigidBody,r.btRigidBody,r.q(const).btTransform,r.q(const).btTransform,bool>()
	.constructor<r.btRigidBody,r.btRigidBody,r.q(const).btTransform,r.q(const).btTransform>()
	.constructor<r.btRigidBody,r.q(const).btTransform,bool>()
	.constructor<r.btRigidBody,r.q(const).btTransform>()
	.function("getInfo1NonVirtual", &btHingeConstraint::getInfo1NonVirtual)
	.function("getInfo2NonVirtual", &btHingeConstraint::getInfo2NonVirtual)
	.function("getInfo2Internal", &btHingeConstraint::getInfo2Internal)
	.function("getInfo2InternalUsingFrameOffset", &btHingeConstraint::getInfo2InternalUsingFrameOffset)
	.function("updateRHS", &btHingeConstraint::updateRHS)
	.function("getRigidBodyA", select_overload<q(const).btRigidBody()const>(&btHingeConstraint::getRigidBodyA))
	.function("getRigidBodyB", select_overload<q(const).btRigidBody()const>(&btHingeConstraint::getRigidBodyB))
	.function("getRigidBodyA", select_overload<btRigidBody()>(&btHingeConstraint::getRigidBodyA))
	.function("getRigidBodyB", select_overload<btRigidBody()>(&btHingeConstraint::getRigidBodyB))
	.function("getFrameOffsetA", &btHingeConstraint::getFrameOffsetA)
	.function("getFrameOffsetB", &btHingeConstraint::getFrameOffsetB)
	.function("setFrames", &btHingeConstraint::setFrames)
	.function("setAngularOnly", &btHingeConstraint::setAngularOnly)
	.function("enableAngularMotor", &btHingeConstraint::enableAngularMotor)
	.function("enableMotor", &btHingeConstraint::enableMotor)
	.function("setMaxMotorImpulse", &btHingeConstraint::setMaxMotorImpulse)
	.function("setMotorTargetVelocity", &btHingeConstraint::setMotorTargetVelocity)
	.function("setMotorTarget_r.q(const).btQuaternion_btScalar", select_overload<void(r.q(const).btQuaternion, btScalar)>(&btHingeConstraint::setMotorTarget))
	.function("setMotorTarget_btScalar_btScalar", select_overload<void(btScalar, btScalar)>(&btHingeConstraint::setMotorTarget))
	.function("setLimit_btScalar_btScalar_btScalar_btScalar_btScalar", select_overload<void(btScalar, btScalar, btScalar, btScalar, btScalar)>(&btHingeConstraint::setLimit))
	.function("setLimit_btScalar_btScalar_btScalar_btScalar", select_overload<void(btScalar, btScalar, btScalar, btScalar)>(&btHingeConstraint::setLimit))
	.function("setLimit_btScalar_btScalar_btScalar", select_overload<void(btScalar, btScalar, btScalar)>(&btHingeConstraint::setLimit))
	.function("setLimit_btScalar_btScalar", select_overload<void(btScalar, btScalar)>(&btHingeConstraint::setLimit))
	.function("getLimitSoftness", &btHingeConstraint::getLimitSoftness)
	.function("getLimitBiasFactor", &btHingeConstraint::getLimitBiasFactor)
	.function("getLimitRelaxationFactor", &btHingeConstraint::getLimitRelaxationFactor)
	.function("setAxis", &btHingeConstraint::setAxis)
	.function("hasLimit", &btHingeConstraint::hasLimit)
	.function("getLowerLimit", &btHingeConstraint::getLowerLimit)
	.function("getUpperLimit", &btHingeConstraint::getUpperLimit)
	.function("getHingeAngle", select_overload<btScalar()>(&btHingeConstraint::getHingeAngle))
	.function("getHingeAngle_r.q(const).btTransform_r.q(const).btTransform", select_overload<btScalar(r.q(const).btTransform, r.q(const).btTransform)>(&btHingeConstraint::getHingeAngle))
	.function("testLimit", &btHingeConstraint::testLimit)
	.function("getAFrame", select_overload<q(const).btTransform()const>(&btHingeConstraint::getAFrame))
	.function("getBFrame", select_overload<q(const).btTransform()const>(&btHingeConstraint::getBFrame))
	.function("getAFrame", select_overload<btTransform()>(&btHingeConstraint::getAFrame))
	.function("getBFrame", select_overload<btTransform()>(&btHingeConstraint::getBFrame))
	.function("getSolveLimit", &btHingeConstraint::getSolveLimit)
	.function("getLimitSign", &btHingeConstraint::getLimitSign)
	.function("getAngularOnly", &btHingeConstraint::getAngularOnly)
	.function("getEnableAngularMotor", &btHingeConstraint::getEnableAngularMotor)
	.function("getMotorTargetVelosity", &btHingeConstraint::getMotorTargetVelosity)
	.function("getMaxMotorImpulse", &btHingeConstraint::getMaxMotorImpulse)
	.function("getUseFrameOffset", &btHingeConstraint::getUseFrameOffset)
	.function("setUseFrameOffset", &btHingeConstraint::setUseFrameOffset)
	.function("getUseReferenceFrameA", &btHingeConstraint::getUseReferenceFrameA)
	.function("setUseReferenceFrameA", &btHingeConstraint::setUseReferenceFrameA)
	.function("setParam_int_btScalar_int", select_overload<void(int, btScalar, int)>(&btHingeConstraint::setParam))
	.function("setParam_int_btScalar", select_overload<void(int, btScalar)>(&btHingeConstraint::setParam))
	.function("getParam_int_int", select_overload<btScalar(int, int)const>(&btHingeConstraint::getParam))
	.function("getParam_int", select_overload<btScalar(int)const>(&btHingeConstraint::getParam))
	.function("getFlags", &btHingeConstraint::getFlags)
	;
	class_<btHingeConstraintDoubleData>("btHingeConstraintDoubleData")
	constant("m_typeConstraintData", m_typeConstraintData);
	constant("m_rbAFrame", m_rbAFrame);
	constant("m_rbBFrame", m_rbBFrame);
	constant("m_useReferenceFrameA", m_useReferenceFrameA);
	constant("m_angularOnly", m_angularOnly);
	constant("m_enableAngularMotor", m_enableAngularMotor);
	constant("m_motorTargetVelocity", m_motorTargetVelocity);
	constant("m_maxMotorImpulse", m_maxMotorImpulse);
	constant("m_lowerLimit", m_lowerLimit);
	constant("m_upperLimit", m_upperLimit);
	constant("m_limitSoftness", m_limitSoftness);
	constant("m_biasFactor", m_biasFactor);
	constant("m_relaxationFactor", m_relaxationFactor);
	;
	class_<btHingeAccumulatedAngleConstraint, base<btHingeConstraint>>("btHingeAccumulatedAngleConstraint")
	.constructor<r.btRigidBody,r.btRigidBody,r.q(const).btVector3,r.q(const).btVector3,r.q(const).btVector3,r.q(const).btVector3,bool>()
	.constructor<r.btRigidBody,r.btRigidBody,r.q(const).btVector3,r.q(const).btVector3,r.q(const).btVector3,r.q(const).btVector3>()
	.constructor<r.btRigidBody,r.q(const).btVector3,r.q(const).btVector3,bool>()
	.constructor<r.btRigidBody,r.q(const).btVector3,r.q(const).btVector3>()
	.constructor<r.btRigidBody,r.btRigidBody,r.q(const).btTransform,r.q(const).btTransform,bool>()
	.constructor<r.btRigidBody,r.btRigidBody,r.q(const).btTransform,r.q(const).btTransform>()
	.constructor<r.btRigidBody,r.q(const).btTransform,bool>()
	.constructor<r.btRigidBody,r.q(const).btTransform>()
	.function("getAccumulatedHingeAngle", &btHingeAccumulatedAngleConstraint::getAccumulatedHingeAngle)
	.function("setAccumulatedHingeAngle", &btHingeAccumulatedAngleConstraint::setAccumulatedHingeAngle)
	;
	class_<btHingeConstraintFloatData>("btHingeConstraintFloatData")
	constant("m_typeConstraintData", m_typeConstraintData);
	constant("m_rbAFrame", m_rbAFrame);
	constant("m_rbBFrame", m_rbBFrame);
	constant("m_useReferenceFrameA", m_useReferenceFrameA);
	constant("m_angularOnly", m_angularOnly);
	constant("m_enableAngularMotor", m_enableAngularMotor);
	constant("m_motorTargetVelocity", m_motorTargetVelocity);
	constant("m_maxMotorImpulse", m_maxMotorImpulse);
	constant("m_lowerLimit", m_lowerLimit);
	constant("m_upperLimit", m_upperLimit);
	constant("m_limitSoftness", m_limitSoftness);
	constant("m_biasFactor", m_biasFactor);
	constant("m_relaxationFactor", m_relaxationFactor);
	;
	class_<btHingeConstraintDoubleData2>("btHingeConstraintDoubleData2")
	constant("m_typeConstraintData", m_typeConstraintData);
	constant("m_rbAFrame", m_rbAFrame);
	constant("m_rbBFrame", m_rbBFrame);
	constant("m_useReferenceFrameA", m_useReferenceFrameA);
	constant("m_angularOnly", m_angularOnly);
	constant("m_enableAngularMotor", m_enableAngularMotor);
	constant("m_motorTargetVelocity", m_motorTargetVelocity);
	constant("m_maxMotorImpulse", m_maxMotorImpulse);
	constant("m_lowerLimit", m_lowerLimit);
	constant("m_upperLimit", m_upperLimit);
	constant("m_limitSoftness", m_limitSoftness);
	constant("m_biasFactor", m_biasFactor);
	constant("m_relaxationFactor", m_relaxationFactor);
	constant("m_padding1", m_padding1);
	;
	class_<btConstraintSetting>("btConstraintSetting")
	constant("m_tau", m_tau);
	constant("m_damping", m_damping);
	constant("m_impulseClamp", m_impulseClamp);
	;
	enum_<btPoint2PointFlags>("btPoint2PointFlags")
		.value("BT_P2P_FLAGS_ERP", BT_P2P_FLAGS_ERP)
		.value("BT_P2P_FLAGS_CFM", BT_P2P_FLAGS_CFM)
		;
	class_<btPoint2PointConstraint, base<btTypedConstraint>>("btPoint2PointConstraint")
	.constructor<r.btRigidBody,r.btRigidBody,r.q(const).btVector3,r.q(const).btVector3>()
	.constructor<r.btRigidBody,r.q(const).btVector3>()
	.function("getInfo1NonVirtual", &btPoint2PointConstraint::getInfo1NonVirtual)
	.function("getInfo2NonVirtual", &btPoint2PointConstraint::getInfo2NonVirtual)
	.function("updateRHS", &btPoint2PointConstraint::updateRHS)
	.function("setPivotA", &btPoint2PointConstraint::setPivotA)
	.function("setPivotB", &btPoint2PointConstraint::setPivotB)
	.function("getPivotInA", &btPoint2PointConstraint::getPivotInA)
	.function("getPivotInB", &btPoint2PointConstraint::getPivotInB)
	.function("setParam_int_btScalar_int", select_overload<void(int, btScalar, int)>(&btPoint2PointConstraint::setParam))
	.function("setParam_int_btScalar", select_overload<void(int, btScalar)>(&btPoint2PointConstraint::setParam))
	.function("getParam_int_int", select_overload<btScalar(int, int)const>(&btPoint2PointConstraint::getParam))
	.function("getParam_int", select_overload<btScalar(int)const>(&btPoint2PointConstraint::getParam))
	.function("getFlags", &btPoint2PointConstraint::getFlags)
	;
	class_<btPoint2PointConstraintFloatData>("btPoint2PointConstraintFloatData")
	constant("m_typeConstraintData", m_typeConstraintData);
	constant("m_pivotInA", m_pivotInA);
	constant("m_pivotInB", m_pivotInB);
	;
	class_<btPoint2PointConstraintDoubleData2>("btPoint2PointConstraintDoubleData2")
	constant("m_typeConstraintData", m_typeConstraintData);
	constant("m_pivotInA", m_pivotInA);
	constant("m_pivotInB", m_pivotInB);
	;
	class_<btPoint2PointConstraintDoubleData>("btPoint2PointConstraintDoubleData")
	constant("m_typeConstraintData", m_typeConstraintData);
	constant("m_pivotInA", m_pivotInA);
	constant("m_pivotInB", m_pivotInB);
	;
	enum_<btSliderFlags>("btSliderFlags")
		.value("BT_SLIDER_FLAGS_CFM_DIRLIN", BT_SLIDER_FLAGS_CFM_DIRLIN)
		.value("BT_SLIDER_FLAGS_ERP_DIRLIN", BT_SLIDER_FLAGS_ERP_DIRLIN)
		.value("BT_SLIDER_FLAGS_CFM_DIRANG", BT_SLIDER_FLAGS_CFM_DIRANG)
		.value("BT_SLIDER_FLAGS_ERP_DIRANG", BT_SLIDER_FLAGS_ERP_DIRANG)
		.value("BT_SLIDER_FLAGS_CFM_ORTLIN", BT_SLIDER_FLAGS_CFM_ORTLIN)
		.value("BT_SLIDER_FLAGS_ERP_ORTLIN", BT_SLIDER_FLAGS_ERP_ORTLIN)
		.value("BT_SLIDER_FLAGS_CFM_ORTANG", BT_SLIDER_FLAGS_CFM_ORTANG)
		.value("BT_SLIDER_FLAGS_ERP_ORTANG", BT_SLIDER_FLAGS_ERP_ORTANG)
		.value("BT_SLIDER_FLAGS_CFM_LIMLIN", BT_SLIDER_FLAGS_CFM_LIMLIN)
		.value("BT_SLIDER_FLAGS_ERP_LIMLIN", BT_SLIDER_FLAGS_ERP_LIMLIN)
		.value("BT_SLIDER_FLAGS_CFM_LIMANG", BT_SLIDER_FLAGS_CFM_LIMANG)
		.value("BT_SLIDER_FLAGS_ERP_LIMANG", BT_SLIDER_FLAGS_ERP_LIMANG)
		;
	class_<btSliderConstraint, base<btTypedConstraint>>("btSliderConstraint")
	.function("initParams", &btSliderConstraint::initParams)
	.constructor<r.btRigidBody,r.btRigidBody,r.q(const).btTransform,r.q(const).btTransform,bool>()
	.constructor<r.btRigidBody,r.q(const).btTransform,bool>()
	.function("getInfo1NonVirtual", &btSliderConstraint::getInfo1NonVirtual)
	.function("getInfo2NonVirtual", &btSliderConstraint::getInfo2NonVirtual)
	.function("getRigidBodyA", &btSliderConstraint::getRigidBodyA)
	.function("getRigidBodyB", &btSliderConstraint::getRigidBodyB)
	.function("getCalculatedTransformA", &btSliderConstraint::getCalculatedTransformA)
	.function("getCalculatedTransformB", &btSliderConstraint::getCalculatedTransformB)
	.function("getFrameOffsetA", select_overload<q(const).btTransform()const>(&btSliderConstraint::getFrameOffsetA))
	.function("getFrameOffsetB", select_overload<q(const).btTransform()const>(&btSliderConstraint::getFrameOffsetB))
	.function("getFrameOffsetA", select_overload<btTransform()>(&btSliderConstraint::getFrameOffsetA))
	.function("getFrameOffsetB", select_overload<btTransform()>(&btSliderConstraint::getFrameOffsetB))
	.function("getLowerLinLimit", &btSliderConstraint::getLowerLinLimit)
	.function("setLowerLinLimit", &btSliderConstraint::setLowerLinLimit)
	.function("getUpperLinLimit", &btSliderConstraint::getUpperLinLimit)
	.function("setUpperLinLimit", &btSliderConstraint::setUpperLinLimit)
	.function("getLowerAngLimit", &btSliderConstraint::getLowerAngLimit)
	.function("setLowerAngLimit", &btSliderConstraint::setLowerAngLimit)
	.function("getUpperAngLimit", &btSliderConstraint::getUpperAngLimit)
	.function("setUpperAngLimit", &btSliderConstraint::setUpperAngLimit)
	.function("getUseLinearReferenceFrameA", &btSliderConstraint::getUseLinearReferenceFrameA)
	.function("getSoftnessDirLin", &btSliderConstraint::getSoftnessDirLin)
	.function("getRestitutionDirLin", &btSliderConstraint::getRestitutionDirLin)
	.function("getDampingDirLin", &btSliderConstraint::getDampingDirLin)
	.function("getSoftnessDirAng", &btSliderConstraint::getSoftnessDirAng)
	.function("getRestitutionDirAng", &btSliderConstraint::getRestitutionDirAng)
	.function("getDampingDirAng", &btSliderConstraint::getDampingDirAng)
	.function("getSoftnessLimLin", &btSliderConstraint::getSoftnessLimLin)
	.function("getRestitutionLimLin", &btSliderConstraint::getRestitutionLimLin)
	.function("getDampingLimLin", &btSliderConstraint::getDampingLimLin)
	.function("getSoftnessLimAng", &btSliderConstraint::getSoftnessLimAng)
	.function("getRestitutionLimAng", &btSliderConstraint::getRestitutionLimAng)
	.function("getDampingLimAng", &btSliderConstraint::getDampingLimAng)
	.function("getSoftnessOrthoLin", &btSliderConstraint::getSoftnessOrthoLin)
	.function("getRestitutionOrthoLin", &btSliderConstraint::getRestitutionOrthoLin)
	.function("getDampingOrthoLin", &btSliderConstraint::getDampingOrthoLin)
	.function("getSoftnessOrthoAng", &btSliderConstraint::getSoftnessOrthoAng)
	.function("getRestitutionOrthoAng", &btSliderConstraint::getRestitutionOrthoAng)
	.function("getDampingOrthoAng", &btSliderConstraint::getDampingOrthoAng)
	.function("setSoftnessDirLin", &btSliderConstraint::setSoftnessDirLin)
	.function("setRestitutionDirLin", &btSliderConstraint::setRestitutionDirLin)
	.function("setDampingDirLin", &btSliderConstraint::setDampingDirLin)
	.function("setSoftnessDirAng", &btSliderConstraint::setSoftnessDirAng)
	.function("setRestitutionDirAng", &btSliderConstraint::setRestitutionDirAng)
	.function("setDampingDirAng", &btSliderConstraint::setDampingDirAng)
	.function("setSoftnessLimLin", &btSliderConstraint::setSoftnessLimLin)
	.function("setRestitutionLimLin", &btSliderConstraint::setRestitutionLimLin)
	.function("setDampingLimLin", &btSliderConstraint::setDampingLimLin)
	.function("setSoftnessLimAng", &btSliderConstraint::setSoftnessLimAng)
	.function("setRestitutionLimAng", &btSliderConstraint::setRestitutionLimAng)
	.function("setDampingLimAng", &btSliderConstraint::setDampingLimAng)
	.function("setSoftnessOrthoLin", &btSliderConstraint::setSoftnessOrthoLin)
	.function("setRestitutionOrthoLin", &btSliderConstraint::setRestitutionOrthoLin)
	.function("setDampingOrthoLin", &btSliderConstraint::setDampingOrthoLin)
	.function("setSoftnessOrthoAng", &btSliderConstraint::setSoftnessOrthoAng)
	.function("setRestitutionOrthoAng", &btSliderConstraint::setRestitutionOrthoAng)
	.function("setDampingOrthoAng", &btSliderConstraint::setDampingOrthoAng)
	.function("setPoweredLinMotor", &btSliderConstraint::setPoweredLinMotor)
	.function("getPoweredLinMotor", &btSliderConstraint::getPoweredLinMotor)
	.function("setTargetLinMotorVelocity", &btSliderConstraint::setTargetLinMotorVelocity)
	.function("getTargetLinMotorVelocity", &btSliderConstraint::getTargetLinMotorVelocity)
	.function("setMaxLinMotorForce", &btSliderConstraint::setMaxLinMotorForce)
	.function("getMaxLinMotorForce", &btSliderConstraint::getMaxLinMotorForce)
	.function("setPoweredAngMotor", &btSliderConstraint::setPoweredAngMotor)
	.function("getPoweredAngMotor", &btSliderConstraint::getPoweredAngMotor)
	.function("setTargetAngMotorVelocity", &btSliderConstraint::setTargetAngMotorVelocity)
	.function("getTargetAngMotorVelocity", &btSliderConstraint::getTargetAngMotorVelocity)
	.function("setMaxAngMotorForce", &btSliderConstraint::setMaxAngMotorForce)
	.function("getMaxAngMotorForce", &btSliderConstraint::getMaxAngMotorForce)
	.function("getLinearPos", &btSliderConstraint::getLinearPos)
	.function("getAngularPos", &btSliderConstraint::getAngularPos)
	.function("getSolveLinLimit", &btSliderConstraint::getSolveLinLimit)
	.function("getLinDepth", &btSliderConstraint::getLinDepth)
	.function("getSolveAngLimit", &btSliderConstraint::getSolveAngLimit)
	.function("getAngDepth", &btSliderConstraint::getAngDepth)
	.function("calculateTransforms", &btSliderConstraint::calculateTransforms)
	.function("testLinLimits", &btSliderConstraint::testLinLimits)
	.function("testAngLimits", &btSliderConstraint::testAngLimits)
	.function("getAncorInA", &btSliderConstraint::getAncorInA)
	.function("getAncorInB", &btSliderConstraint::getAncorInB)
	.function("getUseFrameOffset", &btSliderConstraint::getUseFrameOffset)
	.function("setUseFrameOffset", &btSliderConstraint::setUseFrameOffset)
	.function("setFrames", &btSliderConstraint::setFrames)
	.function("setParam_int_btScalar_int", select_overload<void(int, btScalar, int)>(&btSliderConstraint::setParam))
	.function("setParam_int_btScalar", select_overload<void(int, btScalar)>(&btSliderConstraint::setParam))
	.function("getParam_int_int", select_overload<btScalar(int, int)const>(&btSliderConstraint::getParam))
	.function("getParam_int", select_overload<btScalar(int)const>(&btSliderConstraint::getParam))
	.function("getFlags", &btSliderConstraint::getFlags)
	;
	class_<btSliderConstraintData>("btSliderConstraintData")
	constant("m_typeConstraintData", m_typeConstraintData);
	constant("m_rbAFrame", m_rbAFrame);
	constant("m_rbBFrame", m_rbBFrame);
	constant("m_linearUpperLimit", m_linearUpperLimit);
	constant("m_linearLowerLimit", m_linearLowerLimit);
	constant("m_angularUpperLimit", m_angularUpperLimit);
	constant("m_angularLowerLimit", m_angularLowerLimit);
	constant("m_useLinearReferenceFrameA", m_useLinearReferenceFrameA);
	constant("m_useOffsetForConstraintFrame", m_useOffsetForConstraintFrame);
	;
	class_<btSliderConstraintDoubleData>("btSliderConstraintDoubleData")
	constant("m_typeConstraintData", m_typeConstraintData);
	constant("m_rbAFrame", m_rbAFrame);
	constant("m_rbBFrame", m_rbBFrame);
	constant("m_linearUpperLimit", m_linearUpperLimit);
	constant("m_linearLowerLimit", m_linearLowerLimit);
	constant("m_angularUpperLimit", m_angularUpperLimit);
	constant("m_angularLowerLimit", m_angularLowerLimit);
	constant("m_useLinearReferenceFrameA", m_useLinearReferenceFrameA);
	constant("m_useOffsetForConstraintFrame", m_useOffsetForConstraintFrame);
	;
	class_<btSolve2LinearConstraint>("btSolve2LinearConstraint")
	.constructor<btScalar,btScalar>()
	.function("resolveUnilateralPairConstraint", &btSolve2LinearConstraint::resolveUnilateralPairConstraint)
	.function("resolveBilateralPairConstraint", &btSolve2LinearConstraint::resolveBilateralPairConstraint)
	;
	class_<btUniversalConstraint, base<btGeneric6DofConstraint>>("btUniversalConstraint")
	.constructor<r.btRigidBody,r.btRigidBody,r.q(const).btVector3,r.q(const).btVector3,r.q(const).btVector3>()
	.function("getAnchor", &btUniversalConstraint::getAnchor)
	.function("getAnchor2", &btUniversalConstraint::getAnchor2)
	.function("getAxis1", &btUniversalConstraint::getAxis1)
	.function("getAxis2", &btUniversalConstraint::getAxis2)
	.function("getAngle1", &btUniversalConstraint::getAngle1)
	.function("getAngle2", &btUniversalConstraint::getAngle2)
	.function("setUpperLimit", &btUniversalConstraint::setUpperLimit)
	.function("setLowerLimit", &btUniversalConstraint::setLowerLimit)
	.function("setAxis", &btUniversalConstraint::setAxis)
	;
	enum_<btDynamicsWorldType>("btDynamicsWorldType")
		.value("BT_SIMPLE_DYNAMICS_WORLD", BT_SIMPLE_DYNAMICS_WORLD)
		.value("BT_DISCRETE_DYNAMICS_WORLD", BT_DISCRETE_DYNAMICS_WORLD)
		.value("BT_CONTINUOUS_DYNAMICS_WORLD", BT_CONTINUOUS_DYNAMICS_WORLD)
		.value("BT_SOFT_RIGID_DYNAMICS_WORLD", BT_SOFT_RIGID_DYNAMICS_WORLD)
		.value("BT_GPU_DYNAMICS_WORLD", BT_GPU_DYNAMICS_WORLD)
		.value("BT_SOFT_MULTIBODY_DYNAMICS_WORLD", BT_SOFT_MULTIBODY_DYNAMICS_WORLD)
		;
	class_<btDynamicsWorld, base<btCollisionWorld>>("btDynamicsWorld")
	.constructor<p.btDispatcher,p.btBroadphaseInterface,p.btCollisionConfiguration>()
	.function("stepSimulation_btScalar_int_btScalar", select_overload<int(btScalar, int, btScalar)>(&btDynamicsWorld::stepSimulation))
	.function("stepSimulation_btScalar_int", select_overload<int(btScalar, int)>(&btDynamicsWorld::stepSimulation))
	.function("stepSimulation_btScalar", select_overload<int(btScalar)>(&btDynamicsWorld::stepSimulation))
	.function("addConstraint_p.btTypedConstraint_bool", select_overload<void(p.btTypedConstraint, bool)>(&btDynamicsWorld::addConstraint))
	.function("addConstraint_p.btTypedConstraint", select_overload<void(p.btTypedConstraint)>(&btDynamicsWorld::addConstraint))
	.function("removeConstraint", &btDynamicsWorld::removeConstraint)
	.function("addAction", &btDynamicsWorld::addAction)
	.function("removeAction", &btDynamicsWorld::removeAction)
	.function("setGravity", &btDynamicsWorld::setGravity)
	.function("getGravity", &btDynamicsWorld::getGravity)
	.function("synchronizeMotionStates", &btDynamicsWorld::synchronizeMotionStates)
	.function("addRigidBody_p.btRigidBody", select_overload<void(p.btRigidBody)>(&btDynamicsWorld::addRigidBody))
	.function("addRigidBody_p.btRigidBody_int_int", select_overload<void(p.btRigidBody, int, int)>(&btDynamicsWorld::addRigidBody))
	.function("removeRigidBody", &btDynamicsWorld::removeRigidBody)
	.function("setConstraintSolver", &btDynamicsWorld::setConstraintSolver)
	.function("getConstraintSolver", &btDynamicsWorld::getConstraintSolver)
	.function("getNumConstraints", &btDynamicsWorld::getNumConstraints)
	.function("getConstraint_int", select_overload<btTypedConstraint(int)>(&btDynamicsWorld::getConstraint))
	.function("getConstraint_int", select_overload<q(const).btTypedConstraint(int)const>(&btDynamicsWorld::getConstraint))
	.function("getWorldType", &btDynamicsWorld::getWorldType)
	.function("clearForces", &btDynamicsWorld::clearForces)
	.function("setInternalTickCallback_btInternalTickCallback_p.void_bool", select_overload<void(btInternalTickCallback, p.void, bool)>(&btDynamicsWorld::setInternalTickCallback))
	.function("setInternalTickCallback_btInternalTickCallback_p.void", select_overload<void(btInternalTickCallback, p.void)>(&btDynamicsWorld::setInternalTickCallback))
	.function("setInternalTickCallback_btInternalTickCallback", select_overload<void(btInternalTickCallback)>(&btDynamicsWorld::setInternalTickCallback))
	.function("setWorldUserInfo", &btDynamicsWorld::setWorldUserInfo)
	.function("getWorldUserInfo", &btDynamicsWorld::getWorldUserInfo)
	.function("getSolverInfo", &btDynamicsWorld::getSolverInfo)
	.function("addVehicle", &btDynamicsWorld::addVehicle)
	.function("removeVehicle", &btDynamicsWorld::removeVehicle)
	.function("addCharacter", &btDynamicsWorld::addCharacter)
	.function("removeCharacter", &btDynamicsWorld::removeCharacter)
	;
	class_<btDynamicsWorldDoubleData>("btDynamicsWorldDoubleData")
	constant("m_solverInfo", m_solverInfo);
	constant("m_gravity", m_gravity);
	;
	class_<btDynamicsWorldFloatData>("btDynamicsWorldFloatData")
	constant("m_solverInfo", m_solverInfo);
	constant("m_gravity", m_gravity);
	;
	class_<btSpinMutex>("btSpinMutex")
	.function("lock", &btSpinMutex::lock)
	.function("unlock", &btSpinMutex::unlock)
	.function("tryLock", &btSpinMutex::tryLock)
	;
	function("btMutexLock", &btMutexLock);
	function("btMutexUnlock", &btMutexUnlock);
	function("btMutexTryLock", &btMutexTryLock);
	class_<btDiscreteDynamicsWorld, base<btDynamicsWorld>>("btDiscreteDynamicsWorld")
	.function("predictUnconstraintMotion", &btDiscreteDynamicsWorld::predictUnconstraintMotion)
	.function("integrateTransformsInternal", &btDiscreteDynamicsWorld::integrateTransformsInternal)
	.function("integrateTransforms", &btDiscreteDynamicsWorld::integrateTransforms)
	.function("calculateSimulationIslands", &btDiscreteDynamicsWorld::calculateSimulationIslands)
	.function("solveConstraints", &btDiscreteDynamicsWorld::solveConstraints)
	.function("updateActivationState", &btDiscreteDynamicsWorld::updateActivationState)
	.function("updateActions", &btDiscreteDynamicsWorld::updateActions)
	.function("startProfiling", &btDiscreteDynamicsWorld::startProfiling)
	.function("internalSingleStepSimulation", &btDiscreteDynamicsWorld::internalSingleStepSimulation)
	.function("releasePredictiveContacts", &btDiscreteDynamicsWorld::releasePredictiveContacts)
	.function("createPredictiveContactsInternal", &btDiscreteDynamicsWorld::createPredictiveContactsInternal)
	.function("createPredictiveContacts", &btDiscreteDynamicsWorld::createPredictiveContacts)
	.function("saveKinematicState", &btDiscreteDynamicsWorld::saveKinematicState)
	.function("serializeRigidBodies", &btDiscreteDynamicsWorld::serializeRigidBodies)
	.function("serializeDynamicsWorldInfo", &btDiscreteDynamicsWorld::serializeDynamicsWorldInfo)
	.constructor<p.btDispatcher,p.btBroadphaseInterface,p.btConstraintSolver,p.btCollisionConfiguration>()
	.function("stepSimulation_btScalar_int_btScalar", select_overload<int(btScalar, int, btScalar)>(&btDiscreteDynamicsWorld::stepSimulation))
	.function("stepSimulation_btScalar_int", select_overload<int(btScalar, int)>(&btDiscreteDynamicsWorld::stepSimulation))
	.function("stepSimulation_btScalar", select_overload<int(btScalar)>(&btDiscreteDynamicsWorld::stepSimulation))
	.function("synchronizeSingleMotionState", &btDiscreteDynamicsWorld::synchronizeSingleMotionState)
	.function("addConstraint_p.btTypedConstraint_bool", select_overload<void(p.btTypedConstraint, bool)>(&btDiscreteDynamicsWorld::addConstraint))
	.function("addConstraint_p.btTypedConstraint", select_overload<void(p.btTypedConstraint)>(&btDiscreteDynamicsWorld::addConstraint))
	.function("getSimulationIslandManager", select_overload<btSimulationIslandManager()>(&btDiscreteDynamicsWorld::getSimulationIslandManager))
	.function("getSimulationIslandManager", select_overload<q(const).btSimulationIslandManager()const>(&btDiscreteDynamicsWorld::getSimulationIslandManager))
	.function("getCollisionWorld", &btDiscreteDynamicsWorld::getCollisionWorld)
	.function("addCollisionObject_p.btCollisionObject_int_int", select_overload<void(p.btCollisionObject, int, int)>(&btDiscreteDynamicsWorld::addCollisionObject))
	.function("addCollisionObject_p.btCollisionObject_int", select_overload<void(p.btCollisionObject, int)>(&btDiscreteDynamicsWorld::addCollisionObject))
	.function("addCollisionObject_p.btCollisionObject", select_overload<void(p.btCollisionObject)>(&btDiscreteDynamicsWorld::addCollisionObject))
	.function("addRigidBody_p.btRigidBody", select_overload<void(p.btRigidBody)>(&btDiscreteDynamicsWorld::addRigidBody))
	.function("addRigidBody_p.btRigidBody_int_int", select_overload<void(p.btRigidBody, int, int)>(&btDiscreteDynamicsWorld::addRigidBody))
	.function("debugDrawConstraint", &btDiscreteDynamicsWorld::debugDrawConstraint)
	.function("getConstraint_int", select_overload<btTypedConstraint(int)>(&btDiscreteDynamicsWorld::getConstraint))
	.function("getConstraint_int", select_overload<q(const).btTypedConstraint(int)const>(&btDiscreteDynamicsWorld::getConstraint))
	.function("applyGravity", &btDiscreteDynamicsWorld::applyGravity)
	.function("setNumTasks", &btDiscreteDynamicsWorld::setNumTasks)
	.function("updateVehicles", &btDiscreteDynamicsWorld::updateVehicles)
	.function("setSynchronizeAllMotionStates", &btDiscreteDynamicsWorld::setSynchronizeAllMotionStates)
	.function("getSynchronizeAllMotionStates", &btDiscreteDynamicsWorld::getSynchronizeAllMotionStates)
	.function("setApplySpeculativeContactRestitution", &btDiscreteDynamicsWorld::setApplySpeculativeContactRestitution)
	.function("getApplySpeculativeContactRestitution", &btDiscreteDynamicsWorld::getApplySpeculativeContactRestitution)
	.function("setLatencyMotionStateInterpolation", &btDiscreteDynamicsWorld::setLatencyMotionStateInterpolation)
	.function("getLatencyMotionStateInterpolation", &btDiscreteDynamicsWorld::getLatencyMotionStateInterpolation)
	;
	class_<btSimpleDynamicsWorld, base<btDynamicsWorld>>("btSimpleDynamicsWorld")
	.function("predictUnconstraintMotion", &btSimpleDynamicsWorld::predictUnconstraintMotion)
	.function("integrateTransforms", &btSimpleDynamicsWorld::integrateTransforms)
	.constructor<p.btDispatcher,p.btBroadphaseInterface,p.btConstraintSolver,p.btCollisionConfiguration>()
	.function("stepSimulation_btScalar_int_btScalar", select_overload<int(btScalar, int, btScalar)>(&btSimpleDynamicsWorld::stepSimulation))
	.function("stepSimulation_btScalar_int", select_overload<int(btScalar, int)>(&btSimpleDynamicsWorld::stepSimulation))
	.function("stepSimulation_btScalar", select_overload<int(btScalar)>(&btSimpleDynamicsWorld::stepSimulation))
	.function("addRigidBody_p.btRigidBody", select_overload<void(p.btRigidBody)>(&btSimpleDynamicsWorld::addRigidBody))
	.function("addRigidBody_p.btRigidBody_int_int", select_overload<void(p.btRigidBody, int, int)>(&btSimpleDynamicsWorld::addRigidBody))
	;
	enum_<btMultiBodyLinkFlags>("btMultiBodyLinkFlags")
		.value("BT_MULTIBODYLINKFLAGS_DISABLE_PARENT_COLLISION", BT_MULTIBODYLINKFLAGS_DISABLE_PARENT_COLLISION)
		;
	class_<btSpatialForceVector>("btSpatialForceVector")
	constant("m_topVec", m_topVec);
	constant("m_bottomVec", m_bottomVec);
	.constructor<r.q(const).btVector3,r.q(const).btVector3>()
	.constructor<r.q(const).btScalar,r.q(const).btScalar,r.q(const).btScalar,r.q(const).btScalar,r.q(const).btScalar,r.q(const).btScalar>()
	.function("setVector", &btSpatialForceVector::setVector)
	.function("setValue", &btSpatialForceVector::setValue)
	.function("addVector", &btSpatialForceVector::addVector)
	.function("addValue", &btSpatialForceVector::addValue)
	.function("getLinear", &btSpatialForceVector::getLinear)
	.function("getAngular", &btSpatialForceVector::getAngular)
	.function("setLinear", &btSpatialForceVector::setLinear)
	.function("setAngular", &btSpatialForceVector::setAngular)
	.function("addAngular", &btSpatialForceVector::addAngular)
	.function("addLinear", &btSpatialForceVector::addLinear)
	.function("setZero", &btSpatialForceVector::setZero)
	.function("operator -", &btSpatialForceVector::operator -)
	.function("operator +", &btSpatialForceVector::operator +)
	.function("operator -", &btSpatialForceVector::operator -)
	.function("operator *", &btSpatialForceVector::operator *)
	;
	class_<btSpatialMotionVector>("btSpatialMotionVector")
	constant("m_topVec", m_topVec);
	constant("m_bottomVec", m_bottomVec);
	.constructor<r.q(const).btVector3,r.q(const).btVector3>()
	.function("setVector", &btSpatialMotionVector::setVector)
	.function("setValue", &btSpatialMotionVector::setValue)
	.function("addVector", &btSpatialMotionVector::addVector)
	.function("addValue", &btSpatialMotionVector::addValue)
	.function("getAngular", &btSpatialMotionVector::getAngular)
	.function("getLinear", &btSpatialMotionVector::getLinear)
	.function("setAngular", &btSpatialMotionVector::setAngular)
	.function("setLinear", &btSpatialMotionVector::setLinear)
	.function("addAngular", &btSpatialMotionVector::addAngular)
	.function("addLinear", &btSpatialMotionVector::addLinear)
	.function("setZero", &btSpatialMotionVector::setZero)
	.function("dot", &btSpatialMotionVector::dot)
	.function("operator -", &btSpatialMotionVector::operator -)
	.function("operator +", &btSpatialMotionVector::operator +)
	.function("operator -", &btSpatialMotionVector::operator -)
	.function("operator *", &btSpatialMotionVector::operator *)
	;
	class_<btSymmetricSpatialDyad>("btSymmetricSpatialDyad")
	constant("m_topLeftMat", m_topLeftMat);
	constant("m_topRightMat", m_topRightMat);
	constant("m_bottomLeftMat", m_bottomLeftMat);
	.constructor<r.q(const).btMatrix3x3,r.q(const).btMatrix3x3,r.q(const).btMatrix3x3>()
	.function("setMatrix", &btSymmetricSpatialDyad::setMatrix)
	.function("addMatrix", &btSymmetricSpatialDyad::addMatrix)
	.function("setIdentity", &btSymmetricSpatialDyad::setIdentity)
	.function("operator *", &btSymmetricSpatialDyad::operator *)
	;
	class_<btSpatialTransformationMatrix>("btSpatialTransformationMatrix")
	constant("m_rotMat", m_rotMat);
	constant("m_trnVec", m_trnVec);
	enum_<btSpatialTransformationMatrix::eOutputOperation>("btSpatialTransformationMatrix::eOutputOperation")
		.value("None", btSpatialTransformationMatrix::None)
		.value("Add", btSpatialTransformationMatrix::Add)
		.value("Subtract", btSpatialTransformationMatrix::Subtract)
		;
	.function("transformInverse_r.q(const).btSymmetricSpatialDyad_r.btSymmetricSpatialDyad_btSpatialTransformationMatrix::eOutputOperation", select_overload<void(r.q(const).btSymmetricSpatialDyad, r.btSymmetricSpatialDyad, btSpatialTransformationMatrix::eOutputOperation)>(&btSpatialTransformationMatrix::transformInverse))
	.function("transformInverse_r.q(const).btSymmetricSpatialDyad_r.btSymmetricSpatialDyad", select_overload<void(r.q(const).btSymmetricSpatialDyad, r.btSymmetricSpatialDyad)>(&btSpatialTransformationMatrix::transformInverse))
	;
	class_<btMultibodyLink>("btMultibodyLink")
	constant("m_mass", m_mass);
	constant("m_inertiaLocal", m_inertiaLocal);
	constant("m_parent", m_parent);
	constant("m_zeroRotParentToThis", m_zeroRotParentToThis);
	constant("m_dVector", m_dVector);
	constant("m_eVector", m_eVector);
	constant("m_absFrameTotVelocity", m_absFrameTotVelocity);
	constant("m_absFrameLocVelocity", m_absFrameLocVelocity);
	enum_<btMultibodyLink::eFeatherstoneJointType>("btMultibodyLink::eFeatherstoneJointType")
		.value("eRevolute", btMultibodyLink::eRevolute)
		.value("ePrismatic", btMultibodyLink::ePrismatic)
		.value("eSpherical", btMultibodyLink::eSpherical)
		.value("ePlanar", btMultibodyLink::ePlanar)
		.value("eFixed", btMultibodyLink::eFixed)
		.value("eInvalid", btMultibodyLink::eInvalid)
		;
	constant("m_axes", m_axes);
	.function("setAxisTop_int_r.q(const).btVector3", select_overload<void(int, r.q(const).btVector3)>(&btMultibodyLink::setAxisTop))
	.function("setAxisBottom_int_r.q(const).btVector3", select_overload<void(int, r.q(const).btVector3)>(&btMultibodyLink::setAxisBottom))
	.function("setAxisTop_int_r.q(const).btScalar_r.q(const).btScalar_r.q(const).btScalar", select_overload<void(int, r.q(const).btScalar, r.q(const).btScalar, r.q(const).btScalar)>(&btMultibodyLink::setAxisTop))
	.function("setAxisBottom_int_r.q(const).btScalar_r.q(const).btScalar_r.q(const).btScalar", select_overload<void(int, r.q(const).btScalar, r.q(const).btScalar, r.q(const).btScalar)>(&btMultibodyLink::setAxisBottom))
	.function("getAxisTop", &btMultibodyLink::getAxisTop)
	.function("getAxisBottom", &btMultibodyLink::getAxisBottom)
	constant("m_dofOffset", m_dofOffset);
	constant("m_cfgOffset", m_cfgOffset);
	constant("m_cachedRotParentToThis", m_cachedRotParentToThis);
	constant("m_cachedRVector", m_cachedRVector);
	constant("m_appliedForce", m_appliedForce);
	constant("m_appliedTorque", m_appliedTorque);
	constant("m_appliedConstraintForce", m_appliedConstraintForce);
	constant("m_appliedConstraintTorque", m_appliedConstraintTorque);
	constant("m_jointPos", m_jointPos);
	constant("m_jointTorque", m_jointTorque);
	constant("m_collider", m_collider);
	constant("m_flags", m_flags);
	constant("m_dofCount", m_dofCount);
	constant("m_posVarCount", m_posVarCount);
	constant("m_jointType", m_jointType);
	constant("m_jointFeedback", m_jointFeedback);
	constant("m_cachedWorldTransform", m_cachedWorldTransform);
	constant("m_userPtr", m_userPtr);
	constant("m_jointDamping", m_jointDamping);
	constant("m_jointFriction", m_jointFriction);
	.function("updateCacheMultiDof_p.btScalar", select_overload<void(p.btScalar)>(&btMultibodyLink::updateCacheMultiDof))
	.function("updateCacheMultiDof", select_overload<void()>(&btMultibodyLink::updateCacheMultiDof))
	;
	class_<btMultiBody>("btMultiBody")
	.constructor<int,btScalar,r.q(const).btVector3,bool,bool,bool>()
	.constructor<int,btScalar,r.q(const).btVector3,bool,bool>()
	.function("setupFixed_int_btScalar_r.q(const).btVector3_int_r.q(const).btQuaternion_r.q(const).btVector3_r.q(const).btVector3_bool", select_overload<void(int, btScalar, r.q(const).btVector3, int, r.q(const).btQuaternion, r.q(const).btVector3, r.q(const).btVector3, bool)>(&btMultiBody::setupFixed))
	.function("setupFixed_int_btScalar_r.q(const).btVector3_int_r.q(const).btQuaternion_r.q(const).btVector3_r.q(const).btVector3", select_overload<void(int, btScalar, r.q(const).btVector3, int, r.q(const).btQuaternion, r.q(const).btVector3, r.q(const).btVector3)>(&btMultiBody::setupFixed))
	.function("setupPrismatic", &btMultiBody::setupPrismatic)
	.function("setupRevolute_int_btScalar_r.q(const).btVector3_int_r.q(const).btQuaternion_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3_bool", select_overload<void(int, btScalar, r.q(const).btVector3, int, r.q(const).btQuaternion, r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3, bool)>(&btMultiBody::setupRevolute))
	.function("setupRevolute_int_btScalar_r.q(const).btVector3_int_r.q(const).btQuaternion_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3", select_overload<void(int, btScalar, r.q(const).btVector3, int, r.q(const).btQuaternion, r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3)>(&btMultiBody::setupRevolute))
	.function("setupSpherical_int_btScalar_r.q(const).btVector3_int_r.q(const).btQuaternion_r.q(const).btVector3_r.q(const).btVector3_bool", select_overload<void(int, btScalar, r.q(const).btVector3, int, r.q(const).btQuaternion, r.q(const).btVector3, r.q(const).btVector3, bool)>(&btMultiBody::setupSpherical))
	.function("setupSpherical_int_btScalar_r.q(const).btVector3_int_r.q(const).btQuaternion_r.q(const).btVector3_r.q(const).btVector3", select_overload<void(int, btScalar, r.q(const).btVector3, int, r.q(const).btQuaternion, r.q(const).btVector3, r.q(const).btVector3)>(&btMultiBody::setupSpherical))
	.function("setupPlanar_int_btScalar_r.q(const).btVector3_int_r.q(const).btQuaternion_r.q(const).btVector3_r.q(const).btVector3_bool", select_overload<void(int, btScalar, r.q(const).btVector3, int, r.q(const).btQuaternion, r.q(const).btVector3, r.q(const).btVector3, bool)>(&btMultiBody::setupPlanar))
	.function("setupPlanar_int_btScalar_r.q(const).btVector3_int_r.q(const).btQuaternion_r.q(const).btVector3_r.q(const).btVector3", select_overload<void(int, btScalar, r.q(const).btVector3, int, r.q(const).btQuaternion, r.q(const).btVector3, r.q(const).btVector3)>(&btMultiBody::setupPlanar))
	.function("getLink_int", select_overload<q(const).btMultibodyLink(int)const>(&btMultiBody::getLink))
	.function("getLink_int", select_overload<btMultibodyLink(int)>(&btMultiBody::getLink))
	.function("setBaseCollider", &btMultiBody::setBaseCollider)
	.function("getBaseCollider", select_overload<q(const).btMultiBodyLinkCollider()const>(&btMultiBody::getBaseCollider))
	.function("getBaseCollider", select_overload<btMultiBodyLinkCollider()>(&btMultiBody::getBaseCollider))
	.function("getParent", &btMultiBody::getParent)
	.function("getNumLinks", &btMultiBody::getNumLinks)
	.function("getNumDofs", &btMultiBody::getNumDofs)
	.function("getNumPosVars", &btMultiBody::getNumPosVars)
	.function("getBaseMass", &btMultiBody::getBaseMass)
	.function("getBaseInertia", &btMultiBody::getBaseInertia)
	.function("getLinkMass", &btMultiBody::getLinkMass)
	.function("getLinkInertia", &btMultiBody::getLinkInertia)
	.function("setBaseMass", &btMultiBody::setBaseMass)
	.function("setBaseInertia", &btMultiBody::setBaseInertia)
	.function("getBasePos", &btMultiBody::getBasePos)
	.function("getBaseVel", &btMultiBody::getBaseVel)
	.function("getWorldToBaseRot", &btMultiBody::getWorldToBaseRot)
	.function("getBaseOmega", &btMultiBody::getBaseOmega)
	.function("setBasePos", &btMultiBody::setBasePos)
	.function("setBaseWorldTransform", &btMultiBody::setBaseWorldTransform)
	.function("getBaseWorldTransform", &btMultiBody::getBaseWorldTransform)
	.function("setBaseVel", &btMultiBody::setBaseVel)
	.function("setWorldToBaseRot", &btMultiBody::setWorldToBaseRot)
	.function("setBaseOmega", &btMultiBody::setBaseOmega)
	.function("getJointPos", &btMultiBody::getJointPos)
	.function("getJointVel", &btMultiBody::getJointVel)
	.function("getJointVelMultiDof_int", select_overload<btScalar(int)>(&btMultiBody::getJointVelMultiDof))
	.function("getJointPosMultiDof_int", select_overload<btScalar(int)>(&btMultiBody::getJointPosMultiDof))
	.function("getJointVelMultiDof_int", select_overload<q(const).btScalar(int)const>(&btMultiBody::getJointVelMultiDof))
	.function("getJointPosMultiDof_int", select_overload<q(const).btScalar(int)const>(&btMultiBody::getJointPosMultiDof))
	.function("setJointPos", &btMultiBody::setJointPos)
	.function("setJointVel", &btMultiBody::setJointVel)
	.function("setJointPosMultiDof", &btMultiBody::setJointPosMultiDof)
	.function("setJointVelMultiDof", &btMultiBody::setJointVelMultiDof)
	.function("getVelocityVector", &btMultiBody::getVelocityVector)
	.function("getRVector", &btMultiBody::getRVector)
	.function("getParentToLocalRot", &btMultiBody::getParentToLocalRot)
	.function("localPosToWorld", &btMultiBody::localPosToWorld)
	.function("localDirToWorld", &btMultiBody::localDirToWorld)
	.function("worldPosToLocal", &btMultiBody::worldPosToLocal)
	.function("worldDirToLocal", &btMultiBody::worldDirToLocal)
	.function("localFrameToWorld", &btMultiBody::localFrameToWorld)
	.function("getKineticEnergy", &btMultiBody::getKineticEnergy)
	.function("getAngularMomentum", &btMultiBody::getAngularMomentum)
	.function("clearForcesAndTorques", &btMultiBody::clearForcesAndTorques)
	.function("clearConstraintForces", &btMultiBody::clearConstraintForces)
	.function("clearVelocities", &btMultiBody::clearVelocities)
	.function("addBaseForce", &btMultiBody::addBaseForce)
	.function("addBaseTorque", &btMultiBody::addBaseTorque)
	.function("addLinkForce", &btMultiBody::addLinkForce)
	.function("addLinkTorque", &btMultiBody::addLinkTorque)
	.function("addBaseConstraintForce", &btMultiBody::addBaseConstraintForce)
	.function("addBaseConstraintTorque", &btMultiBody::addBaseConstraintTorque)
	.function("addLinkConstraintForce", &btMultiBody::addLinkConstraintForce)
	.function("addLinkConstraintTorque", &btMultiBody::addLinkConstraintTorque)
	.function("addJointTorque", &btMultiBody::addJointTorque)
	.function("addJointTorqueMultiDof_int_int_btScalar", select_overload<void(int, int, btScalar)>(&btMultiBody::addJointTorqueMultiDof))
	.function("addJointTorqueMultiDof_int_p.q(const).btScalar", select_overload<void(int, p.q(const).btScalar)>(&btMultiBody::addJointTorqueMultiDof))
	.function("getBaseForce", &btMultiBody::getBaseForce)
	.function("getBaseTorque", &btMultiBody::getBaseTorque)
	.function("getLinkForce", &btMultiBody::getLinkForce)
	.function("getLinkTorque", &btMultiBody::getLinkTorque)
	.function("getJointTorque", &btMultiBody::getJointTorque)
	.function("getJointTorqueMultiDof", &btMultiBody::getJointTorqueMultiDof)
	.function("computeAccelerationsArticulatedBodyAlgorithmMultiDof_btScalar_r.btAlignedObjectArray<(btScalar)>_r.btAlignedObjectArray<(btVector3)>_r.btAlignedObjectArray<(btMatrix3x3)>_bool", select_overload<void(btScalar, r.btAlignedObjectArray<(btScalar)>, r.btAlignedObjectArray<(btVector3)>, r.btAlignedObjectArray<(btMatrix3x3)>, bool)>(&btMultiBody::computeAccelerationsArticulatedBodyAlgorithmMultiDof))
	.function("computeAccelerationsArticulatedBodyAlgorithmMultiDof_btScalar_r.btAlignedObjectArray<(btScalar)>_r.btAlignedObjectArray<(btVector3)>_r.btAlignedObjectArray<(btMatrix3x3)>", select_overload<void(btScalar, r.btAlignedObjectArray<(btScalar)>, r.btAlignedObjectArray<(btVector3)>, r.btAlignedObjectArray<(btMatrix3x3)>)>(&btMultiBody::computeAccelerationsArticulatedBodyAlgorithmMultiDof))
	.function("stepVelocitiesMultiDof_btScalar_r.btAlignedObjectArray<(btScalar)>_r.btAlignedObjectArray<(btVector3)>_r.btAlignedObjectArray<(btMatrix3x3)>_bool", select_overload<void(btScalar, r.btAlignedObjectArray<(btScalar)>, r.btAlignedObjectArray<(btVector3)>, r.btAlignedObjectArray<(btMatrix3x3)>, bool)>(&btMultiBody::stepVelocitiesMultiDof))
	.function("stepVelocitiesMultiDof_btScalar_r.btAlignedObjectArray<(btScalar)>_r.btAlignedObjectArray<(btVector3)>_r.btAlignedObjectArray<(btMatrix3x3)>", select_overload<void(btScalar, r.btAlignedObjectArray<(btScalar)>, r.btAlignedObjectArray<(btVector3)>, r.btAlignedObjectArray<(btMatrix3x3)>)>(&btMultiBody::stepVelocitiesMultiDof))
	.function("calcAccelerationDeltasMultiDof", &btMultiBody::calcAccelerationDeltasMultiDof)
	.function("applyDeltaVeeMultiDof2", &btMultiBody::applyDeltaVeeMultiDof2)
	.function("processDeltaVeeMultiDof2", &btMultiBody::processDeltaVeeMultiDof2)
	.function("applyDeltaVeeMultiDof", &btMultiBody::applyDeltaVeeMultiDof)
	.function("stepPositionsMultiDof_btScalar_p.btScalar_p.btScalar", select_overload<void(btScalar, p.btScalar, p.btScalar)>(&btMultiBody::stepPositionsMultiDof))
	.function("stepPositionsMultiDof_btScalar_p.btScalar", select_overload<void(btScalar, p.btScalar)>(&btMultiBody::stepPositionsMultiDof))
	.function("stepPositionsMultiDof_btScalar", select_overload<void(btScalar)>(&btMultiBody::stepPositionsMultiDof))
	.function("fillContactJacobianMultiDof", &btMultiBody::fillContactJacobianMultiDof)
	.function("fillConstraintJacobianMultiDof", &btMultiBody::fillConstraintJacobianMultiDof)
	.function("setCanSleep", &btMultiBody::setCanSleep)
	.function("getCanSleep", &btMultiBody::getCanSleep)
	.function("isAwake", &btMultiBody::isAwake)
	.function("wakeUp", &btMultiBody::wakeUp)
	.function("goToSleep", &btMultiBody::goToSleep)
	.function("checkMotionAndSleepIfRequired", &btMultiBody::checkMotionAndSleepIfRequired)
	.function("hasFixedBase", &btMultiBody::hasFixedBase)
	.function("getCompanionId", &btMultiBody::getCompanionId)
	.function("setCompanionId", &btMultiBody::setCompanionId)
	.function("setNumLinks", &btMultiBody::setNumLinks)
	.function("getLinearDamping", &btMultiBody::getLinearDamping)
	.function("setLinearDamping", &btMultiBody::setLinearDamping)
	.function("getAngularDamping", &btMultiBody::getAngularDamping)
	.function("setAngularDamping", &btMultiBody::setAngularDamping)
	.function("getUseGyroTerm", &btMultiBody::getUseGyroTerm)
	.function("setUseGyroTerm", &btMultiBody::setUseGyroTerm)
	.function("getMaxCoordinateVelocity", &btMultiBody::getMaxCoordinateVelocity)
	.function("setMaxCoordinateVelocity", &btMultiBody::setMaxCoordinateVelocity)
	.function("getMaxAppliedImpulse", &btMultiBody::getMaxAppliedImpulse)
	.function("setMaxAppliedImpulse", &btMultiBody::setMaxAppliedImpulse)
	.function("setHasSelfCollision", &btMultiBody::setHasSelfCollision)
	.function("hasSelfCollision", &btMultiBody::hasSelfCollision)
	.function("finalizeMultiDof", &btMultiBody::finalizeMultiDof)
	.function("useRK4Integration", &btMultiBody::useRK4Integration)
	.function("isUsingRK4Integration", &btMultiBody::isUsingRK4Integration)
	.function("useGlobalVelocities", &btMultiBody::useGlobalVelocities)
	.function("isUsingGlobalVelocities", &btMultiBody::isUsingGlobalVelocities)
	.function("isPosUpdated", &btMultiBody::isPosUpdated)
	.function("setPosUpdated", &btMultiBody::setPosUpdated)
	.function("internalNeedsJointFeedback", &btMultiBody::internalNeedsJointFeedback)
	.function("forwardKinematics", &btMultiBody::forwardKinematics)
	.function("compTreeLinkVelocities", &btMultiBody::compTreeLinkVelocities)
	.function("updateCollisionObjectWorldTransforms", &btMultiBody::updateCollisionObjectWorldTransforms)
	.function("calculateSerializeBufferSize", &btMultiBody::calculateSerializeBufferSize)
	.function("serialize", &btMultiBody::serialize)
	.function("getBaseName", &btMultiBody::getBaseName)
	.function("setBaseName", &btMultiBody::setBaseName)
	.function("getUserPointer", &btMultiBody::getUserPointer)
	.function("getUserIndex", &btMultiBody::getUserIndex)
	.function("getUserIndex2", &btMultiBody::getUserIndex2)
	.function("setUserPointer", &btMultiBody::setUserPointer)
	.function("setUserIndex", &btMultiBody::setUserIndex)
	.function("setUserIndex2", &btMultiBody::setUserIndex2)
	.constructor<r.q(const).btMultiBody>()
	.function("solveImatrix", &btMultiBody::solveImatrix)
	.function("solveImatrix", &btMultiBody::solveImatrix)
	.function("updateLinksDofOffsets", &btMultiBody::updateLinksDofOffsets)
	.function("mulMatrix", &btMultiBody::mulMatrix)
	;
	class_<btMultiBodyLinkDoubleData>("btMultiBodyLinkDoubleData")
	constant("m_zeroRotParentToThis", m_zeroRotParentToThis);
	constant("m_parentComToThisComOffset", m_parentComToThisComOffset);
	constant("m_thisPivotToThisComOffset", m_thisPivotToThisComOffset);
	constant("m_jointAxisTop", m_jointAxisTop);
	constant("m_jointAxisBottom", m_jointAxisBottom);
	constant("m_linkInertia", m_linkInertia);
	constant("m_linkMass", m_linkMass);
	constant("m_parentIndex", m_parentIndex);
	constant("m_jointType", m_jointType);
	constant("m_dofCount", m_dofCount);
	constant("m_posVarCount", m_posVarCount);
	constant("m_jointPos", m_jointPos);
	constant("m_jointVel", m_jointVel);
	constant("m_jointTorque", m_jointTorque);
	constant("m_jointDamping", m_jointDamping);
	constant("m_jointFriction", m_jointFriction);
	constant("m_linkName", m_linkName);
	constant("m_jointName", m_jointName);
	constant("m_linkCollider", m_linkCollider);
	constant("m_paddingPtr", m_paddingPtr);
	;
	class_<btMultiBodyLinkFloatData>("btMultiBodyLinkFloatData")
	constant("m_zeroRotParentToThis", m_zeroRotParentToThis);
	constant("m_parentComToThisComOffset", m_parentComToThisComOffset);
	constant("m_thisPivotToThisComOffset", m_thisPivotToThisComOffset);
	constant("m_jointAxisTop", m_jointAxisTop);
	constant("m_jointAxisBottom", m_jointAxisBottom);
	constant("m_linkInertia", m_linkInertia);
	constant("m_dofCount", m_dofCount);
	constant("m_linkMass", m_linkMass);
	constant("m_parentIndex", m_parentIndex);
	constant("m_jointType", m_jointType);
	constant("m_jointPos", m_jointPos);
	constant("m_jointVel", m_jointVel);
	constant("m_jointTorque", m_jointTorque);
	constant("m_posVarCount", m_posVarCount);
	constant("m_jointDamping", m_jointDamping);
	constant("m_jointFriction", m_jointFriction);
	constant("m_linkName", m_linkName);
	constant("m_jointName", m_jointName);
	constant("m_linkCollider", m_linkCollider);
	constant("m_paddingPtr", m_paddingPtr);
	;
	class_<btMultiBodyDoubleData>("btMultiBodyDoubleData")
	constant("m_baseWorldTransform", m_baseWorldTransform);
	constant("m_baseInertia", m_baseInertia);
	constant("m_baseMass", m_baseMass);
	constant("m_baseName", m_baseName);
	constant("m_links", m_links);
	constant("m_baseCollider", m_baseCollider);
	constant("m_paddingPtr", m_paddingPtr);
	constant("m_numLinks", m_numLinks);
	constant("m_padding", m_padding);
	;
	class_<btMultiBodyFloatData>("btMultiBodyFloatData")
	constant("m_baseName", m_baseName);
	constant("m_links", m_links);
	constant("m_baseCollider", m_baseCollider);
	constant("m_baseWorldTransform", m_baseWorldTransform);
	constant("m_baseInertia", m_baseInertia);
	constant("m_baseMass", m_baseMass);
	constant("m_numLinks", m_numLinks);
	;
	class_<btMultiBodySolverConstraint>("btMultiBodySolverConstraint")
	constant("m_deltaVelAindex", m_deltaVelAindex);
	constant("m_jacAindex", m_jacAindex);
	constant("m_deltaVelBindex", m_deltaVelBindex);
	constant("m_jacBindex", m_jacBindex);
	constant("m_relpos1CrossNormal", m_relpos1CrossNormal);
	constant("m_contactNormal1", m_contactNormal1);
	constant("m_relpos2CrossNormal", m_relpos2CrossNormal);
	constant("m_contactNormal2", m_contactNormal2);
	constant("m_angularComponentA", m_angularComponentA);
	constant("m_angularComponentB", m_angularComponentB);
	constant("m_appliedPushImpulse", m_appliedPushImpulse);
	constant("m_appliedImpulse", m_appliedImpulse);
	constant("m_friction", m_friction);
	constant("m_jacDiagABInv", m_jacDiagABInv);
	constant("m_rhs", m_rhs);
	constant("m_cfm", m_cfm);
	constant("m_lowerLimit", m_lowerLimit);
	constant("m_upperLimit", m_upperLimit);
	constant("m_rhsPenetration", m_rhsPenetration);
	constant("m_overrideNumSolverIterations", m_overrideNumSolverIterations);
	constant("m_frictionIndex", m_frictionIndex);
	constant("m_solverBodyIdA", m_solverBodyIdA);
	constant("m_multiBodyA", m_multiBodyA);
	constant("m_linkA", m_linkA);
	constant("m_solverBodyIdB", m_solverBodyIdB);
	constant("m_multiBodyB", m_multiBodyB);
	constant("m_linkB", m_linkB);
	constant("m_orgConstraint", m_orgConstraint);
	constant("m_orgDofIndex", m_orgDofIndex);
	enum_<btMultiBodySolverConstraint::btSolverConstraintType>("btMultiBodySolverConstraint::btSolverConstraintType")
		.value("BT_SOLVER_CONTACT_1D", btMultiBodySolverConstraint::BT_SOLVER_CONTACT_1D)
		.value("BT_SOLVER_FRICTION_1D", btMultiBodySolverConstraint::BT_SOLVER_FRICTION_1D)
		;
	;
	class_<btMultiBodyJacobianData>("btMultiBodyJacobianData")
	constant("m_jacobians", m_jacobians);
	constant("m_deltaVelocitiesUnitImpulse", m_deltaVelocitiesUnitImpulse);
	constant("m_deltaVelocities", m_deltaVelocities);
	constant("scratch_r", scratch_r);
	constant("scratch_v", scratch_v);
	constant("scratch_m", scratch_m);
	constant("m_solverBodyPool", m_solverBodyPool);
	constant("m_fixedBodyId", m_fixedBodyId);
	;
	class_<btMultiBodyConstraint>("btMultiBodyConstraint")
	.function("applyDeltaVee", &btMultiBodyConstraint::applyDeltaVee)
	.function("fillMultiBodyConstraint", &btMultiBodyConstraint::fillMultiBodyConstraint)
	.function("fillMultiBodyConstraint", &btMultiBodyConstraint::fillMultiBodyConstraint)
	.function("fillMultiBodyConstraint", &btMultiBodyConstraint::fillMultiBodyConstraint)
	.function("fillMultiBodyConstraint", &btMultiBodyConstraint::fillMultiBodyConstraint)
	.function("fillMultiBodyConstraint", &btMultiBodyConstraint::fillMultiBodyConstraint)
	.function("fillMultiBodyConstraint", &btMultiBodyConstraint::fillMultiBodyConstraint)
	.constructor<p.btMultiBody,p.btMultiBody,int,int,int,bool>()
	.function("updateJacobianSizes", &btMultiBodyConstraint::updateJacobianSizes)
	.function("allocateJacobiansMultiDof", &btMultiBodyConstraint::allocateJacobiansMultiDof)
	.function("setFrameInB", &btMultiBodyConstraint::setFrameInB)
	.function("setPivotInB", &btMultiBodyConstraint::setPivotInB)
	.function("finalizeMultiDof", &btMultiBodyConstraint::finalizeMultiDof)
	.function("getIslandIdA", &btMultiBodyConstraint::getIslandIdA)
	.function("getIslandIdB", &btMultiBodyConstraint::getIslandIdB)
	.function("createConstraintRows", &btMultiBodyConstraint::createConstraintRows)
	.function("getNumRows", &btMultiBodyConstraint::getNumRows)
	.function("getMultiBodyA", &btMultiBodyConstraint::getMultiBodyA)
	.function("getMultiBodyB", &btMultiBodyConstraint::getMultiBodyB)
	.function("internalSetAppliedImpulse", &btMultiBodyConstraint::internalSetAppliedImpulse)
	.function("getAppliedImpulse", &btMultiBodyConstraint::getAppliedImpulse)
	.function("getPosition", &btMultiBodyConstraint::getPosition)
	.function("setPosition", &btMultiBodyConstraint::setPosition)
	.function("isUnilateral", &btMultiBodyConstraint::isUnilateral)
	.function("jacobianA_int", select_overload<btScalar(int)>(&btMultiBodyConstraint::jacobianA))
	.function("jacobianA_int", select_overload<q(const).btScalar(int)const>(&btMultiBodyConstraint::jacobianA))
	.function("jacobianB_int", select_overload<btScalar(int)>(&btMultiBodyConstraint::jacobianB))
	.function("jacobianB_int", select_overload<q(const).btScalar(int)const>(&btMultiBodyConstraint::jacobianB))
	.function("getMaxAppliedImpulse", &btMultiBodyConstraint::getMaxAppliedImpulse)
	.function("setMaxAppliedImpulse", &btMultiBodyConstraint::setMaxAppliedImpulse)
	.function("debugDraw", &btMultiBodyConstraint::debugDraw)
	;
	class_<btMultiBodyConstraintSolver, base<btSequentialImpulseConstraintSolver>>("btMultiBodyConstraintSolver")
	.function("resolveSingleConstraintRowGeneric", &btMultiBodyConstraintSolver::resolveSingleConstraintRowGeneric)
	.function("convertContacts", &btMultiBodyConstraintSolver::convertContacts)
	.function("addMultiBodyFrictionConstraint", &btMultiBodyConstraintSolver::addMultiBodyFrictionConstraint)
	.function("addMultiBodyFrictionConstraint", &btMultiBodyConstraintSolver::addMultiBodyFrictionConstraint)
	.function("addMultiBodyFrictionConstraint", &btMultiBodyConstraintSolver::addMultiBodyFrictionConstraint)
	.function("addMultiBodyTorsionalFrictionConstraint", &btMultiBodyConstraintSolver::addMultiBodyTorsionalFrictionConstraint)
	.function("addMultiBodyTorsionalFrictionConstraint", &btMultiBodyConstraintSolver::addMultiBodyTorsionalFrictionConstraint)
	.function("addMultiBodyTorsionalFrictionConstraint", &btMultiBodyConstraintSolver::addMultiBodyTorsionalFrictionConstraint)
	.function("setupMultiBodyJointLimitConstraint", &btMultiBodyConstraintSolver::setupMultiBodyJointLimitConstraint)
	.function("setupMultiBodyContactConstraint", &btMultiBodyConstraintSolver::setupMultiBodyContactConstraint)
	.function("setupMultiBodyContactConstraint", &btMultiBodyConstraintSolver::setupMultiBodyContactConstraint)
	.function("setupMultiBodyContactConstraint", &btMultiBodyConstraintSolver::setupMultiBodyContactConstraint)
	.function("setupMultiBodyTorsionalFrictionConstraint", &btMultiBodyConstraintSolver::setupMultiBodyTorsionalFrictionConstraint)
	.function("setupMultiBodyTorsionalFrictionConstraint", &btMultiBodyConstraintSolver::setupMultiBodyTorsionalFrictionConstraint)
	.function("setupMultiBodyTorsionalFrictionConstraint", &btMultiBodyConstraintSolver::setupMultiBodyTorsionalFrictionConstraint)
	.function("convertMultiBodyContact", &btMultiBodyConstraintSolver::convertMultiBodyContact)
	.function("solveGroupCacheFriendlySetup", &btMultiBodyConstraintSolver::solveGroupCacheFriendlySetup)
	.function("solveSingleIteration", &btMultiBodyConstraintSolver::solveSingleIteration)
	.function("applyDeltaVee", &btMultiBodyConstraintSolver::applyDeltaVee)
	.function("writeBackSolverBodyToMultiBody", &btMultiBodyConstraintSolver::writeBackSolverBodyToMultiBody)
	.function("solveGroupCacheFriendlyFinish", &btMultiBodyConstraintSolver::solveGroupCacheFriendlyFinish)
	.function("solveMultiBodyGroup", &btMultiBodyConstraintSolver::solveMultiBodyGroup)
	;
	class_<btMultiBodyDynamicsWorld, base<btDiscreteDynamicsWorld>>("btMultiBodyDynamicsWorld")
	.function("calculateSimulationIslands", &btMultiBodyDynamicsWorld::calculateSimulationIslands)
	.function("updateActivationState", &btMultiBodyDynamicsWorld::updateActivationState)
	.function("solveConstraints", &btMultiBodyDynamicsWorld::solveConstraints)
	.function("serializeMultiBodies", &btMultiBodyDynamicsWorld::serializeMultiBodies)
	.constructor<p.btDispatcher,p.btBroadphaseInterface,p.btMultiBodyConstraintSolver,p.btCollisionConfiguration>()
	.function("addMultiBody_p.btMultiBody_int_int", select_overload<void(p.btMultiBody, int, int)>(&btMultiBodyDynamicsWorld::addMultiBody))
	.function("addMultiBody_p.btMultiBody_int", select_overload<void(p.btMultiBody, int)>(&btMultiBodyDynamicsWorld::addMultiBody))
	.function("addMultiBody_p.btMultiBody", select_overload<void(p.btMultiBody)>(&btMultiBodyDynamicsWorld::addMultiBody))
	.function("removeMultiBody", &btMultiBodyDynamicsWorld::removeMultiBody)
	.function("getNumMultibodies", &btMultiBodyDynamicsWorld::getNumMultibodies)
	.function("getMultiBody", &btMultiBodyDynamicsWorld::getMultiBody)
	.function("addMultiBodyConstraint", &btMultiBodyDynamicsWorld::addMultiBodyConstraint)
	.function("getNumMultiBodyConstraints", &btMultiBodyDynamicsWorld::getNumMultiBodyConstraints)
	.function("getMultiBodyConstraint_int", select_overload<btMultiBodyConstraint(int)>(&btMultiBodyDynamicsWorld::getMultiBodyConstraint))
	.function("getMultiBodyConstraint_int", select_overload<q(const).btMultiBodyConstraint(int)const>(&btMultiBodyDynamicsWorld::getMultiBodyConstraint))
	.function("removeMultiBodyConstraint", &btMultiBodyDynamicsWorld::removeMultiBodyConstraint)
	.function("integrateTransforms", &btMultiBodyDynamicsWorld::integrateTransforms)
	.function("debugDrawMultiBodyConstraint", &btMultiBodyDynamicsWorld::debugDrawMultiBodyConstraint)
	.function("forwardKinematics", &btMultiBodyDynamicsWorld::forwardKinematics)
	.function("clearMultiBodyConstraintForces", &btMultiBodyDynamicsWorld::clearMultiBodyConstraintForces)
	.function("clearMultiBodyForces", &btMultiBodyDynamicsWorld::clearMultiBodyForces)
	;
	class_<btMultiBodyJointLimitConstraint, base<btMultiBodyConstraint>>("btMultiBodyJointLimitConstraint")
	.constructor<p.btMultiBody,int,btScalar,btScalar>()
	;
	class_<btMultiBodyJointMotor, base<btMultiBodyConstraint>>("btMultiBodyJointMotor")
	.constructor<p.btMultiBody,int,btScalar,btScalar>()
	.constructor<p.btMultiBody,int,int,btScalar,btScalar>()
	.function("setVelocityTarget_btScalar_btScalar", select_overload<void(btScalar, btScalar)>(&btMultiBodyJointMotor::setVelocityTarget))
	.function("setVelocityTarget_btScalar", select_overload<void(btScalar)>(&btMultiBodyJointMotor::setVelocityTarget))
	.function("setPositionTarget_btScalar_btScalar", select_overload<void(btScalar, btScalar)>(&btMultiBodyJointMotor::setPositionTarget))
	.function("setPositionTarget_btScalar", select_overload<void(btScalar)>(&btMultiBodyJointMotor::setPositionTarget))
	.function("setErp", &btMultiBodyJointMotor::setErp)
	.function("getErp", &btMultiBodyJointMotor::getErp)
	.function("setRhsClamp", &btMultiBodyJointMotor::setRhsClamp)
	;
	class_<btMultiBodyLinkCollider, base<btCollisionObject>>("btMultiBodyLinkCollider")
	.constructor<p.btMultiBody,int>()
	.class_function("upcast", &btMultiBodyLinkCollider::upcast)
	.class_function("upcast", &btMultiBodyLinkCollider::upcast)
	;
	class_<btMultiBodyPoint2Point, base<btMultiBodyConstraint>>("btMultiBodyPoint2Point")
	.constructor<p.btMultiBody,int,p.btRigidBody,r.q(const).btVector3,r.q(const).btVector3>()
	.constructor<p.btMultiBody,int,p.btMultiBody,int,r.q(const).btVector3,r.q(const).btVector3>()
	.function("getPivotInB", &btMultiBodyPoint2Point::getPivotInB)
	;
	class_<btDantzigScratchMemory>("btDantzigScratchMemory")
	constant("m_scratch", m_scratch);
	constant("L", L);
	constant("d", d);
	constant("delta_w", delta_w);
	constant("delta_x", delta_x);
	constant("Dell", Dell);
	constant("ell", ell);
	constant("Arows", Arows);
	constant("p", p);
	constant("C", C);
	constant("state", state);
	;
	function("btSolveDantzigLCP", &btSolveDantzigLCP);
	class_<btClock>("btClock")
	.constructor<r.q(const).btClock>()
	.function("reset", &btClock::reset)
	.function("getTimeMilliseconds", &btClock::getTimeMilliseconds)
	.function("getTimeMicroseconds", &btClock::getTimeMicroseconds)
	.function("getTimeNanoseconds", &btClock::getTimeNanoseconds)
	.function("getTimeSeconds", &btClock::getTimeSeconds)
	;
	function("btGetCurrentEnterProfileZoneFunc", &btGetCurrentEnterProfileZoneFunc, allow_raw_pointers());
	function("btGetCurrentLeaveProfileZoneFunc", &btGetCurrentLeaveProfileZoneFunc, allow_raw_pointers());
	function("btSetCustomEnterProfileZoneFunc", &btSetCustomEnterProfileZoneFunc);
	function("btSetCustomLeaveProfileZoneFunc", &btSetCustomLeaveProfileZoneFunc);
	function("btQuickprofGetCurrentThreadIndex2", &btQuickprofGetCurrentThreadIndex2);
	constant("BT_QUICKPROF_MAX_THREAD_COUNT", BT_QUICKPROF_MAX_THREAD_COUNT);
	class_<CProfileNode>("CProfileNode")
	.constructor<p.q(const).char,p.CProfileNode>()
	.function("Get_Sub_Node", &CProfileNode::Get_Sub_Node)
	.function("Get_Parent", &CProfileNode::Get_Parent)
	.function("Get_Sibling", &CProfileNode::Get_Sibling)
	.function("Get_Child", &CProfileNode::Get_Child)
	.function("CleanupMemory", &CProfileNode::CleanupMemory)
	.function("Reset", &CProfileNode::Reset)
	.function("Call", &CProfileNode::Call)
	.function("Return", &CProfileNode::Return)
	.function("Get_Name", &CProfileNode::Get_Name)
	.function("Get_Total_Calls", &CProfileNode::Get_Total_Calls)
	.function("Get_Total_Time", &CProfileNode::Get_Total_Time)
	.function("GetUserPointer", &CProfileNode::GetUserPointer)
	.function("SetUserPointer", &CProfileNode::SetUserPointer)
	;
	class_<CProfileManager>("CProfileManager")
	.class_function("Start_Profile", &CProfileManager::Start_Profile)
	.class_function("Stop_Profile", &CProfileManager::Stop_Profile)
	.class_function("CleanupMemory", &CProfileManager::CleanupMemory)
	.class_function("Reset", &CProfileManager::Reset)
	.class_function("Increment_Frame_Counter", &CProfileManager::Increment_Frame_Counter)
	.class_function("Get_Frame_Count_Since_Reset", &CProfileManager::Get_Frame_Count_Since_Reset)
	.class_function("Get_Time_Since_Reset", &CProfileManager::Get_Time_Since_Reset)
	.class_function("Get_Iterator", &CProfileManager::Get_Iterator)
	.class_function("Release_Iterator", &CProfileManager::Release_Iterator)
	.class_function("dumpRecursive", &CProfileManager::dumpRecursive)
	.class_function("dumpAll", &CProfileManager::dumpAll)
	;
	class_<CProfileSample>("CProfileSample")
	.constructor<p.q(const).char>()
	;
	class_<btIntSortPredicate>("btIntSortPredicate")
	.function("operator ()", &btIntSortPredicate::operator ())
	;
	function("setElem", &setElem);
	function("setElem", &setElem);
	class_<btMLCPSolverInterface>("btMLCPSolverInterface")
	.function("solveMLCP_r.q(const).btMatrixXf_r.q(const).btVectorXf_r.btVectorXf_r.q(const).btVectorXf_r.q(const).btVectorXf_r.q(const).btAlignedObjectArray<(int)>_int_bool", select_overload<bool(r.q(const).btMatrixXf, r.q(const).btVectorXf, r.btVectorXf, r.q(const).btVectorXf, r.q(const).btVectorXf, r.q(const).btAlignedObjectArray<(int)>, int, bool)>(&btMLCPSolverInterface::solveMLCP))
	.function("solveMLCP_r.q(const).btMatrixXf_r.q(const).btVectorXf_r.btVectorXf_r.q(const).btVectorXf_r.q(const).btVectorXf_r.q(const).btAlignedObjectArray<(int)>_int", select_overload<bool(r.q(const).btMatrixXf, r.q(const).btVectorXf, r.btVectorXf, r.q(const).btVectorXf, r.q(const).btVectorXf, r.q(const).btAlignedObjectArray<(int)>, int)>(&btMLCPSolverInterface::solveMLCP))
	;
	class_<btDantzigSolver, base<btMLCPSolverInterface>>("btDantzigSolver")
	.function("solveMLCP_r.q(const).btMatrixXf_r.q(const).btVectorXf_r.btVectorXf_r.q(const).btVectorXf_r.q(const).btVectorXf_r.q(const).btAlignedObjectArray<(int)>_int_bool", select_overload<bool(r.q(const).btMatrixXf, r.q(const).btVectorXf, r.btVectorXf, r.q(const).btVectorXf, r.q(const).btVectorXf, r.q(const).btAlignedObjectArray<(int)>, int, bool)>(&btDantzigSolver::solveMLCP))
	.function("solveMLCP_r.q(const).btMatrixXf_r.q(const).btVectorXf_r.btVectorXf_r.q(const).btVectorXf_r.q(const).btVectorXf_r.q(const).btAlignedObjectArray<(int)>_int", select_overload<bool(r.q(const).btMatrixXf, r.q(const).btVectorXf, r.btVectorXf, r.q(const).btVectorXf, r.q(const).btVectorXf, r.q(const).btAlignedObjectArray<(int)>, int)>(&btDantzigSolver::solveMLCP))
	;
	class_<btMLCPSolver, base<btSequentialImpulseConstraintSolver>>("btMLCPSolver")
	.function("solveGroupCacheFriendlySetup", &btMLCPSolver::solveGroupCacheFriendlySetup)
	.function("solveGroupCacheFriendlyIterations", &btMLCPSolver::solveGroupCacheFriendlyIterations)
	.function("createMLCP", &btMLCPSolver::createMLCP)
	.function("createMLCPFast", &btMLCPSolver::createMLCPFast)
	.function("solveMLCP", &btMLCPSolver::solveMLCP)
	.constructor<p.btMLCPSolverInterface>()
	.function("setMLCPSolver", &btMLCPSolver::setMLCPSolver)
	.function("getNumFallbacks", &btMLCPSolver::getNumFallbacks)
	.function("setNumFallbacks", &btMLCPSolver::setNumFallbacks)
	;
	class_<btSolveProjectedGaussSeidel, base<btMLCPSolverInterface>>("btSolveProjectedGaussSeidel")
	.function("solveMLCP_r.q(const).btMatrixXf_r.q(const).btVectorXf_r.btVectorXf_r.q(const).btVectorXf_r.q(const).btVectorXf_r.q(const).btAlignedObjectArray<(int)>_int_bool", select_overload<bool(r.q(const).btMatrixXf, r.q(const).btVectorXf, r.btVectorXf, r.q(const).btVectorXf, r.q(const).btVectorXf, r.q(const).btAlignedObjectArray<(int)>, int, bool)>(&btSolveProjectedGaussSeidel::solveMLCP))
	.function("solveMLCP_r.q(const).btMatrixXf_r.q(const).btVectorXf_r.btVectorXf_r.q(const).btVectorXf_r.q(const).btVectorXf_r.q(const).btAlignedObjectArray<(int)>_int", select_overload<bool(r.q(const).btMatrixXf, r.q(const).btVectorXf, r.btVectorXf, r.q(const).btVectorXf, r.q(const).btVectorXf, r.q(const).btAlignedObjectArray<(int)>, int)>(&btSolveProjectedGaussSeidel::solveMLCP))
	;
	class_<btVehicleRaycaster>("btVehicleRaycaster")
	.function("castRay", &btVehicleRaycaster::castRay)
	;
	class_<btWheelInfoConstructionInfo>("btWheelInfoConstructionInfo")
	constant("m_chassisConnectionCS", m_chassisConnectionCS);
	constant("m_wheelDirectionCS", m_wheelDirectionCS);
	constant("m_wheelAxleCS", m_wheelAxleCS);
	constant("m_suspensionRestLength", m_suspensionRestLength);
	constant("m_maxSuspensionTravelCm", m_maxSuspensionTravelCm);
	constant("m_wheelRadius", m_wheelRadius);
	constant("m_suspensionStiffness", m_suspensionStiffness);
	constant("m_wheelsDampingCompression", m_wheelsDampingCompression);
	constant("m_wheelsDampingRelaxation", m_wheelsDampingRelaxation);
	constant("m_frictionSlip", m_frictionSlip);
	constant("m_maxSuspensionForce", m_maxSuspensionForce);
	constant("m_bIsFrontWheel", m_bIsFrontWheel);
	;
	class_<btWheelInfo>("btWheelInfo")
	constant("m_raycastInfo", m_raycastInfo);
	constant("m_worldTransform", m_worldTransform);
	constant("m_chassisConnectionPointCS", m_chassisConnectionPointCS);
	constant("m_wheelDirectionCS", m_wheelDirectionCS);
	constant("m_wheelAxleCS", m_wheelAxleCS);
	constant("m_suspensionRestLength1", m_suspensionRestLength1);
	constant("m_maxSuspensionTravelCm", m_maxSuspensionTravelCm);
	.function("getSuspensionRestLength", &btWheelInfo::getSuspensionRestLength)
	constant("m_wheelsRadius", m_wheelsRadius);
	constant("m_suspensionStiffness", m_suspensionStiffness);
	constant("m_wheelsDampingCompression", m_wheelsDampingCompression);
	constant("m_wheelsDampingRelaxation", m_wheelsDampingRelaxation);
	constant("m_frictionSlip", m_frictionSlip);
	constant("m_steering", m_steering);
	constant("m_rotation", m_rotation);
	constant("m_deltaRotation", m_deltaRotation);
	constant("m_rollInfluence", m_rollInfluence);
	constant("m_maxSuspensionForce", m_maxSuspensionForce);
	constant("m_engineForce", m_engineForce);
	constant("m_brake", m_brake);
	constant("m_bIsFrontWheel", m_bIsFrontWheel);
	constant("m_clientInfo", m_clientInfo);
	.constructor<r.btWheelInfoConstructionInfo>()
	.function("updateWheel", &btWheelInfo::updateWheel)
	constant("m_clippedInvContactDotSuspension", m_clippedInvContactDotSuspension);
	constant("m_suspensionRelativeVelocity", m_suspensionRelativeVelocity);
	constant("m_wheelsSuspensionForce", m_wheelsSuspensionForce);
	constant("m_skidInfo", m_skidInfo);
	;
	class_<btRaycastVehicle, base<btActionInterface>>("btRaycastVehicle")
	.function("defaultInit", &btRaycastVehicle::defaultInit)
	.constructor<r.q(const).btRaycastVehicle::btVehicleTuning,p.btRigidBody,p.btVehicleRaycaster>()
	.function("getChassisWorldTransform", &btRaycastVehicle::getChassisWorldTransform)
	.function("rayCast", &btRaycastVehicle::rayCast)
	.function("updateVehicle", &btRaycastVehicle::updateVehicle)
	.function("resetSuspension", &btRaycastVehicle::resetSuspension)
	.function("getSteeringValue", &btRaycastVehicle::getSteeringValue)
	.function("setSteeringValue", &btRaycastVehicle::setSteeringValue)
	.function("applyEngineForce", &btRaycastVehicle::applyEngineForce)
	.function("getWheelTransformWS", &btRaycastVehicle::getWheelTransformWS)
	.function("updateWheelTransform_int_bool", select_overload<void(int, bool)>(&btRaycastVehicle::updateWheelTransform))
	.function("updateWheelTransform_int", select_overload<void(int)>(&btRaycastVehicle::updateWheelTransform))
	.function("addWheel", &btRaycastVehicle::addWheel)
	.function("getNumWheels", &btRaycastVehicle::getNumWheels)
	.function("getWheelInfo_int", select_overload<q(const).btWheelInfo(int)const>(&btRaycastVehicle::getWheelInfo))
	.function("getWheelInfo_int", select_overload<btWheelInfo(int)>(&btRaycastVehicle::getWheelInfo))
	.function("updateWheelTransformsWS_r.btWheelInfo_bool", select_overload<void(r.btWheelInfo, bool)>(&btRaycastVehicle::updateWheelTransformsWS))
	.function("updateWheelTransformsWS_r.btWheelInfo", select_overload<void(r.btWheelInfo)>(&btRaycastVehicle::updateWheelTransformsWS))
	.function("setBrake", &btRaycastVehicle::setBrake)
	.function("setPitchControl", &btRaycastVehicle::setPitchControl)
	.function("updateSuspension", &btRaycastVehicle::updateSuspension)
	.function("updateFriction", &btRaycastVehicle::updateFriction)
	.function("getRigidBody", select_overload<btRigidBody()>(&btRaycastVehicle::getRigidBody))
	.function("getRigidBody", select_overload<q(const).btRigidBody()const>(&btRaycastVehicle::getRigidBody))
	.function("getRightAxis", &btRaycastVehicle::getRightAxis)
	.function("getUpAxis", &btRaycastVehicle::getUpAxis)
	.function("getForwardAxis", &btRaycastVehicle::getForwardAxis)
	.function("getForwardVector", &btRaycastVehicle::getForwardVector)
	.function("getCurrentSpeedKmHour", &btRaycastVehicle::getCurrentSpeedKmHour)
	.function("setCoordinateSystem", &btRaycastVehicle::setCoordinateSystem)
	.function("getUserConstraintType", &btRaycastVehicle::getUserConstraintType)
	.function("setUserConstraintType", &btRaycastVehicle::setUserConstraintType)
	.function("setUserConstraintId", &btRaycastVehicle::setUserConstraintId)
	.function("getUserConstraintId", &btRaycastVehicle::getUserConstraintId)
	;
	class_<btDefaultVehicleRaycaster, base<btVehicleRaycaster>>("btDefaultVehicleRaycaster")
	.constructor<p.btDynamicsWorld>()
	;
	class_<btSoftBodySolver>("btSoftBodySolver")
	enum_<btSoftBodySolver::SolverTypes>("btSoftBodySolver::SolverTypes")
		;
	.function("getSolverType", &btSoftBodySolver::getSolverType)
	.function("checkInitialized", &btSoftBodySolver::checkInitialized)
	.function("optimize_r.btAlignedObjectArray<(p.btSoftBody)>_bool", select_overload<void(r.btAlignedObjectArray<(p.btSoftBody)>, bool)>(&btSoftBodySolver::optimize))
	.function("optimize_r.btAlignedObjectArray<(p.btSoftBody)>", select_overload<void(r.btAlignedObjectArray<(p.btSoftBody)>)>(&btSoftBodySolver::optimize))
	.function("copyBackToSoftBodies_bool", select_overload<void(bool)>(&btSoftBodySolver::copyBackToSoftBodies))
	.function("copyBackToSoftBodies", select_overload<void()>(&btSoftBodySolver::copyBackToSoftBodies))
	.function("predictMotion", &btSoftBodySolver::predictMotion)
	.function("solveConstraints", &btSoftBodySolver::solveConstraints)
	.function("updateSoftBodies", &btSoftBodySolver::updateSoftBodies)
	.function("processCollision_p.btSoftBody_p.q(const).btCollisionObjectWrapper", select_overload<void(p.btSoftBody, p.q(const).btCollisionObjectWrapper)>(&btSoftBodySolver::processCollision))
	.function("processCollision_p.btSoftBody_p.btSoftBody", select_overload<void(p.btSoftBody, p.btSoftBody)>(&btSoftBodySolver::processCollision))
	.function("setNumberOfPositionIterations", &btSoftBodySolver::setNumberOfPositionIterations)
	.function("getNumberOfPositionIterations", &btSoftBodySolver::getNumberOfPositionIterations)
	.function("setNumberOfVelocityIterations", &btSoftBodySolver::setNumberOfVelocityIterations)
	.function("getNumberOfVelocityIterations", &btSoftBodySolver::getNumberOfVelocityIterations)
	.function("getTimeScale", &btSoftBodySolver::getTimeScale)
	;
	class_<btSoftBodySolverOutput>("btSoftBodySolverOutput")
	.function("copySoftBodyToVertexBuffer", &btSoftBodySolverOutput::copySoftBodyToVertexBuffer)
	;
	class_<btVertexBufferDescriptor>("btVertexBufferDescriptor")
	enum_<btVertexBufferDescriptor::BufferTypes>("btVertexBufferDescriptor::BufferTypes")
		;
	.function("hasVertexPositions", &btVertexBufferDescriptor::hasVertexPositions)
	.function("hasNormals", &btVertexBufferDescriptor::hasNormals)
	.function("getBufferType", &btVertexBufferDescriptor::getBufferType)
	.function("getVertexOffset", &btVertexBufferDescriptor::getVertexOffset)
	.function("getVertexStride", &btVertexBufferDescriptor::getVertexStride)
	.function("getNormalOffset", &btVertexBufferDescriptor::getNormalOffset)
	.function("getNormalStride", &btVertexBufferDescriptor::getNormalStride)
	;
	class_<btCPUVertexBufferDescriptor, base<btVertexBufferDescriptor>>("btCPUVertexBufferDescriptor")
	.constructor<p.float,int,int>()
	.constructor<p.float,int,int,int,int>()
	.function("getBasePointer", &btCPUVertexBufferDescriptor::getBasePointer)
	;
	class_<btDefaultSoftBodySolver, base<btSoftBodySolver>>("btDefaultSoftBodySolver")
	.function("optimize_r.btAlignedObjectArray<(p.btSoftBody)>_bool", select_overload<void(r.btAlignedObjectArray<(p.btSoftBody)>, bool)>(&btDefaultSoftBodySolver::optimize))
	.function("optimize_r.btAlignedObjectArray<(p.btSoftBody)>", select_overload<void(r.btAlignedObjectArray<(p.btSoftBody)>)>(&btDefaultSoftBodySolver::optimize))
	.function("copyBackToSoftBodies_bool", select_overload<void(bool)>(&btDefaultSoftBodySolver::copyBackToSoftBodies))
	.function("copyBackToSoftBodies", select_overload<void()>(&btDefaultSoftBodySolver::copyBackToSoftBodies))
	.function("copySoftBodyToVertexBuffer", &btDefaultSoftBodySolver::copySoftBodyToVertexBuffer)
	.function("processCollision_p.btSoftBody_p.q(const).btCollisionObjectWrapper", select_overload<void(p.btSoftBody, p.q(const).btCollisionObjectWrapper)>(&btDefaultSoftBodySolver::processCollision))
	.function("processCollision_p.btSoftBody_p.btSoftBody", select_overload<void(p.btSoftBody, p.btSoftBody)>(&btDefaultSoftBodySolver::processCollision))
	;
	class_<btSoftBodyWorldInfo>("btSoftBodyWorldInfo")
	constant("air_density", air_density);
	constant("water_density", water_density);
	constant("water_offset", water_offset);
	constant("m_maxDisplacement", m_maxDisplacement);
	constant("water_normal", water_normal);
	constant("m_broadphase", m_broadphase);
	constant("m_dispatcher", m_dispatcher);
	constant("m_gravity", m_gravity);
	constant("m_sparsesdf", m_sparsesdf);
	;
	class_<btSoftBody, base<btCollisionObject>>("btSoftBody")
	.constructor<p.btSoftBodyWorldInfo,int,p.q(const).btVector3,p.q(const).btScalar>()
	.constructor<p.btSoftBodyWorldInfo>()
	.function("initDefaults", &btSoftBody::initDefaults)
	.function("getWorldInfo", &btSoftBody::getWorldInfo)
	.function("checkLink_int_int", select_overload<bool(int, int)const>(&btSoftBody::checkLink))
	.function("checkLink_p.q(const).btSoftBody::Node_p.q(const).btSoftBody::Node", select_overload<bool(p.q(const).btSoftBody::Node, p.q(const).btSoftBody::Node)const>(&btSoftBody::checkLink))
	.function("checkFace", &btSoftBody::checkFace)
	.function("appendMaterial", &btSoftBody::appendMaterial)
	.function("appendNote_p.q(const).char_r.q(const).btVector3_r.q(const).btVector4_p.btSoftBody::Node_p.btSoftBody::Node_p.btSoftBody::Node_p.btSoftBody::Node", select_overload<void(p.q(const).char, r.q(const).btVector3, r.q(const).btVector4, p.btSoftBody::Node, p.btSoftBody::Node, p.btSoftBody::Node, p.btSoftBody::Node)>(&btSoftBody::appendNote))
	.function("appendNote_p.q(const).char_r.q(const).btVector3_r.q(const).btVector4_p.btSoftBody::Node_p.btSoftBody::Node_p.btSoftBody::Node", select_overload<void(p.q(const).char, r.q(const).btVector3, r.q(const).btVector4, p.btSoftBody::Node, p.btSoftBody::Node, p.btSoftBody::Node)>(&btSoftBody::appendNote))
	.function("appendNote_p.q(const).char_r.q(const).btVector3_r.q(const).btVector4_p.btSoftBody::Node_p.btSoftBody::Node", select_overload<void(p.q(const).char, r.q(const).btVector3, r.q(const).btVector4, p.btSoftBody::Node, p.btSoftBody::Node)>(&btSoftBody::appendNote))
	.function("appendNote_p.q(const).char_r.q(const).btVector3_r.q(const).btVector4_p.btSoftBody::Node", select_overload<void(p.q(const).char, r.q(const).btVector3, r.q(const).btVector4, p.btSoftBody::Node)>(&btSoftBody::appendNote))
	.function("appendNote_p.q(const).char_r.q(const).btVector3_r.q(const).btVector4", select_overload<void(p.q(const).char, r.q(const).btVector3, r.q(const).btVector4)>(&btSoftBody::appendNote))
	.function("appendNote_p.q(const).char_r.q(const).btVector3", select_overload<void(p.q(const).char, r.q(const).btVector3)>(&btSoftBody::appendNote))
	.function("appendNote_p.q(const).char_r.q(const).btVector3_p.btSoftBody::Node", select_overload<void(p.q(const).char, r.q(const).btVector3, p.btSoftBody::Node)>(&btSoftBody::appendNote))
	.function("appendNote_p.q(const).char_r.q(const).btVector3_p.btSoftBody::Link", select_overload<void(p.q(const).char, r.q(const).btVector3, p.btSoftBody::Link)>(&btSoftBody::appendNote))
	.function("appendNote_p.q(const).char_r.q(const).btVector3_p.btSoftBody::Face", select_overload<void(p.q(const).char, r.q(const).btVector3, p.btSoftBody::Face)>(&btSoftBody::appendNote))
	.function("appendNode", &btSoftBody::appendNode)
	.function("appendLink_int_p.btSoftBody::Material", select_overload<void(int, p.btSoftBody::Material)>(&btSoftBody::appendLink))
	.function("appendLink_int", select_overload<void(int)>(&btSoftBody::appendLink))
	.function("appendLink", select_overload<void()>(&btSoftBody::appendLink))
	.function("appendLink_int_int_p.btSoftBody::Material_bool", select_overload<void(int, int, p.btSoftBody::Material, bool)>(&btSoftBody::appendLink))
	.function("appendLink_int_int_p.btSoftBody::Material", select_overload<void(int, int, p.btSoftBody::Material)>(&btSoftBody::appendLink))
	.function("appendLink_int_int", select_overload<void(int, int)>(&btSoftBody::appendLink))
	.function("appendLink_p.btSoftBody::Node_p.btSoftBody::Node_p.btSoftBody::Material_bool", select_overload<void(p.btSoftBody::Node, p.btSoftBody::Node, p.btSoftBody::Material, bool)>(&btSoftBody::appendLink))
	.function("appendLink_p.btSoftBody::Node_p.btSoftBody::Node_p.btSoftBody::Material", select_overload<void(p.btSoftBody::Node, p.btSoftBody::Node, p.btSoftBody::Material)>(&btSoftBody::appendLink))
	.function("appendLink_p.btSoftBody::Node_p.btSoftBody::Node", select_overload<void(p.btSoftBody::Node, p.btSoftBody::Node)>(&btSoftBody::appendLink))
	.function("appendFace_int_p.btSoftBody::Material", select_overload<void(int, p.btSoftBody::Material)>(&btSoftBody::appendFace))
	.function("appendFace_int", select_overload<void(int)>(&btSoftBody::appendFace))
	.function("appendFace", select_overload<void()>(&btSoftBody::appendFace))
	.function("appendFace_int_int_int_p.btSoftBody::Material", select_overload<void(int, int, int, p.btSoftBody::Material)>(&btSoftBody::appendFace))
	.function("appendFace_int_int_int", select_overload<void(int, int, int)>(&btSoftBody::appendFace))
	.function("appendTetra_int_p.btSoftBody::Material", select_overload<void(int, p.btSoftBody::Material)>(&btSoftBody::appendTetra))
	.function("appendTetra_int_int_int_int_p.btSoftBody::Material", select_overload<void(int, int, int, int, p.btSoftBody::Material)>(&btSoftBody::appendTetra))
	.function("appendTetra_int_int_int_int", select_overload<void(int, int, int, int)>(&btSoftBody::appendTetra))
	.function("appendAnchor_int_p.btRigidBody_bool_btScalar", select_overload<void(int, p.btRigidBody, bool, btScalar)>(&btSoftBody::appendAnchor))
	.function("appendAnchor_int_p.btRigidBody_bool", select_overload<void(int, p.btRigidBody, bool)>(&btSoftBody::appendAnchor))
	.function("appendAnchor_int_p.btRigidBody", select_overload<void(int, p.btRigidBody)>(&btSoftBody::appendAnchor))
	.function("appendAnchor_int_p.btRigidBody_r.q(const).btVector3_bool_btScalar", select_overload<void(int, p.btRigidBody, r.q(const).btVector3, bool, btScalar)>(&btSoftBody::appendAnchor))
	.function("appendAnchor_int_p.btRigidBody_r.q(const).btVector3_bool", select_overload<void(int, p.btRigidBody, r.q(const).btVector3, bool)>(&btSoftBody::appendAnchor))
	.function("appendAnchor_int_p.btRigidBody_r.q(const).btVector3", select_overload<void(int, p.btRigidBody, r.q(const).btVector3)>(&btSoftBody::appendAnchor))
	.function("appendLinearJoint_r.q(const).btSoftBody::LJoint::Specs_p.btSoftBody::Cluster_btSoftBody::Body", select_overload<void(r.q(const).btSoftBody::LJoint::Specs, p.btSoftBody::Cluster, btSoftBody::Body)>(&btSoftBody::appendLinearJoint))
	.function("appendLinearJoint_r.q(const).btSoftBody::LJoint::Specs_btSoftBody::Body", select_overload<void(r.q(const).btSoftBody::LJoint::Specs, btSoftBody::Body)>(&btSoftBody::appendLinearJoint))
	.function("appendLinearJoint_r.q(const).btSoftBody::LJoint::Specs", select_overload<void(r.q(const).btSoftBody::LJoint::Specs)>(&btSoftBody::appendLinearJoint))
	.function("appendLinearJoint_r.q(const).btSoftBody::LJoint::Specs_p.btSoftBody", select_overload<void(r.q(const).btSoftBody::LJoint::Specs, p.btSoftBody)>(&btSoftBody::appendLinearJoint))
	.function("appendAngularJoint_r.q(const).btSoftBody::AJoint::Specs_p.btSoftBody::Cluster_btSoftBody::Body", select_overload<void(r.q(const).btSoftBody::AJoint::Specs, p.btSoftBody::Cluster, btSoftBody::Body)>(&btSoftBody::appendAngularJoint))
	.function("appendAngularJoint_r.q(const).btSoftBody::AJoint::Specs_btSoftBody::Body", select_overload<void(r.q(const).btSoftBody::AJoint::Specs, btSoftBody::Body)>(&btSoftBody::appendAngularJoint))
	.function("appendAngularJoint_r.q(const).btSoftBody::AJoint::Specs", select_overload<void(r.q(const).btSoftBody::AJoint::Specs)>(&btSoftBody::appendAngularJoint))
	.function("appendAngularJoint_r.q(const).btSoftBody::AJoint::Specs_p.btSoftBody", select_overload<void(r.q(const).btSoftBody::AJoint::Specs, p.btSoftBody)>(&btSoftBody::appendAngularJoint))
	.function("addForce_r.q(const).btVector3", select_overload<void(r.q(const).btVector3)>(&btSoftBody::addForce))
	.function("addForce_r.q(const).btVector3_int", select_overload<void(r.q(const).btVector3, int)>(&btSoftBody::addForce))
	.function("addAeroForceToNode", &btSoftBody::addAeroForceToNode)
	.function("addAeroForceToFace", &btSoftBody::addAeroForceToFace)
	.function("addVelocity_r.q(const).btVector3", select_overload<void(r.q(const).btVector3)>(&btSoftBody::addVelocity))
	.function("setVelocity", &btSoftBody::setVelocity)
	.function("addVelocity_r.q(const).btVector3_int", select_overload<void(r.q(const).btVector3, int)>(&btSoftBody::addVelocity))
	.function("setMass", &btSoftBody::setMass)
	.function("getMass", &btSoftBody::getMass)
	.function("getTotalMass", &btSoftBody::getTotalMass)
	.function("setTotalMass_btScalar_bool", select_overload<void(btScalar, bool)>(&btSoftBody::setTotalMass))
	.function("setTotalMass_btScalar", select_overload<void(btScalar)>(&btSoftBody::setTotalMass))
	.function("setTotalDensity", &btSoftBody::setTotalDensity)
	.function("setVolumeMass", &btSoftBody::setVolumeMass)
	.function("setVolumeDensity", &btSoftBody::setVolumeDensity)
	.function("transform", &btSoftBody::transform)
	.function("translate", &btSoftBody::translate)
	.function("rotate", &btSoftBody::rotate)
	.function("scale", &btSoftBody::scale)
	.function("getRestLengthScale", &btSoftBody::getRestLengthScale)
	.function("setRestLengthScale", &btSoftBody::setRestLengthScale)
	.function("setPose", &btSoftBody::setPose)
	.function("resetLinkRestLengths", &btSoftBody::resetLinkRestLengths)
	.function("getVolume", &btSoftBody::getVolume)
	.function("clusterCount", &btSoftBody::clusterCount)
	.class_function("clusterCom", &btSoftBody::clusterCom)
	.function("clusterCom_int", select_overload<btVector3(int)const>(&btSoftBody::clusterCom))
	.class_function("clusterVelocity", &btSoftBody::clusterVelocity)
	.class_function("clusterVImpulse", &btSoftBody::clusterVImpulse)
	.class_function("clusterDImpulse", &btSoftBody::clusterDImpulse)
	.class_function("clusterImpulse", &btSoftBody::clusterImpulse)
	.class_function("clusterVAImpulse", &btSoftBody::clusterVAImpulse)
	.class_function("clusterDAImpulse", &btSoftBody::clusterDAImpulse)
	.class_function("clusterAImpulse", &btSoftBody::clusterAImpulse)
	.class_function("clusterDCImpulse", &btSoftBody::clusterDCImpulse)
	.function("generateBendingConstraints_int_p.btSoftBody::Material", select_overload<int(int, p.btSoftBody::Material)>(&btSoftBody::generateBendingConstraints))
	.function("generateBendingConstraints_int", select_overload<int(int)>(&btSoftBody::generateBendingConstraints))
	.function("randomizeConstraints", &btSoftBody::randomizeConstraints)
	.function("releaseCluster", &btSoftBody::releaseCluster)
	.function("releaseClusters", &btSoftBody::releaseClusters)
	.function("generateClusters_int_int", select_overload<int(int, int)>(&btSoftBody::generateClusters))
	.function("generateClusters_int", select_overload<int(int)>(&btSoftBody::generateClusters))
	.function("refine", &btSoftBody::refine)
	.function("cutLink_int_int_btScalar", select_overload<bool(int, int, btScalar)>(&btSoftBody::cutLink))
	.function("cutLink_p.q(const).btSoftBody::Node_p.q(const).btSoftBody::Node_btScalar", select_overload<bool(p.q(const).btSoftBody::Node, p.q(const).btSoftBody::Node, btScalar)>(&btSoftBody::cutLink))
	.function("rayTest_r.q(const).btVector3_r.q(const).btVector3_r.btSoftBody::sRayCast", select_overload<bool(r.q(const).btVector3, r.q(const).btVector3, r.btSoftBody::sRayCast)>(&btSoftBody::rayTest))
	.function("setSolver", &btSoftBody::setSolver)
	.function("predictMotion", &btSoftBody::predictMotion)
	.function("solveConstraints", &btSoftBody::solveConstraints)
	.function("staticSolve", &btSoftBody::staticSolve)
	.class_function("solveCommonConstraints", &btSoftBody::solveCommonConstraints)
	.class_function("solveClusters", &btSoftBody::solveClusters)
	.function("integrateMotion", &btSoftBody::integrateMotion)
	.function("defaultCollisionHandler_p.q(const).btCollisionObjectWrapper", select_overload<void(p.q(const).btCollisionObjectWrapper)>(&btSoftBody::defaultCollisionHandler))
	.function("defaultCollisionHandler_p.btSoftBody", select_overload<void(p.btSoftBody)>(&btSoftBody::defaultCollisionHandler))
	.function("setWindVelocity", &btSoftBody::setWindVelocity)
	.function("getWindVelocity", &btSoftBody::getWindVelocity)
	.function("setSoftBodySolver", &btSoftBody::setSoftBodySolver)
	.function("getSoftBodySolver", select_overload<btSoftBodySolver()>(&btSoftBody::getSoftBodySolver))
	.function("getSoftBodySolver", select_overload<btSoftBodySolver()const>(&btSoftBody::getSoftBodySolver))
	.class_function("upcast", &btSoftBody::upcast)
	.class_function("upcast", &btSoftBody::upcast)
	.function("getAabb", &btSoftBody::getAabb)
	.function("pointersToIndices", &btSoftBody::pointersToIndices)
	.function("indicesToPointers_p.q(const).int", select_overload<void(p.q(const).int)>(&btSoftBody::indicesToPointers))
	.function("indicesToPointers", select_overload<void()>(&btSoftBody::indicesToPointers))
	.function("rayTest_r.q(const).btVector3_r.q(const).btVector3_r.btScalar_r.btSoftBody::eFeature::__r.int_bool", select_overload<int(r.q(const).btVector3, r.q(const).btVector3, r.btScalar, r.btSoftBody::eFeature::_, r.int, bool)const>(&btSoftBody::rayTest))
	.function("initializeFaceTree", &btSoftBody::initializeFaceTree)
	.function("evaluateCom", &btSoftBody::evaluateCom)
	.function("checkContact", &btSoftBody::checkContact)
	.function("updateNormals", &btSoftBody::updateNormals)
	.function("updateBounds", &btSoftBody::updateBounds)
	.function("updatePose", &btSoftBody::updatePose)
	.function("updateConstants", &btSoftBody::updateConstants)
	.function("updateLinkConstants", &btSoftBody::updateLinkConstants)
	.function("updateArea_bool", select_overload<void(bool)>(&btSoftBody::updateArea))
	.function("updateArea", select_overload<void()>(&btSoftBody::updateArea))
	.function("initializeClusters", &btSoftBody::initializeClusters)
	.function("updateClusters", &btSoftBody::updateClusters)
	.function("cleanupClusters", &btSoftBody::cleanupClusters)
	.function("prepareClusters", &btSoftBody::prepareClusters)
	.function("solveClusters_btScalar", select_overload<void(btScalar)>(&btSoftBody::solveClusters))
	.function("applyClusters", &btSoftBody::applyClusters)
	.function("dampClusters", &btSoftBody::dampClusters)
	.function("applyForces", &btSoftBody::applyForces)
	.class_function("PSolve_Anchors", &btSoftBody::PSolve_Anchors)
	.class_function("PSolve_RContacts", &btSoftBody::PSolve_RContacts)
	.class_function("PSolve_SContacts", &btSoftBody::PSolve_SContacts)
	.class_function("PSolve_Links", &btSoftBody::PSolve_Links)
	.class_function("VSolve_Links", &btSoftBody::VSolve_Links)
	.class_function("getSolver", &btSoftBody::getSolver)
	.class_function("getSolver", &btSoftBody::getSolver)
	;
	class_<btTriIndex>("btTriIndex")
	constant("m_PartIdTriangleIndex", m_PartIdTriangleIndex);
	constant("m_childShape", m_childShape);
	.constructor<int,int,p.btCollisionShape>()
	.function("getTriangleIndex", &btTriIndex::getTriangleIndex)
	.function("getPartId", &btTriIndex::getPartId)
	.function("getUid", &btTriIndex::getUid)
	;
	class_<btSoftBodyTriangleCallback, base<btTriangleCallback>>("btSoftBodyTriangleCallback")
	.constructor<p.btDispatcher,p.q(const).btCollisionObjectWrapper,p.q(const).btCollisionObjectWrapper,bool>()
	.function("setTimeStepAndCounters", &btSoftBodyTriangleCallback::setTimeStepAndCounters)
	.function("clearCache", &btSoftBodyTriangleCallback::clearCache)
	.function("getAabbMin", &btSoftBodyTriangleCallback::getAabbMin)
	.function("getAabbMax", &btSoftBodyTriangleCallback::getAabbMax)
	;
	class_<btSoftBodyConcaveCollisionAlgorithm, base<btCollisionAlgorithm>>("btSoftBodyConcaveCollisionAlgorithm")
	.constructor<r.q(const).btCollisionAlgorithmConstructionInfo,p.q(const).btCollisionObjectWrapper,p.q(const).btCollisionObjectWrapper,bool>()
	.function("clearCache", &btSoftBodyConcaveCollisionAlgorithm::clearCache)
	;
	class_<SoftBodyMaterialData>("SoftBodyMaterialData")
	constant("m_linearStiffness", m_linearStiffness);
	constant("m_angularStiffness", m_angularStiffness);
	constant("m_volumeStiffness", m_volumeStiffness);
	constant("m_flags", m_flags);
	;
	class_<SoftBodyNodeData>("SoftBodyNodeData")
	constant("m_material", m_material);
	constant("m_position", m_position);
	constant("m_previousPosition", m_previousPosition);
	constant("m_velocity", m_velocity);
	constant("m_accumulatedForce", m_accumulatedForce);
	constant("m_normal", m_normal);
	constant("m_inverseMass", m_inverseMass);
	constant("m_area", m_area);
	constant("m_attach", m_attach);
	constant("m_pad", m_pad);
	;
	class_<SoftBodyLinkData>("SoftBodyLinkData")
	constant("m_material", m_material);
	constant("m_nodeIndices", m_nodeIndices);
	constant("m_restLength", m_restLength);
	constant("m_bbending", m_bbending);
	;
	class_<SoftBodyFaceData>("SoftBodyFaceData")
	constant("m_normal", m_normal);
	constant("m_material", m_material);
	constant("m_nodeIndices", m_nodeIndices);
	constant("m_restArea", m_restArea);
	;
	class_<SoftBodyTetraData>("SoftBodyTetraData")
	constant("m_c0", m_c0);
	constant("m_material", m_material);
	constant("m_nodeIndices", m_nodeIndices);
	constant("m_restVolume", m_restVolume);
	constant("m_c1", m_c1);
	constant("m_c2", m_c2);
	constant("m_pad", m_pad);
	;
	class_<SoftRigidAnchorData>("SoftRigidAnchorData")
	constant("m_c0", m_c0);
	constant("m_c1", m_c1);
	constant("m_localFrame", m_localFrame);
	constant("m_rigidBody", m_rigidBody);
	constant("m_nodeIndex", m_nodeIndex);
	constant("m_c2", m_c2);
	;
	class_<SoftBodyConfigData>("SoftBodyConfigData")
	constant("m_aeroModel", m_aeroModel);
	constant("m_baumgarte", m_baumgarte);
	constant("m_damping", m_damping);
	constant("m_drag", m_drag);
	constant("m_lift", m_lift);
	constant("m_pressure", m_pressure);
	constant("m_volume", m_volume);
	constant("m_dynamicFriction", m_dynamicFriction);
	constant("m_poseMatch", m_poseMatch);
	constant("m_rigidContactHardness", m_rigidContactHardness);
	constant("m_kineticContactHardness", m_kineticContactHardness);
	constant("m_softContactHardness", m_softContactHardness);
	constant("m_anchorHardness", m_anchorHardness);
	constant("m_softRigidClusterHardness", m_softRigidClusterHardness);
	constant("m_softKineticClusterHardness", m_softKineticClusterHardness);
	constant("m_softSoftClusterHardness", m_softSoftClusterHardness);
	constant("m_softRigidClusterImpulseSplit", m_softRigidClusterImpulseSplit);
	constant("m_softKineticClusterImpulseSplit", m_softKineticClusterImpulseSplit);
	constant("m_softSoftClusterImpulseSplit", m_softSoftClusterImpulseSplit);
	constant("m_maxVolume", m_maxVolume);
	constant("m_timeScale", m_timeScale);
	constant("m_velocityIterations", m_velocityIterations);
	constant("m_positionIterations", m_positionIterations);
	constant("m_driftIterations", m_driftIterations);
	constant("m_clusterIterations", m_clusterIterations);
	constant("m_collisionFlags", m_collisionFlags);
	;
	class_<SoftBodyPoseData>("SoftBodyPoseData")
	constant("m_rot", m_rot);
	constant("m_scale", m_scale);
	constant("m_aqq", m_aqq);
	constant("m_com", m_com);
	constant("m_positions", m_positions);
	constant("m_weights", m_weights);
	constant("m_numPositions", m_numPositions);
	constant("m_numWeigts", m_numWeigts);
	constant("m_bvolume", m_bvolume);
	constant("m_bframe", m_bframe);
	constant("m_restVolume", m_restVolume);
	constant("m_pad", m_pad);
	;
	class_<SoftBodyClusterData>("SoftBodyClusterData")
	constant("m_framexform", m_framexform);
	constant("m_locii", m_locii);
	constant("m_invwi", m_invwi);
	constant("m_com", m_com);
	constant("m_vimpulses", m_vimpulses);
	constant("m_dimpulses", m_dimpulses);
	constant("m_lv", m_lv);
	constant("m_av", m_av);
	constant("m_framerefs", m_framerefs);
	constant("m_nodeIndices", m_nodeIndices);
	constant("m_masses", m_masses);
	constant("m_numFrameRefs", m_numFrameRefs);
	constant("m_numNodes", m_numNodes);
	constant("m_numMasses", m_numMasses);
	constant("m_idmass", m_idmass);
	constant("m_imass", m_imass);
	constant("m_nvimpulses", m_nvimpulses);
	constant("m_ndimpulses", m_ndimpulses);
	constant("m_ndamping", m_ndamping);
	constant("m_ldamping", m_ldamping);
	constant("m_adamping", m_adamping);
	constant("m_matching", m_matching);
	constant("m_maxSelfCollisionImpulse", m_maxSelfCollisionImpulse);
	constant("m_selfCollisionImpulseFactor", m_selfCollisionImpulseFactor);
	constant("m_containsAnchor", m_containsAnchor);
	constant("m_collide", m_collide);
	constant("m_clusterIndex", m_clusterIndex);
	;
	enum_<btSoftJointBodyType>("btSoftJointBodyType")
		.value("BT_JOINT_SOFT_BODY_CLUSTER", BT_JOINT_SOFT_BODY_CLUSTER)
		.value("BT_JOINT_RIGID_BODY", BT_JOINT_RIGID_BODY)
		.value("BT_JOINT_COLLISION_OBJECT", BT_JOINT_COLLISION_OBJECT)
		;
	class_<btSoftBodyJointData>("btSoftBodyJointData")
	constant("m_bodyA", m_bodyA);
	constant("m_bodyB", m_bodyB);
	constant("m_refs", m_refs);
	constant("m_cfm", m_cfm);
	constant("m_erp", m_erp);
	constant("m_split", m_split);
	constant("m_delete", m_delete);
	constant("m_relPosition", m_relPosition);
	constant("m_bodyAtype", m_bodyAtype);
	constant("m_bodyBtype", m_bodyBtype);
	constant("m_jointType", m_jointType);
	constant("m_pad", m_pad);
	;
	class_<btSoftBodyFloatData>("btSoftBodyFloatData")
	constant("m_collisionObjectData", m_collisionObjectData);
	constant("m_pose", m_pose);
	constant("m_materials", m_materials);
	constant("m_nodes", m_nodes);
	constant("m_links", m_links);
	constant("m_faces", m_faces);
	constant("m_tetrahedra", m_tetrahedra);
	constant("m_anchors", m_anchors);
	constant("m_clusters", m_clusters);
	constant("m_joints", m_joints);
	constant("m_numMaterials", m_numMaterials);
	constant("m_numNodes", m_numNodes);
	constant("m_numLinks", m_numLinks);
	constant("m_numFaces", m_numFaces);
	constant("m_numTetrahedra", m_numTetrahedra);
	constant("m_numAnchors", m_numAnchors);
	constant("m_numClusters", m_numClusters);
	constant("m_numJoints", m_numJoints);
	constant("m_config", m_config);
	;
	class_<fDrawFlags>("fDrawFlags")
	enum_<fDrawFlags::_>("fDrawFlags::_")
		.value("Nodes", fDrawFlags::Nodes)
		.value("Links", fDrawFlags::Links)
		.value("Faces", fDrawFlags::Faces)
		.value("Tetras", fDrawFlags::Tetras)
		.value("Normals", fDrawFlags::Normals)
		.value("Contacts", fDrawFlags::Contacts)
		.value("Anchors", fDrawFlags::Anchors)
		.value("Notes", fDrawFlags::Notes)
		.value("Clusters", fDrawFlags::Clusters)
		.value("NodeTree", fDrawFlags::NodeTree)
		.value("FaceTree", fDrawFlags::FaceTree)
		.value("ClusterTree", fDrawFlags::ClusterTree)
		.value("Joints", fDrawFlags::Joints)
		.value("Std", fDrawFlags::Std)
		.value("StdTetra", fDrawFlags::StdTetra)
		;
	;
	class_<btSoftBodyHelpers>("btSoftBodyHelpers")
	.class_function("Draw", &btSoftBodyHelpers::Draw)
	.class_function("Draw", &btSoftBodyHelpers::Draw)
	.class_function("DrawInfos", &btSoftBodyHelpers::DrawInfos)
	.class_function("DrawNodeTree", &btSoftBodyHelpers::DrawNodeTree)
	.class_function("DrawNodeTree", &btSoftBodyHelpers::DrawNodeTree)
	.class_function("DrawNodeTree", &btSoftBodyHelpers::DrawNodeTree)
	.class_function("DrawFaceTree", &btSoftBodyHelpers::DrawFaceTree)
	.class_function("DrawFaceTree", &btSoftBodyHelpers::DrawFaceTree)
	.class_function("DrawFaceTree", &btSoftBodyHelpers::DrawFaceTree)
	.class_function("DrawClusterTree", &btSoftBodyHelpers::DrawClusterTree)
	.class_function("DrawClusterTree", &btSoftBodyHelpers::DrawClusterTree)
	.class_function("DrawClusterTree", &btSoftBodyHelpers::DrawClusterTree)
	.class_function("DrawFrame", &btSoftBodyHelpers::DrawFrame)
	.class_function("CreateRope", &btSoftBodyHelpers::CreateRope)
	.class_function("CreatePatch", &btSoftBodyHelpers::CreatePatch)
	.class_function("CreatePatchUV", &btSoftBodyHelpers::CreatePatchUV)
	.class_function("CreatePatchUV", &btSoftBodyHelpers::CreatePatchUV)
	.class_function("CalculateUV", &btSoftBodyHelpers::CalculateUV)
	.class_function("CreateEllipsoid", &btSoftBodyHelpers::CreateEllipsoid)
	.class_function("CreateFromTriMesh", &btSoftBodyHelpers::CreateFromTriMesh)
	.class_function("CreateFromTriMesh", &btSoftBodyHelpers::CreateFromTriMesh)
	.class_function("CreateFromConvexHull", &btSoftBodyHelpers::CreateFromConvexHull)
	.class_function("CreateFromConvexHull", &btSoftBodyHelpers::CreateFromConvexHull)
	.class_function("CreateFromTetGenData", &btSoftBodyHelpers::CreateFromTetGenData)
	.class_function("ReoptimizeLinkOrder", &btSoftBodyHelpers::ReoptimizeLinkOrder)
	;
	class_<btPolarDecomposition>("btPolarDecomposition")
	.constructor<btScalar,unsigned int>()
	.constructor<btScalar>()
	.function("decompose", &btPolarDecomposition::decompose)
	.function("maxIterations", &btPolarDecomposition::maxIterations)
	;
	function("polarDecompose", &polarDecompose);
	class_<btSoftBodyCollisionShape, base<btConcaveShape>>("btSoftBodyCollisionShape")
	.constructor<p.btSoftBody>()
	;
	class_<btSoftClusterCollisionShape, base<btConvexInternalShape>>("btSoftClusterCollisionShape")
	.constructor<p.q(const).btSoftBody::Cluster>()
	.function("getShapeType", &btSoftClusterCollisionShape::getShapeType)
	;
	.class_function("Lerp", &btSoftClusterCollisionShape::Lerp)
	function("Lerp", &Lerp);
	.class_function("Clamp", &btSoftClusterCollisionShape::Clamp)
	function("Clamp", &Clamp);
	.class_function("ClusterMetric", &btSoftClusterCollisionShape::ClusterMetric)
	function("ClusterMetric", &ClusterMetric);
	.class_function("ScaleAlongAxis", &btSoftClusterCollisionShape::ScaleAlongAxis)
	function("ScaleAlongAxis", &ScaleAlongAxis);
	.class_function("Cross", &btSoftClusterCollisionShape::Cross)
	function("Cross", &Cross);
	.class_function("Diagonal", &btSoftClusterCollisionShape::Diagonal)
	function("Diagonal", &Diagonal);
	.class_function("Add", &btSoftClusterCollisionShape::Add)
	function("Add", &Add);
	.class_function("Sub", &btSoftClusterCollisionShape::Sub)
	function("Sub", &Sub);
	.class_function("Mul", &btSoftClusterCollisionShape::Mul)
	function("Mul", &Mul);
	.class_function("Orthogonalize", &btSoftClusterCollisionShape::Orthogonalize)
	function("Orthogonalize", &Orthogonalize);
	.class_function("MassMatrix", &btSoftClusterCollisionShape::MassMatrix)
	function("MassMatrix", &MassMatrix);
	.class_function("ImpulseMatrix", &btSoftClusterCollisionShape::ImpulseMatrix)
	function("ImpulseMatrix", &ImpulseMatrix);
	.class_function("ImpulseMatrix", &btSoftClusterCollisionShape::ImpulseMatrix)
	function("ImpulseMatrix", &ImpulseMatrix);
	.class_function("AngularImpulseMatrix", &btSoftClusterCollisionShape::AngularImpulseMatrix)
	function("AngularImpulseMatrix", &AngularImpulseMatrix);
	.class_function("ProjectOnAxis", &btSoftClusterCollisionShape::ProjectOnAxis)
	function("ProjectOnAxis", &ProjectOnAxis);
	.class_function("ProjectOnPlane", &btSoftClusterCollisionShape::ProjectOnPlane)
	function("ProjectOnPlane", &ProjectOnPlane);
	.class_function("ProjectOrigin", &btSoftClusterCollisionShape::ProjectOrigin)
	function("ProjectOrigin", &ProjectOrigin);
	.class_function("ProjectOrigin", &btSoftClusterCollisionShape::ProjectOrigin)
	function("ProjectOrigin", &ProjectOrigin);
	.class_function("BaryCoord", &btSoftClusterCollisionShape::BaryCoord)
	function("BaryCoord", &BaryCoord);
	.class_function("ImplicitSolve", &btSoftClusterCollisionShape::ImplicitSolve)
	function("ImplicitSolve", &ImplicitSolve);
	.class_function("ImplicitSolve", &btSoftClusterCollisionShape::ImplicitSolve)
	function("ImplicitSolve", &ImplicitSolve);
	.class_function("EvaluateMedium", &btSoftClusterCollisionShape::EvaluateMedium)
	function("EvaluateMedium", &EvaluateMedium);
	.class_function("NormalizeAny", &btSoftClusterCollisionShape::NormalizeAny)
	function("NormalizeAny", &NormalizeAny);
	.class_function("VolumeOf", &btSoftClusterCollisionShape::VolumeOf)
	function("VolumeOf", &VolumeOf);
	.class_function("CenterOf", &btSoftClusterCollisionShape::CenterOf)
	function("CenterOf", &CenterOf);
	.class_function("AreaOf", &btSoftClusterCollisionShape::AreaOf)
	function("AreaOf", &AreaOf);
	.class_function("VolumeOf", &btSoftClusterCollisionShape::VolumeOf)
	function("VolumeOf", &VolumeOf);
	.class_function("ApplyClampedForce", &btSoftClusterCollisionShape::ApplyClampedForce)
	function("ApplyClampedForce", &ApplyClampedForce);
	.class_function("MatchEdge", &btSoftClusterCollisionShape::MatchEdge)
	function("MatchEdge", &MatchEdge);
	class_<btEigen>("btEigen")
	.class_function("system", &btEigen::system)
	.class_function("system", &btEigen::system)
	.class_function("mulTPQ", &btEigen::mulTPQ)
	.class_function("mulPQ", &btEigen::mulPQ)
	;
	.class_function("PolarDecompose", &btEigen::PolarDecompose)
	function("PolarDecompose", &PolarDecompose);
	class_<btSoftColliders>("btSoftColliders")
	;
	class_<btSoftBodyRigidBodyCollisionConfiguration, base<btDefaultCollisionConfiguration>>("btSoftBodyRigidBodyCollisionConfiguration")
	.constructor<r.q(const).btDefaultCollisionConstructionInfo>()
	;
	class_<btSoftRigidCollisionAlgorithm, base<btCollisionAlgorithm>>("btSoftRigidCollisionAlgorithm")
	.constructor<p.btPersistentManifold,r.q(const).btCollisionAlgorithmConstructionInfo,p.q(const).btCollisionObjectWrapper,p.q(const).btCollisionObjectWrapper,bool>()
	;
	class_<btSoftRigidDynamicsWorld, base<btDiscreteDynamicsWorld>>("btSoftRigidDynamicsWorld")
	.function("predictUnconstraintMotion", &btSoftRigidDynamicsWorld::predictUnconstraintMotion)
	.function("internalSingleStepSimulation", &btSoftRigidDynamicsWorld::internalSingleStepSimulation)
	.function("solveSoftBodiesConstraints", &btSoftRigidDynamicsWorld::solveSoftBodiesConstraints)
	.function("serializeSoftBodies", &btSoftRigidDynamicsWorld::serializeSoftBodies)
	.constructor<p.btDispatcher,p.btBroadphaseInterface,p.btConstraintSolver,p.btCollisionConfiguration,p.btSoftBodySolver>()
	.constructor<p.btDispatcher,p.btBroadphaseInterface,p.btConstraintSolver,p.btCollisionConfiguration>()
	.function("addSoftBody_p.btSoftBody_int_int", select_overload<void(p.btSoftBody, int, int)>(&btSoftRigidDynamicsWorld::addSoftBody))
	.function("addSoftBody_p.btSoftBody_int", select_overload<void(p.btSoftBody, int)>(&btSoftRigidDynamicsWorld::addSoftBody))
	.function("addSoftBody_p.btSoftBody", select_overload<void(p.btSoftBody)>(&btSoftRigidDynamicsWorld::addSoftBody))
	.function("removeSoftBody", &btSoftRigidDynamicsWorld::removeSoftBody)
	.function("getDrawFlags", &btSoftRigidDynamicsWorld::getDrawFlags)
	.function("setDrawFlags", &btSoftRigidDynamicsWorld::setDrawFlags)
	.function("getWorldInfo", select_overload<btSoftBodyWorldInfo()>(&btSoftRigidDynamicsWorld::getWorldInfo))
	.function("getWorldInfo", select_overload<q(const).btSoftBodyWorldInfo()const>(&btSoftRigidDynamicsWorld::getWorldInfo))
	.function("getSoftBodyArray", select_overload<btSoftBodyArray()>(&btSoftRigidDynamicsWorld::getSoftBodyArray))
	.function("getSoftBodyArray", select_overload<q(const).btSoftBodyArray()const>(&btSoftRigidDynamicsWorld::getSoftBodyArray))
	.class_function("rayTestSingle", &btSoftRigidDynamicsWorld::rayTestSingle)
	;
	class_<btSoftSoftCollisionAlgorithm, base<btCollisionAlgorithm>>("btSoftSoftCollisionAlgorithm")
	.constructor<r.q(const).btCollisionAlgorithmConstructionInfo>()
	.constructor<p.btPersistentManifold,r.q(const).btCollisionAlgorithmConstructionInfo,p.q(const).btCollisionObjectWrapper,p.q(const).btCollisionObjectWrapper>()
	;
	class_<HullResult>("HullResult")
	;
	enum_<HullFlag>("HullFlag")
		.value("QF_TRIANGLES", QF_TRIANGLES)
		.value("QF_REVERSE_ORDER", QF_REVERSE_ORDER)
		.value("QF_DEFAULT", QF_DEFAULT)
		;
	class_<HullDesc>("HullDesc")
	.constructor<HullFlag,unsigned int,p.q(const).btVector3,unsigned int>()
	.constructor<HullFlag,unsigned int,p.q(const).btVector3>()
	.function("HasHullFlag", &HullDesc::HasHullFlag)
	.function("SetHullFlag", &HullDesc::SetHullFlag)
	.function("ClearHullFlag", &HullDesc::ClearHullFlag)
	;
	enum_<HullError>("HullError")
		.value("QE_OK", QE_OK)
		.value("QE_FAIL", QE_FAIL)
		;
	class_<btPlane>("btPlane")
	.constructor<r.q(const).btVector3,btScalar>()
	;
	class_<ConvexH>("ConvexH")
	.constructor<int,int,int>()
	;
	class_<int4>("int4")
	.constructor<int,int,int,int>()
	;
	class_<PHullResult>("PHullResult")
	;
	class_<HullLibrary>("HullLibrary")
	.function("CreateConvexHull", &HullLibrary::CreateConvexHull)
	.function("ReleaseResult", &HullLibrary::ReleaseResult)
	.function("ComputeHull", &HullLibrary::ComputeHull)
	.function("allocateTriangle", &HullLibrary::allocateTriangle)
	.function("deAllocateTriangle", &HullLibrary::deAllocateTriangle)
	.function("b2bfix", &HullLibrary::b2bfix)
	.function("removeb2b", &HullLibrary::removeb2b)
	.function("checkit", &HullLibrary::checkit)
	.function("extrudable", &HullLibrary::extrudable)
	.function("calchull", &HullLibrary::calchull)
	.function("calchullgen", &HullLibrary::calchullgen)
	.function("FindSimplex", &HullLibrary::FindSimplex)
	.function("ConvexHCrop", &HullLibrary::ConvexHCrop)
	.function("extrude", &HullLibrary::extrude)
	.function("test_cube", &HullLibrary::test_cube)
	.function("BringOutYourDead", &HullLibrary::BringOutYourDead)
	.function("CleanupVertices", &HullLibrary::CleanupVertices)
	;
	class_<btConvexHullComputer>("btConvexHullComputer")
	.function("compute", &btConvexHullComputer::compute)
	.function("compute_p.q(const).float_int_int_btScalar_btScalar", select_overload<btScalar(p.q(const).float, int, int, btScalar, btScalar)>(&btConvexHullComputer::compute))
	.function("compute_p.q(const).double_int_int_btScalar_btScalar", select_overload<btScalar(p.q(const).double, int, int, btScalar, btScalar)>(&btConvexHullComputer::compute))
	;
	class_<btDefaultMotionState, base<btMotionState>>("btDefaultMotionState")
	constant("m_graphicsWorldTrans", m_graphicsWorldTrans);
	constant("m_centerOfMassOffset", m_centerOfMassOffset);
	constant("m_startWorldTrans", m_startWorldTrans);
	constant("m_userPointer", m_userPointer);
	.constructor<r.q(const).btTransform,r.q(const).btTransform>()
	.constructor<r.q(const).btTransform>()
	;
	class_<btGeometryUtil>("btGeometryUtil")
	.class_function("getPlaneEquationsFromVertices", &btGeometryUtil::getPlaneEquationsFromVertices)
	.class_function("getVerticesFromPlaneEquations", &btGeometryUtil::getVerticesFromPlaneEquations)
	.class_function("isPointInsidePlanes", &btGeometryUtil::isPointInsidePlanes)
	.class_function("areVerticesBehindPlane", &btGeometryUtil::areVerticesBehindPlane)
	;
	class_<GrahamVector3, base<btVector3>>("GrahamVector3")
	.constructor<r.q(const).btVector3,int>()
	constant("m_angle", m_angle);
	constant("m_orgIndex", m_orgIndex);
	;
	class_<btAngleCompareFunc>("btAngleCompareFunc")
	constant("m_anchor", m_anchor);
	.constructor<r.q(const).btVector3>()
	.function("operator ()", &btAngleCompareFunc::operator ())
	;
	function("GrahamScanConvexHull2D", &GrahamScanConvexHull2D);
	class_<btGEN_Link>("btGEN_Link")
	.constructor<p.btGEN_Link,p.btGEN_Link>()
	.function("getNext", &btGEN_Link::getNext)
	.function("getPrev", &btGEN_Link::getPrev)
	.function("isHead", &btGEN_Link::isHead)
	.function("isTail", &btGEN_Link::isTail)
	.function("insertBefore", &btGEN_Link::insertBefore)
	.function("insertAfter", &btGEN_Link::insertAfter)
	.function("remove", &btGEN_Link::remove)
	;
	class_<btGEN_List>("btGEN_List")
	.function("getHead", &btGEN_List::getHead)
	.function("getTail", &btGEN_List::getTail)
	.function("addHead", &btGEN_List::addHead)
	.function("addTail", &btGEN_List::addTail)
	;
	class_<btPoolAllocator>("btPoolAllocator")
	.constructor<int,int>()
	.function("getFreeCount", &btPoolAllocator::getFreeCount)
	.function("getUsedCount", &btPoolAllocator::getUsedCount)
	.function("getMaxCount", &btPoolAllocator::getMaxCount)
	.function("allocate", &btPoolAllocator::allocate)
	.function("validPtr", &btPoolAllocator::validPtr)
	.function("freeMemory", &btPoolAllocator::freeMemory)
	.function("getElementSize", &btPoolAllocator::getElementSize)
	.function("getPoolAddress", select_overload<unsigned char()>(&btPoolAllocator::getPoolAddress))
	.function("getPoolAddress", select_overload<q(const).unsigned char()const>(&btPoolAllocator::getPoolAddress))
	;
	function("GEN_srand", &GEN_srand);
	function("GEN_rand", &GEN_rand);
	class_<btBlock>("btBlock")
	constant("previous", previous);
	constant("address", address);
	;
	class_<btStackAlloc>("btStackAlloc")
	.constructor<unsigned int>()
	.function("create", &btStackAlloc::create)
	.function("destroy", &btStackAlloc::destroy)
	.function("getAvailableMemory", &btStackAlloc::getAvailableMemory)
	.function("allocate", &btStackAlloc::allocate)
	.function("beginBlock", &btStackAlloc::beginBlock)
	.function("endBlock", &btStackAlloc::endBlock)
	.function("ctor", &btStackAlloc::ctor)
	;
}

