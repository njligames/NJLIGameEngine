/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.11
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */
#include <emscripten/bind.h>
using namespace emscripten;


#ifndef SWIGEMBIND
#define SWIGEMBIND
#endif


#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if defined(__GNUC__)
#  if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#    ifndef GCC_HASCLASSVISIBILITY
#      define GCC_HASCLASSVISIBILITY
#    endif
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif

/* Deal with Apple's deprecated 'AssertMacros.h' from Carbon-framework */
#if defined(__APPLE__) && !defined(__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES)
# define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
#endif

/* Intel's compiler complains if a variable which was never initialised is
 * cast to void, which is a common idiom which we use to indicate that we
 * are aware a variable isn't used.  So we just silence that warning.
 * See: https://github.com/swig/swig/issues/192 for more discussion.
 */
#ifdef __INTEL_COMPILER
# pragma warning disable 592
#endif


#include "AbstractActionable.h"
#include "AbstractBuilder.h"
#include "AbstractClock.h"
#include "AbstractDecorator.h"
#include "AbstractFactoryObject.h"
#include "AbstractFrameBufferObject.h"
#include "AbstractObject.h"
#include "AbstractRender.h"
#include "AbstractState.h"
#include "AbstractStateMachine.h"
#include "AbstractTransform.h"
#include "Action.h"
#include "ActionBuilder.h"
#include "Camera.h"
#include "CameraBuilder.h"
#include "Clock.h"
#include "ClockBuilder.h"
#include "CollisionResponse.h"
#include "CollisionResponseBuilder.h"
#include "Cube.h"
#include "CubeBuilder.h"
#include "Font.h"
#include "FontBuilder.h"
//#include "GameClock.h"
#include "Geometry.h"
#include "Image.h"
#include "ImageBuilder.h"
//#include "JLIBuilders.h"
//#include "JLIEngine.h"
#include "JLIFactoryTypes.h"
//#include "JLITransform.h"
#include "JsonJLI.h"
#include "JsonJLIBuilder.h"
#include "LevelOfDetail.h"
#include "LevelOfDetailBuilder.h"
#include "Light.h"
#include "LightBuilder.h"
//#include "Lua.h"
//#include "LuaBuilder.h"
#include "Material.h"
#include "MaterialBuilder.h"
#include "MaterialProperty.h"
#include "MaterialPropertyBuilder.h"
#include "Node.h"
#include "NodeBuilder.h"
#include "NodeState.h"
#include "NodeStateBuilder.h"
#include "NodeStateMachine.h"
#include "NodeStateMachineBuilder.h"
#include "ParticleEmitter.h"
#include "ParticleEmitterBuilder.h"
#include "PhysicsBody.h"
#include "PhysicsBodyGhost.h"
#include "PhysicsBodyGhostBuilder.h"
#include "PhysicsBodyRigid.h"
#include "PhysicsBodyRigidBuilder.h"
#include "PhysicsBodySoft.h"
#include "PhysicsBodySoftBuilder.h"
#include "PhysicsCloseContact.h"
#include "PhysicsCloseContactBuilder.h"
#include "PhysicsConstraint.h"
#include "PhysicsConstraintBuilder.h"
#include "PhysicsConstraintConeTwist.h"
#include "PhysicsConstraintConeTwistBuilder.h"
#include "PhysicsConstraintFixed.h"
#include "PhysicsConstraintFixedBuilder.h"
#include "PhysicsConstraintGeneric6Dof.h"
#include "PhysicsConstraintGeneric6DofBuilder.h"
#include "PhysicsConstraintGeneric6DofSpring.h"
#include "PhysicsConstraintGeneric6DofSpringBuilder.h"
#include "PhysicsConstraintHinge.h"
#include "PhysicsConstraintHingeBuilder.h"
#include "PhysicsConstraintPointToPoint.h"
#include "PhysicsConstraintPointToPointBuilder.h"
#include "PhysicsConstraintSlider.h"
#include "PhysicsConstraintSliderBuilder.h"
#include "PhysicsContact.h"
#include "PhysicsContactBuilder.h"
#include "PhysicsField.h"
#include "PhysicsFieldBuilder.h"
#include "PhysicsRayContact.h"
#include "PhysicsRayContactBuilder.h"
#include "PhysicsShape.h"
#include "PhysicsShapeBox.h"
#include "PhysicsShapeBox2D.h"
#include "PhysicsShapeBox2DBuilder.h"
#include "PhysicsShapeBoxBuilder.h"
#include "PhysicsShapeBvhTriangleMesh.h"
#include "PhysicsShapeBvhTriangleMeshBuilder.h"
#include "PhysicsShapeCapsule.h"
#include "PhysicsShapeCapsuleBuilder.h"
#include "PhysicsShapeCone.h"
#include "PhysicsShapeConeBuilder.h"
#include "PhysicsShapeConvexHull.h"
#include "PhysicsShapeConvexHullBuilder.h"
#include "PhysicsShapeConvexTriangleMesh.h"
#include "PhysicsShapeConvexTriangleMeshBuilder.h"
#include "PhysicsShapeCylinder.h"
#include "PhysicsShapeCylinderBuilder.h"
#include "PhysicsShapeHeightfieldTerrain.h"
#include "PhysicsShapeHeightfieldTerrainBuilder.h"
#include "PhysicsShapeMultiSphere.h"
#include "PhysicsShapeMultiSphereBuilder.h"
#include "PhysicsShapeSphere.h"
#include "PhysicsShapeSphereBuilder.h"
#include "PhysicsShapeStaticPlane.h"
#include "PhysicsShapeStaticPlaneBuilder.h"
#include "PhysicsWorld.h"
#include "PhysicsWorldBuilder.h"
#include "Plane.h"
#include "PlaneBuilder.h"
#include "Scene.h"
#include "SceneBuilder.h"
#include "SceneState.h"
#include "SceneStateBuilder.h"
#include "SceneStateMachine.h"
#include "SceneStateMachineBuilder.h"
#include "ShaderProgram.h"
#include "ShaderProgramBuilder.h"
#include "Skinner.h"
#include "SkinnerBuilder.h"
#include "SoundBuilder.h"
#include "Sprite2D.h"
#include "Sprite2DBuilder.h"
#include "SpriteFrameAtlas.h"
#include "SpriteFrameAtlasBuilder.h"
#include "SteeringBehavior.h"
#include "SteeringBehaviorBuilder.h"
#include "SteeringBehaviorAlignment.h"
#include "SteeringBehaviorAlignmentBuilder.h"
#include "SteeringBehaviorArrive.h"
#include "SteeringBehaviorArriveBuilder.h"
#include "SteeringBehaviorCohesion.h"
#include "SteeringBehaviorCohesionBuilder.h"
#include "SteeringBehaviorEvade.h"
#include "SteeringBehaviorEvadeBuilder.h"
#include "SteeringBehaviorFlee.h"
#include "SteeringBehaviorFleeBuilder.h"
#include "SteeringBehaviorFollowPath.h"
#include "SteeringBehaviorFollowPathBuilder.h"
#include "SteeringBehaviorHide.h"
#include "SteeringBehaviorHideBuilder.h"
#include "SteeringBehaviorInterpose.h"
#include "SteeringBehaviorInterposeBuilder.h"
#include "SteeringBehaviorMachine.h"
#include "SteeringBehaviorMachineBuilder.h"
#include "SteeringBehaviorMachineDithered.h"
#include "SteeringBehaviorMachineDitheredBuilder.h"
#include "SteeringBehaviorMachinePrioritized.h"
#include "SteeringBehaviorMachinePrioritizedBuilder.h"
#include "SteeringBehaviorMachineWeighted.h"
#include "SteeringBehaviorMachineWeightedBuilder.h"
#include "SteeringBehaviorObstacleAvoidance.h"
#include "SteeringBehaviorObstacleAvoidanceBuilder.h"
#include "SteeringBehaviorOffsetPursuit.h"
#include "SteeringBehaviorOffsetPursuitBuilder.h"
#include "SteeringBehaviorPursuit.h"
#include "SteeringBehaviorPursuitBuilder.h"
#include "SteeringBehaviorSeek.h"
#include "SteeringBehaviorSeekBuilder.h"
#include "SteeringBehaviorSeparation.h"
#include "SteeringBehaviorSeparationBuilder.h"
#include "SteeringBehaviorWallAvoidance.h"
#include "SteeringBehaviorWallAvoidanceBuilder.h"
#include "SteeringBehaviorWander.h"
#include "SteeringBehaviorWanderBuilder.h"
#include "StopWatch.h"
#include "StopWatchBuilder.h"
#include "Thread.h"
#include "ThreadBuilder.h"
#include "Timer.h"
#include "TimerBuilder.h"
#include "World.h"
#include "WorldClock.h"
#include "WorldDebugDrawer.h"
#include "WorldFactory.h"
#ifdef USE_NANOVG_LIBRARY
    #include "ButtonHUD.h"
    #include "ButtonHUDBuilder.h"
    #include "CheckboxHUD.h"
    #include "CheckboxHUDBuilder.h"
    #include "DropdownHUD.h"
    #include "DropdownHUDBuilder.h"
    #include "LabelHUD.h"
    #include "LabelHUDBuilder.h"
    #include "SliderHUD.h"
    #include "SliderHUDBuilder.h"
    #include "TextboxHUD.h"
    #include "TextboxHUDBuilder.h"
    #include "WorldHUD.h"
#endif
#include "WorldLuaVirtualMachine.h"
#include "WorldResourceLoader.h"
//#include "WorldSQLite.h"
#include "WorldSocket.h"
#include "WorldState.h"
#include "WorldStateBuilder.h"
#include "WorldStateMachine.h"
#include "WorldStateMachineBuilder.h"
#include "Xml.h"
#include "XmlBuilder.h"
//#########################################################################################################
#include "DeviceInputTime.h"
#include "DeviceTouch.h"
#include "File.h"
//#include "Game.h"
//#include "JLIAssetUtil.h"
//#include "JLIFileUtil.h"
#include "Localization.h"
#include "Log.h"
#include "Macros.h"
#include "Sound.h"
#include "Util.h"
#include "ColorUtil.h"
//#include "WorldFacebook.h"
#include "WorldInput.h"
//#include "WorldPythonVirtualMachine.h"
#include "WorldSound.h"


#include "AbstractActionable.h"
    

#include "AbstractBuilder.h"
    

#include "AbstractClock.h"
    

#include "AbstractDecorator.h"
    

#include "AbstractFactoryObject.h"
    

#include "AbstractFrameBufferObject.h"
    

#include "AbstractObject.h"
    

#include "AbstractRender.h"
    

#include "AbstractState.h"
    

#include "AbstractStateMachine.h"
    

#include "AbstractTransform.h"
    

#include "PhysicsBody.h"
    

#include "PhysicsShape.h"
    

#include "Geometry.h"
    

    static njli::Sound **new_SoundArray(int nelements) { 

        return njli::Sound::createArray(nelements);
        
}
    
    static void delete_SoundArray(njli::Sound **ary) { 

        njli::Sound::destroyArray(ary);
        
}
    
    static njli::Sound *SoundArray_getitem(njli::Sound **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SoundArray_setitem(njli::Sound **ary, int index, njli::Sound *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::Action **new_ActionArray(int nelements) { 

        return njli::Action::createArray(nelements);
        
}
    
    static void delete_ActionArray(njli::Action **ary) { 

        njli::Action::destroyArray(ary);
        
}
    
    static njli::Action *ActionArray_getitem(njli::Action **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void ActionArray_setitem(njli::Action **ary, int index, njli::Action *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::ActionBuilder **new_ActionBuilderArray(int nelements) { 

        return njli::ActionBuilder::createArray(nelements);
        
}
    
    static void delete_ActionBuilderArray(njli::ActionBuilder **ary) { 

        njli::ActionBuilder::destroyArray(ary);
        
}
    
    static njli::ActionBuilder *ActionBuilderArray_getitem(njli::ActionBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void ActionBuilderArray_setitem(njli::ActionBuilder **ary, int index, njli::ActionBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::Camera **new_CameraArray(int nelements) { 

        return njli::Camera::createArray(nelements);
        
}
    
    static void delete_CameraArray(njli::Camera **ary) { 

        njli::Camera::destroyArray(ary);
        
}
    
    static njli::Camera *CameraArray_getitem(njli::Camera **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void CameraArray_setitem(njli::Camera **ary, int index, njli::Camera *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::CameraBuilder **new_CameraBuilderArray(int nelements) { 

        return njli::CameraBuilder::createArray(nelements);
        
}
    
    static void delete_CameraBuilderArray(njli::CameraBuilder **ary) { 

        njli::CameraBuilder::destroyArray(ary);
        
}
    
    static njli::CameraBuilder *CameraBuilderArray_getitem(njli::CameraBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void CameraBuilderArray_setitem(njli::CameraBuilder **ary, int index, njli::CameraBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::Clock **new_ClockArray(int nelements) { 

        return njli::Clock::createArray(nelements);
        
}
    
    static void delete_ClockArray(njli::Clock **ary) { 

        njli::Clock::destroyArray(ary);
        
}
    
    static njli::Clock *ClockArray_getitem(njli::Clock **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void ClockArray_setitem(njli::Clock **ary, int index, njli::Clock *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::ClockBuilder **new_ClockBuilderArray(int nelements) { 

        return njli::ClockBuilder::createArray(nelements);
        
}
    
    static void delete_ClockBuilderArray(njli::ClockBuilder **ary) { 

        njli::ClockBuilder::destroyArray(ary);
        
}
    
    static njli::ClockBuilder *ClockBuilderArray_getitem(njli::ClockBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void ClockBuilderArray_setitem(njli::ClockBuilder **ary, int index, njli::ClockBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::CollisionResponse **new_CollisionResponseArray(int nelements) { 

        return njli::CollisionResponse::createArray(nelements);
        
}
    
    static void delete_CollisionResponseArray(njli::CollisionResponse **ary) { 

        njli::CollisionResponse::destroyArray(ary);
        
}
    
    static njli::CollisionResponse *CollisionResponseArray_getitem(njli::CollisionResponse **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void CollisionResponseArray_setitem(njli::CollisionResponse **ary, int index, njli::CollisionResponse *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::CollisionResponseBuilder **new_CollisionResponseBuilderArray(int nelements) { 

        return njli::CollisionResponseBuilder::createArray(nelements);
        
}
    
    static void delete_CollisionResponseBuilderArray(njli::CollisionResponseBuilder **ary) { 

        njli::CollisionResponseBuilder::destroyArray(ary);
        
}
    
    static njli::CollisionResponseBuilder *CollisionResponseBuilderArray_getitem(njli::CollisionResponseBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void CollisionResponseBuilderArray_setitem(njli::CollisionResponseBuilder **ary, int index, njli::CollisionResponseBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::Cube **new_CubeArray(int nelements) { 

        return njli::Cube::createArray(nelements);
        
}
    
    static void delete_CubeArray(njli::Cube **ary) { 

        njli::Cube::destroyArray(ary);
        
}
    
    static njli::Cube *CubeArray_getitem(njli::Cube **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void CubeArray_setitem(njli::Cube **ary, int index, njli::Cube *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::CubeBuilder **new_CubeBuilderArray(int nelements) { 

        return njli::CubeBuilder::createArray(nelements);
        
}
    
    static void delete_CubeBuilderArray(njli::CubeBuilder **ary) { 

        njli::CubeBuilder::destroyArray(ary);
        
}
    
    static njli::CubeBuilder *CubeBuilderArray_getitem(njli::CubeBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void CubeBuilderArray_setitem(njli::CubeBuilder **ary, int index, njli::CubeBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::Font **new_FontArray(int nelements) { 

        return njli::Font::createArray(nelements);
        
}
    
    static void delete_FontArray(njli::Font **ary) { 

        njli::Font::destroyArray(ary);
        
}
    
    static njli::Font *FontArray_getitem(njli::Font **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void FontArray_setitem(njli::Font **ary, int index, njli::Font *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::FontBuilder **new_FontBuilderArray(int nelements) { 

        return njli::FontBuilder::createArray(nelements);
        
}
    
    static void delete_FontBuilderArray(njli::FontBuilder **ary) { 

        njli::FontBuilder::destroyArray(ary);
        
}
    
    static njli::FontBuilder *FontBuilderArray_getitem(njli::FontBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void FontBuilderArray_setitem(njli::FontBuilder **ary, int index, njli::FontBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::Image **new_ImageArray(int nelements) { 

        return njli::Image::createArray(nelements);
        
}
    
    static void delete_ImageArray(njli::Image **ary) { 

        njli::Image::destroyArray(ary);
        
}
    
    static njli::Image *ImageArray_getitem(njli::Image **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void ImageArray_setitem(njli::Image **ary, int index, njli::Image *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::ImageBuilder **new_ImageBuilderArray(int nelements) { 

        return njli::ImageBuilder::createArray(nelements);
        
}
    
    static void delete_ImageBuilderArray(njli::ImageBuilder **ary) { 

        njli::ImageBuilder::destroyArray(ary);
        
}
    
    static njli::ImageBuilder *ImageBuilderArray_getitem(njli::ImageBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void ImageBuilderArray_setitem(njli::ImageBuilder **ary, int index, njli::ImageBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::JsonJLI **new_JsonJLIArray(int nelements) { 

        return njli::JsonJLI::createArray(nelements);
        
}
    
    static void delete_JsonJLIArray(njli::JsonJLI **ary) { 

        njli::JsonJLI::destroyArray(ary);
        
}
    
    static njli::JsonJLI *JsonJLIArray_getitem(njli::JsonJLI **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void JsonJLIArray_setitem(njli::JsonJLI **ary, int index, njli::JsonJLI *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::JsonJLIBuilder **new_JsonJLIBuilderArray(int nelements) { 

        return njli::JsonJLIBuilder::createArray(nelements);
        
}
    
    static void delete_JsonJLIBuilderArray(njli::JsonJLIBuilder **ary) { 

        njli::JsonJLIBuilder::destroyArray(ary);
        
}
    
    static njli::JsonJLIBuilder *JsonJLIBuilderArray_getitem(njli::JsonJLIBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void JsonJLIBuilderArray_setitem(njli::JsonJLIBuilder **ary, int index, njli::JsonJLIBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::LevelOfDetail **new_LevelOfDetailArray(int nelements) { 

        return njli::LevelOfDetail::createArray(nelements);
        
}
    
    static void delete_LevelOfDetailArray(njli::LevelOfDetail **ary) { 

        njli::LevelOfDetail::destroyArray(ary);
        
}
    
    static njli::LevelOfDetail *LevelOfDetailArray_getitem(njli::LevelOfDetail **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void LevelOfDetailArray_setitem(njli::LevelOfDetail **ary, int index, njli::LevelOfDetail *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::LevelOfDetailBuilder **new_LevelOfDetailBuilderArray(int nelements) { 

        return njli::LevelOfDetailBuilder::createArray(nelements);
        
}
    
    static void delete_LevelOfDetailBuilderArray(njli::LevelOfDetailBuilder **ary) { 

        njli::LevelOfDetailBuilder::destroyArray(ary);
        
}
    
    static njli::LevelOfDetailBuilder *LevelOfDetailBuilderArray_getitem(njli::LevelOfDetailBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void LevelOfDetailBuilderArray_setitem(njli::LevelOfDetailBuilder **ary, int index, njli::LevelOfDetailBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::Light **new_LightArray(int nelements) { 

        return njli::Light::createArray(nelements);
        
}
    
    static void delete_LightArray(njli::Light **ary) { 

        njli::Light::destroyArray(ary);
        
}
    
    static njli::Light *LightArray_getitem(njli::Light **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void LightArray_setitem(njli::Light **ary, int index, njli::Light *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::LightBuilder **new_LightBuilderArray(int nelements) { 

        return njli::LightBuilder::createArray(nelements);
        
}
    
    static void delete_LightBuilderArray(njli::LightBuilder **ary) { 

        njli::LightBuilder::destroyArray(ary);
        
}
    
    static njli::LightBuilder *LightBuilderArray_getitem(njli::LightBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void LightBuilderArray_setitem(njli::LightBuilder **ary, int index, njli::LightBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::Material **new_MaterialArray(int nelements) { 

        return njli::Material::createArray(nelements);
        
}
    
    static void delete_MaterialArray(njli::Material **ary) { 

        njli::Material::destroyArray(ary);
        
}
    
    static njli::Material *MaterialArray_getitem(njli::Material **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void MaterialArray_setitem(njli::Material **ary, int index, njli::Material *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::MaterialBuilder **new_MaterialBuilderArray(int nelements) { 

        return njli::MaterialBuilder::createArray(nelements);
        
}
    
    static void delete_MaterialBuilderArray(njli::MaterialBuilder **ary) { 

        njli::MaterialBuilder::destroyArray(ary);
        
}
    
    static njli::MaterialBuilder *MaterialBuilderArray_getitem(njli::MaterialBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void MaterialBuilderArray_setitem(njli::MaterialBuilder **ary, int index, njli::MaterialBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::MaterialProperty **new_MaterialPropertyArray(int nelements) { 

        return njli::MaterialProperty::createArray(nelements);
        
}
    
    static void delete_MaterialPropertyArray(njli::MaterialProperty **ary) { 

        njli::MaterialProperty::destroyArray(ary);
        
}
    
    static njli::MaterialProperty *MaterialPropertyArray_getitem(njli::MaterialProperty **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void MaterialPropertyArray_setitem(njli::MaterialProperty **ary, int index, njli::MaterialProperty *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::MaterialPropertyBuilder **new_MaterialPropertyBuilderArray(int nelements) { 

        return njli::MaterialPropertyBuilder::createArray(nelements);
        
}
    
    static void delete_MaterialPropertyBuilderArray(njli::MaterialPropertyBuilder **ary) { 

        njli::MaterialPropertyBuilder::destroyArray(ary);
        
}
    
    static njli::MaterialPropertyBuilder *MaterialPropertyBuilderArray_getitem(njli::MaterialPropertyBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void MaterialPropertyBuilderArray_setitem(njli::MaterialPropertyBuilder **ary, int index, njli::MaterialPropertyBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::Node **new_NodeArray(int nelements) { 

        return njli::Node::createArray(nelements);
        
}
    
    static void delete_NodeArray(njli::Node **ary) { 

        njli::Node::destroyArray(ary);
        
}
    
    static njli::Node *NodeArray_getitem(njli::Node **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void NodeArray_setitem(njli::Node **ary, int index, njli::Node *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::NodeBuilder **new_NodeBuilderArray(int nelements) { 

        return njli::NodeBuilder::createArray(nelements);
        
}
    
    static void delete_NodeBuilderArray(njli::NodeBuilder **ary) { 

        njli::NodeBuilder::destroyArray(ary);
        
}
    
    static njli::NodeBuilder *NodeBuilderArray_getitem(njli::NodeBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void NodeBuilderArray_setitem(njli::NodeBuilder **ary, int index, njli::NodeBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::NodeState **new_NodeStateArray(int nelements) { 

        return njli::NodeState::createArray(nelements);
        
}
    
    static void delete_NodeStateArray(njli::NodeState **ary) { 

        njli::NodeState::destroyArray(ary);
        
}
    
    static njli::NodeState *NodeStateArray_getitem(njli::NodeState **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void NodeStateArray_setitem(njli::NodeState **ary, int index, njli::NodeState *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::NodeStateBuilder **new_NodeStateBuilderArray(int nelements) { 

        return njli::NodeStateBuilder::createArray(nelements);
        
}
    
    static void delete_NodeStateBuilderArray(njli::NodeStateBuilder **ary) { 

        njli::NodeStateBuilder::destroyArray(ary);
        
}
    
    static njli::NodeStateBuilder *NodeStateBuilderArray_getitem(njli::NodeStateBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void NodeStateBuilderArray_setitem(njli::NodeStateBuilder **ary, int index, njli::NodeStateBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::NodeStateMachine **new_NodeStateMachineArray(int nelements) { 

        return njli::NodeStateMachine::createArray(nelements);
        
}
    
    static void delete_NodeStateMachineArray(njli::NodeStateMachine **ary) { 

        njli::NodeStateMachine::destroyArray(ary);
        
}
    
    static njli::NodeStateMachine *NodeStateMachineArray_getitem(njli::NodeStateMachine **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void NodeStateMachineArray_setitem(njli::NodeStateMachine **ary, int index, njli::NodeStateMachine *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::NodeStateMachineBuilder **new_NodeStateMachineBuilderArray(int nelements) { 

        return njli::NodeStateMachineBuilder::createArray(nelements);
        
}
    
    static void delete_NodeStateMachineBuilderArray(njli::NodeStateMachineBuilder **ary) { 

        njli::NodeStateMachineBuilder::destroyArray(ary);
        
}
    
    static njli::NodeStateMachineBuilder *NodeStateMachineBuilderArray_getitem(njli::NodeStateMachineBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void NodeStateMachineBuilderArray_setitem(njli::NodeStateMachineBuilder **ary, int index, njli::NodeStateMachineBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::ParticleEmitter **new_ParticleEmitterArray(int nelements) { 

        return njli::ParticleEmitter::createArray(nelements);
        
}
    
    static void delete_ParticleEmitterArray(njli::ParticleEmitter **ary) { 

        njli::ParticleEmitter::destroyArray(ary);
        
}
    
    static njli::ParticleEmitter *ParticleEmitterArray_getitem(njli::ParticleEmitter **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void ParticleEmitterArray_setitem(njli::ParticleEmitter **ary, int index, njli::ParticleEmitter *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::ParticleEmitterBuilder **new_ParticleEmitterBuilderArray(int nelements) { 

        return njli::ParticleEmitterBuilder::createArray(nelements);
        
}
    
    static void delete_ParticleEmitterBuilderArray(njli::ParticleEmitterBuilder **ary) { 

        njli::ParticleEmitterBuilder::destroyArray(ary);
        
}
    
    static njli::ParticleEmitterBuilder *ParticleEmitterBuilderArray_getitem(njli::ParticleEmitterBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void ParticleEmitterBuilderArray_setitem(njli::ParticleEmitterBuilder **ary, int index, njli::ParticleEmitterBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsBodyGhost **new_PhysicsBodyGhostArray(int nelements) { 

        return njli::PhysicsBodyGhost::createArray(nelements);
        
}
    
    static void delete_PhysicsBodyGhostArray(njli::PhysicsBodyGhost **ary) { 

        njli::PhysicsBodyGhost::destroyArray(ary);
        
}
    
    static njli::PhysicsBodyGhost *PhysicsBodyGhostArray_getitem(njli::PhysicsBodyGhost **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsBodyGhostArray_setitem(njli::PhysicsBodyGhost **ary, int index, njli::PhysicsBodyGhost *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsBodyGhostBuilder **new_PhysicsBodyGhostBuilderArray(int nelements) { 

        return njli::PhysicsBodyGhostBuilder::createArray(nelements);
        
}
    
    static void delete_PhysicsBodyGhostBuilderArray(njli::PhysicsBodyGhostBuilder **ary) { 

        njli::PhysicsBodyGhostBuilder::destroyArray(ary);
        
}
    
    static njli::PhysicsBodyGhostBuilder *PhysicsBodyGhostBuilderArray_getitem(njli::PhysicsBodyGhostBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsBodyGhostBuilderArray_setitem(njli::PhysicsBodyGhostBuilder **ary, int index, njli::PhysicsBodyGhostBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsBodyRigid **new_PhysicsBodyRigidArray(int nelements) { 

        return njli::PhysicsBodyRigid::createArray(nelements);
        
}
    
    static void delete_PhysicsBodyRigidArray(njli::PhysicsBodyRigid **ary) { 

        njli::PhysicsBodyRigid::destroyArray(ary);
        
}
    
    static njli::PhysicsBodyRigid *PhysicsBodyRigidArray_getitem(njli::PhysicsBodyRigid **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsBodyRigidArray_setitem(njli::PhysicsBodyRigid **ary, int index, njli::PhysicsBodyRigid *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsBodyRigidBuilder **new_PhysicsBodyRigidBuilderArray(int nelements) { 

        return njli::PhysicsBodyRigidBuilder::createArray(nelements);
        
}
    
    static void delete_PhysicsBodyRigidBuilderArray(njli::PhysicsBodyRigidBuilder **ary) { 

        njli::PhysicsBodyRigidBuilder::destroyArray(ary);
        
}
    
    static njli::PhysicsBodyRigidBuilder *PhysicsBodyRigidBuilderArray_getitem(njli::PhysicsBodyRigidBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsBodyRigidBuilderArray_setitem(njli::PhysicsBodyRigidBuilder **ary, int index, njli::PhysicsBodyRigidBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsBodySoft **new_PhysicsBodySoftArray(int nelements) { 

        return njli::PhysicsBodySoft::createArray(nelements);
        
}
    
    static void delete_PhysicsBodySoftArray(njli::PhysicsBodySoft **ary) { 

        njli::PhysicsBodySoft::destroyArray(ary);
        
}
    
    static njli::PhysicsBodySoft *PhysicsBodySoftArray_getitem(njli::PhysicsBodySoft **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsBodySoftArray_setitem(njli::PhysicsBodySoft **ary, int index, njli::PhysicsBodySoft *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsBodySoftBuilder **new_PhysicsBodySoftBuilderArray(int nelements) { 

        return njli::PhysicsBodySoftBuilder::createArray(nelements);
        
}
    
    static void delete_PhysicsBodySoftBuilderArray(njli::PhysicsBodySoftBuilder **ary) { 

        njli::PhysicsBodySoftBuilder::destroyArray(ary);
        
}
    
    static njli::PhysicsBodySoftBuilder *PhysicsBodySoftBuilderArray_getitem(njli::PhysicsBodySoftBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsBodySoftBuilderArray_setitem(njli::PhysicsBodySoftBuilder **ary, int index, njli::PhysicsBodySoftBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsCloseContact **new_PhysicsCloseContactArray(int nelements) { 

        return njli::PhysicsCloseContact::createArray(nelements);
        
}
    
    static void delete_PhysicsCloseContactArray(njli::PhysicsCloseContact **ary) { 

        njli::PhysicsCloseContact::destroyArray(ary);
        
}
    
    static njli::PhysicsCloseContact *PhysicsCloseContactArray_getitem(njli::PhysicsCloseContact **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsCloseContactArray_setitem(njli::PhysicsCloseContact **ary, int index, njli::PhysicsCloseContact *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsCloseContactBuilder **new_PhysicsCloseContactBuilderArray(int nelements) { 

        return njli::PhysicsCloseContactBuilder::createArray(nelements);
        
}
    
    static void delete_PhysicsCloseContactBuilderArray(njli::PhysicsCloseContactBuilder **ary) { 

        njli::PhysicsCloseContactBuilder::destroyArray(ary);
        
}
    
    static njli::PhysicsCloseContactBuilder *PhysicsCloseContactBuilderArray_getitem(njli::PhysicsCloseContactBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsCloseContactBuilderArray_setitem(njli::PhysicsCloseContactBuilder **ary, int index, njli::PhysicsCloseContactBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsConstraint **new_PhysicsConstraintArray(int nelements) { 

        return njli::PhysicsConstraint::createArray(nelements);
        
}
    
    static void delete_PhysicsConstraintArray(njli::PhysicsConstraint **ary) { 

        njli::PhysicsConstraint::destroyArray(ary);
        
}
    
    static njli::PhysicsConstraint *PhysicsConstraintArray_getitem(njli::PhysicsConstraint **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsConstraintArray_setitem(njli::PhysicsConstraint **ary, int index, njli::PhysicsConstraint *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsConstraintBuilder **new_PhysicsConstraintBuilderArray(int nelements) { 

        return njli::PhysicsConstraintBuilder::createArray(nelements);
        
}
    
    static void delete_PhysicsConstraintBuilderArray(njli::PhysicsConstraintBuilder **ary) { 

        njli::PhysicsConstraintBuilder::destroyArray(ary);
        
}
    
    static njli::PhysicsConstraintBuilder *PhysicsConstraintBuilderArray_getitem(njli::PhysicsConstraintBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsConstraintBuilderArray_setitem(njli::PhysicsConstraintBuilder **ary, int index, njli::PhysicsConstraintBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsConstraintConeTwist **new_PhysicsConstraintConeTwistArray(int nelements) { 

        return njli::PhysicsConstraintConeTwist::createArray(nelements);
        
}
    
    static void delete_PhysicsConstraintConeTwistArray(njli::PhysicsConstraintConeTwist **ary) { 

        njli::PhysicsConstraintConeTwist::destroyArray(ary);
        
}
    
    static njli::PhysicsConstraintConeTwist *PhysicsConstraintConeTwistArray_getitem(njli::PhysicsConstraintConeTwist **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsConstraintConeTwistArray_setitem(njli::PhysicsConstraintConeTwist **ary, int index, njli::PhysicsConstraintConeTwist *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsConstraintConeTwistBuilder **new_PhysicsConstraintConeTwistBuilderArray(int nelements) { 

        return njli::PhysicsConstraintConeTwistBuilder::createArray(nelements);
        
}
    
    static void delete_PhysicsConstraintConeTwistBuilderArray(njli::PhysicsConstraintConeTwistBuilder **ary) { 

        njli::PhysicsConstraintConeTwistBuilder::destroyArray(ary);
        
}
    
    static njli::PhysicsConstraintConeTwistBuilder *PhysicsConstraintConeTwistBuilderArray_getitem(njli::PhysicsConstraintConeTwistBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsConstraintConeTwistBuilderArray_setitem(njli::PhysicsConstraintConeTwistBuilder **ary, int index, njli::PhysicsConstraintConeTwistBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsConstraintFixed **new_PhysicsConstraintFixedArray(int nelements) { 

        return njli::PhysicsConstraintFixed::createArray(nelements);
        
}
    
    static void delete_PhysicsConstraintFixedArray(njli::PhysicsConstraintFixed **ary) { 

        njli::PhysicsConstraintFixed::destroyArray(ary);
        
}
    
    static njli::PhysicsConstraintFixed *PhysicsConstraintFixedArray_getitem(njli::PhysicsConstraintFixed **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsConstraintFixedArray_setitem(njli::PhysicsConstraintFixed **ary, int index, njli::PhysicsConstraintFixed *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsConstraintFixedBuilder **new_PhysicsConstraintFixedBuilderArray(int nelements) { 

        return njli::PhysicsConstraintFixedBuilder::createArray(nelements);
        
}
    
    static void delete_PhysicsConstraintFixedBuilderArray(njli::PhysicsConstraintFixedBuilder **ary) { 

        njli::PhysicsConstraintFixedBuilder::destroyArray(ary);
        
}
    
    static njli::PhysicsConstraintFixedBuilder *PhysicsConstraintFixedBuilderArray_getitem(njli::PhysicsConstraintFixedBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsConstraintFixedBuilderArray_setitem(njli::PhysicsConstraintFixedBuilder **ary, int index, njli::PhysicsConstraintFixedBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsConstraintGeneric6Dof **new_PhysicsConstraintGeneric6DofArray(int nelements) { 

        return njli::PhysicsConstraintGeneric6Dof::createArray(nelements);
        
}
    
    static void delete_PhysicsConstraintGeneric6DofArray(njli::PhysicsConstraintGeneric6Dof **ary) { 

        njli::PhysicsConstraintGeneric6Dof::destroyArray(ary);
        
}
    
    static njli::PhysicsConstraintGeneric6Dof *PhysicsConstraintGeneric6DofArray_getitem(njli::PhysicsConstraintGeneric6Dof **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsConstraintGeneric6DofArray_setitem(njli::PhysicsConstraintGeneric6Dof **ary, int index, njli::PhysicsConstraintGeneric6Dof *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsConstraintGeneric6DofBuilder **new_PhysicsConstraintGeneric6DofBuilderArray(int nelements) { 

        return njli::PhysicsConstraintGeneric6DofBuilder::createArray(nelements);
        
}
    
    static void delete_PhysicsConstraintGeneric6DofBuilderArray(njli::PhysicsConstraintGeneric6DofBuilder **ary) { 

        njli::PhysicsConstraintGeneric6DofBuilder::destroyArray(ary);
        
}
    
    static njli::PhysicsConstraintGeneric6DofBuilder *PhysicsConstraintGeneric6DofBuilderArray_getitem(njli::PhysicsConstraintGeneric6DofBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsConstraintGeneric6DofBuilderArray_setitem(njli::PhysicsConstraintGeneric6DofBuilder **ary, int index, njli::PhysicsConstraintGeneric6DofBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsConstraintGeneric6DofSpring **new_PhysicsConstraintGeneric6DofSpringArray(int nelements) { 

        return njli::PhysicsConstraintGeneric6DofSpring::createArray(nelements);
        
}
    
    static void delete_PhysicsConstraintGeneric6DofSpringArray(njli::PhysicsConstraintGeneric6DofSpring **ary) { 

        njli::PhysicsConstraintGeneric6DofSpring::destroyArray(ary);
        
}
    
    static njli::PhysicsConstraintGeneric6DofSpring *PhysicsConstraintGeneric6DofSpringArray_getitem(njli::PhysicsConstraintGeneric6DofSpring **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsConstraintGeneric6DofSpringArray_setitem(njli::PhysicsConstraintGeneric6DofSpring **ary, int index, njli::PhysicsConstraintGeneric6DofSpring *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsConstraintGeneric6DofSpringBuilder **new_PhysicsConstraintGeneric6DofSpringBuilderArray(int nelements) { 

        return njli::PhysicsConstraintGeneric6DofSpringBuilder::createArray(nelements);
        
}
    
    static void delete_PhysicsConstraintGeneric6DofSpringBuilderArray(njli::PhysicsConstraintGeneric6DofSpringBuilder **ary) { 

        njli::PhysicsConstraintGeneric6DofSpringBuilder::destroyArray(ary);
        
}
    
    static njli::PhysicsConstraintGeneric6DofSpringBuilder *PhysicsConstraintGeneric6DofSpringBuilderArray_getitem(njli::PhysicsConstraintGeneric6DofSpringBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsConstraintGeneric6DofSpringBuilderArray_setitem(njli::PhysicsConstraintGeneric6DofSpringBuilder **ary, int index, njli::PhysicsConstraintGeneric6DofSpringBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsConstraintHinge **new_PhysicsConstraintHingeArray(int nelements) { 

        return njli::PhysicsConstraintHinge::createArray(nelements);
        
}
    
    static void delete_PhysicsConstraintHingeArray(njli::PhysicsConstraintHinge **ary) { 

        njli::PhysicsConstraintHinge::destroyArray(ary);
        
}
    
    static njli::PhysicsConstraintHinge *PhysicsConstraintHingeArray_getitem(njli::PhysicsConstraintHinge **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsConstraintHingeArray_setitem(njli::PhysicsConstraintHinge **ary, int index, njli::PhysicsConstraintHinge *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsConstraintHingeBuilder **new_PhysicsConstraintHingeBuilderArray(int nelements) { 

        return njli::PhysicsConstraintHingeBuilder::createArray(nelements);
        
}
    
    static void delete_PhysicsConstraintHingeBuilderArray(njli::PhysicsConstraintHingeBuilder **ary) { 

        njli::PhysicsConstraintHingeBuilder::destroyArray(ary);
        
}
    
    static njli::PhysicsConstraintHingeBuilder *PhysicsConstraintHingeBuilderArray_getitem(njli::PhysicsConstraintHingeBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsConstraintHingeBuilderArray_setitem(njli::PhysicsConstraintHingeBuilder **ary, int index, njli::PhysicsConstraintHingeBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsConstraintPointToPoint **new_PhysicsConstraintPointToPointArray(int nelements) { 

        return njli::PhysicsConstraintPointToPoint::createArray(nelements);
        
}
    
    static void delete_PhysicsConstraintPointToPointArray(njli::PhysicsConstraintPointToPoint **ary) { 

        njli::PhysicsConstraintPointToPoint::destroyArray(ary);
        
}
    
    static njli::PhysicsConstraintPointToPoint *PhysicsConstraintPointToPointArray_getitem(njli::PhysicsConstraintPointToPoint **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsConstraintPointToPointArray_setitem(njli::PhysicsConstraintPointToPoint **ary, int index, njli::PhysicsConstraintPointToPoint *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsConstraintPointToPointBuilder **new_PhysicsConstraintPointToPointBuilderArray(int nelements) { 

        return njli::PhysicsConstraintPointToPointBuilder::createArray(nelements);
        
}
    
    static void delete_PhysicsConstraintPointToPointBuilderArray(njli::PhysicsConstraintPointToPointBuilder **ary) { 

        njli::PhysicsConstraintPointToPointBuilder::destroyArray(ary);
        
}
    
    static njli::PhysicsConstraintPointToPointBuilder *PhysicsConstraintPointToPointBuilderArray_getitem(njli::PhysicsConstraintPointToPointBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsConstraintPointToPointBuilderArray_setitem(njli::PhysicsConstraintPointToPointBuilder **ary, int index, njli::PhysicsConstraintPointToPointBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsConstraintSlider **new_PhysicsConstraintSliderArray(int nelements) { 

        return njli::PhysicsConstraintSlider::createArray(nelements);
        
}
    
    static void delete_PhysicsConstraintSliderArray(njli::PhysicsConstraintSlider **ary) { 

        njli::PhysicsConstraintSlider::destroyArray(ary);
        
}
    
    static njli::PhysicsConstraintSlider *PhysicsConstraintSliderArray_getitem(njli::PhysicsConstraintSlider **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsConstraintSliderArray_setitem(njli::PhysicsConstraintSlider **ary, int index, njli::PhysicsConstraintSlider *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsConstraintSliderBuilder **new_PhysicsConstraintSliderBuilderArray(int nelements) { 

        return njli::PhysicsConstraintSliderBuilder::createArray(nelements);
        
}
    
    static void delete_PhysicsConstraintSliderBuilderArray(njli::PhysicsConstraintSliderBuilder **ary) { 

        njli::PhysicsConstraintSliderBuilder::destroyArray(ary);
        
}
    
    static njli::PhysicsConstraintSliderBuilder *PhysicsConstraintSliderBuilderArray_getitem(njli::PhysicsConstraintSliderBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsConstraintSliderBuilderArray_setitem(njli::PhysicsConstraintSliderBuilder **ary, int index, njli::PhysicsConstraintSliderBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsContact **new_PhysicsContactArray(int nelements) { 

        return njli::PhysicsContact::createArray(nelements);
        
}
    
    static void delete_PhysicsContactArray(njli::PhysicsContact **ary) { 

        njli::PhysicsContact::destroyArray(ary);
        
}
    
    static njli::PhysicsContact *PhysicsContactArray_getitem(njli::PhysicsContact **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsContactArray_setitem(njli::PhysicsContact **ary, int index, njli::PhysicsContact *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsContactBuilder **new_PhysicsContactBuilderArray(int nelements) { 

        return njli::PhysicsContactBuilder::createArray(nelements);
        
}
    
    static void delete_PhysicsContactBuilderArray(njli::PhysicsContactBuilder **ary) { 

        njli::PhysicsContactBuilder::destroyArray(ary);
        
}
    
    static njli::PhysicsContactBuilder *PhysicsContactBuilderArray_getitem(njli::PhysicsContactBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsContactBuilderArray_setitem(njli::PhysicsContactBuilder **ary, int index, njli::PhysicsContactBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsField **new_PhysicsFieldArray(int nelements) { 

        return njli::PhysicsField::createArray(nelements);
        
}
    
    static void delete_PhysicsFieldArray(njli::PhysicsField **ary) { 

        njli::PhysicsField::destroyArray(ary);
        
}
    
    static njli::PhysicsField *PhysicsFieldArray_getitem(njli::PhysicsField **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsFieldArray_setitem(njli::PhysicsField **ary, int index, njli::PhysicsField *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsFieldBuilder **new_PhysicsFieldBuilderArray(int nelements) { 

        return njli::PhysicsFieldBuilder::createArray(nelements);
        
}
    
    static void delete_PhysicsFieldBuilderArray(njli::PhysicsFieldBuilder **ary) { 

        njli::PhysicsFieldBuilder::destroyArray(ary);
        
}
    
    static njli::PhysicsFieldBuilder *PhysicsFieldBuilderArray_getitem(njli::PhysicsFieldBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsFieldBuilderArray_setitem(njli::PhysicsFieldBuilder **ary, int index, njli::PhysicsFieldBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsRayContact **new_PhysicsRayContactArray(int nelements) { 

        return njli::PhysicsRayContact::createArray(nelements);
        
}
    
    static void delete_PhysicsRayContactArray(njli::PhysicsRayContact **ary) { 

        njli::PhysicsRayContact::destroyArray(ary);
        
}
    
    static njli::PhysicsRayContact *PhysicsRayContactArray_getitem(njli::PhysicsRayContact **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsRayContactArray_setitem(njli::PhysicsRayContact **ary, int index, njli::PhysicsRayContact *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsRayContactBuilder **new_PhysicsRayContactBuilderArray(int nelements) { 

        return njli::PhysicsRayContactBuilder::createArray(nelements);
        
}
    
    static void delete_PhysicsRayContactBuilderArray(njli::PhysicsRayContactBuilder **ary) { 

        njli::PhysicsRayContactBuilder::destroyArray(ary);
        
}
    
    static njli::PhysicsRayContactBuilder *PhysicsRayContactBuilderArray_getitem(njli::PhysicsRayContactBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsRayContactBuilderArray_setitem(njli::PhysicsRayContactBuilder **ary, int index, njli::PhysicsRayContactBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsShapeBox **new_PhysicsShapeBoxArray(int nelements) { 

        return njli::PhysicsShapeBox::createArray(nelements);
        
}
    
    static void delete_PhysicsShapeBoxArray(njli::PhysicsShapeBox **ary) { 

        njli::PhysicsShapeBox::destroyArray(ary);
        
}
    
    static njli::PhysicsShapeBox *PhysicsShapeBoxArray_getitem(njli::PhysicsShapeBox **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsShapeBoxArray_setitem(njli::PhysicsShapeBox **ary, int index, njli::PhysicsShapeBox *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsShapeBox2D **new_PhysicsShapeBox2DArray(int nelements) { 

        return njli::PhysicsShapeBox2D::createArray(nelements);
        
}
    
    static void delete_PhysicsShapeBox2DArray(njli::PhysicsShapeBox2D **ary) { 

        njli::PhysicsShapeBox2D::destroyArray(ary);
        
}
    
    static njli::PhysicsShapeBox2D *PhysicsShapeBox2DArray_getitem(njli::PhysicsShapeBox2D **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsShapeBox2DArray_setitem(njli::PhysicsShapeBox2D **ary, int index, njli::PhysicsShapeBox2D *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsShapeBox2DBuilder **new_PhysicsShapeBox2DBuilderArray(int nelements) { 

        return njli::PhysicsShapeBox2DBuilder::createArray(nelements);
        
}
    
    static void delete_PhysicsShapeBox2DBuilderArray(njli::PhysicsShapeBox2DBuilder **ary) { 

        njli::PhysicsShapeBox2DBuilder::destroyArray(ary);
        
}
    
    static njli::PhysicsShapeBox2DBuilder *PhysicsShapeBox2DBuilderArray_getitem(njli::PhysicsShapeBox2DBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsShapeBox2DBuilderArray_setitem(njli::PhysicsShapeBox2DBuilder **ary, int index, njli::PhysicsShapeBox2DBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsShapeBoxBuilder **new_PhysicsShapeBoxBuilderArray(int nelements) { 

        return njli::PhysicsShapeBoxBuilder::createArray(nelements);
        
}
    
    static void delete_PhysicsShapeBoxBuilderArray(njli::PhysicsShapeBoxBuilder **ary) { 

        njli::PhysicsShapeBoxBuilder::destroyArray(ary);
        
}
    
    static njli::PhysicsShapeBoxBuilder *PhysicsShapeBoxBuilderArray_getitem(njli::PhysicsShapeBoxBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsShapeBoxBuilderArray_setitem(njli::PhysicsShapeBoxBuilder **ary, int index, njli::PhysicsShapeBoxBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsShapeBvhTriangleMesh **new_PhysicsShapeBvhTriangleMeshArray(int nelements) { 

        return njli::PhysicsShapeBvhTriangleMesh::createArray(nelements);
        
}
    
    static void delete_PhysicsShapeBvhTriangleMeshArray(njli::PhysicsShapeBvhTriangleMesh **ary) { 

        njli::PhysicsShapeBvhTriangleMesh::destroyArray(ary);
        
}
    
    static njli::PhysicsShapeBvhTriangleMesh *PhysicsShapeBvhTriangleMeshArray_getitem(njli::PhysicsShapeBvhTriangleMesh **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsShapeBvhTriangleMeshArray_setitem(njli::PhysicsShapeBvhTriangleMesh **ary, int index, njli::PhysicsShapeBvhTriangleMesh *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsShapeBvhTriangleMeshBuilder **new_PhysicsShapeBvhTriangleMeshBuilderArray(int nelements) { 

        return njli::PhysicsShapeBvhTriangleMeshBuilder::createArray(nelements);
        
}
    
    static void delete_PhysicsShapeBvhTriangleMeshBuilderArray(njli::PhysicsShapeBvhTriangleMeshBuilder **ary) { 

        njli::PhysicsShapeBvhTriangleMeshBuilder::destroyArray(ary);
        
}
    
    static njli::PhysicsShapeBvhTriangleMeshBuilder *PhysicsShapeBvhTriangleMeshBuilderArray_getitem(njli::PhysicsShapeBvhTriangleMeshBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsShapeBvhTriangleMeshBuilderArray_setitem(njli::PhysicsShapeBvhTriangleMeshBuilder **ary, int index, njli::PhysicsShapeBvhTriangleMeshBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsShapeCapsule **new_PhysicsShapeCapsuleArray(int nelements) { 

        return njli::PhysicsShapeCapsule::createArray(nelements);
        
}
    
    static void delete_PhysicsShapeCapsuleArray(njli::PhysicsShapeCapsule **ary) { 

        njli::PhysicsShapeCapsule::destroyArray(ary);
        
}
    
    static njli::PhysicsShapeCapsule *PhysicsShapeCapsuleArray_getitem(njli::PhysicsShapeCapsule **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsShapeCapsuleArray_setitem(njli::PhysicsShapeCapsule **ary, int index, njli::PhysicsShapeCapsule *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsShapeCapsuleBuilder **new_PhysicsShapeCapsuleBuilderArray(int nelements) { 

        return njli::PhysicsShapeCapsuleBuilder::createArray(nelements);
        
}
    
    static void delete_PhysicsShapeCapsuleBuilderArray(njli::PhysicsShapeCapsuleBuilder **ary) { 

        njli::PhysicsShapeCapsuleBuilder::destroyArray(ary);
        
}
    
    static njli::PhysicsShapeCapsuleBuilder *PhysicsShapeCapsuleBuilderArray_getitem(njli::PhysicsShapeCapsuleBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsShapeCapsuleBuilderArray_setitem(njli::PhysicsShapeCapsuleBuilder **ary, int index, njli::PhysicsShapeCapsuleBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsShapeCone **new_PhysicsShapeConeArray(int nelements) { 

        return njli::PhysicsShapeCone::createArray(nelements);
        
}
    
    static void delete_PhysicsShapeConeArray(njli::PhysicsShapeCone **ary) { 

        njli::PhysicsShapeCone::destroyArray(ary);
        
}
    
    static njli::PhysicsShapeCone *PhysicsShapeConeArray_getitem(njli::PhysicsShapeCone **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsShapeConeArray_setitem(njli::PhysicsShapeCone **ary, int index, njli::PhysicsShapeCone *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsShapeConeBuilder **new_PhysicsShapeConeBuilderArray(int nelements) { 

        return njli::PhysicsShapeConeBuilder::createArray(nelements);
        
}
    
    static void delete_PhysicsShapeConeBuilderArray(njli::PhysicsShapeConeBuilder **ary) { 

        njli::PhysicsShapeConeBuilder::destroyArray(ary);
        
}
    
    static njli::PhysicsShapeConeBuilder *PhysicsShapeConeBuilderArray_getitem(njli::PhysicsShapeConeBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsShapeConeBuilderArray_setitem(njli::PhysicsShapeConeBuilder **ary, int index, njli::PhysicsShapeConeBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsShapeConvexHull **new_PhysicsShapeConvexHullArray(int nelements) { 

        return njli::PhysicsShapeConvexHull::createArray(nelements);
        
}
    
    static void delete_PhysicsShapeConvexHullArray(njli::PhysicsShapeConvexHull **ary) { 

        njli::PhysicsShapeConvexHull::destroyArray(ary);
        
}
    
    static njli::PhysicsShapeConvexHull *PhysicsShapeConvexHullArray_getitem(njli::PhysicsShapeConvexHull **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsShapeConvexHullArray_setitem(njli::PhysicsShapeConvexHull **ary, int index, njli::PhysicsShapeConvexHull *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsShapeConvexHullBuilder **new_PhysicsShapeConvexHullBuilderArray(int nelements) { 

        return njli::PhysicsShapeConvexHullBuilder::createArray(nelements);
        
}
    
    static void delete_PhysicsShapeConvexHullBuilderArray(njli::PhysicsShapeConvexHullBuilder **ary) { 

        njli::PhysicsShapeConvexHullBuilder::destroyArray(ary);
        
}
    
    static njli::PhysicsShapeConvexHullBuilder *PhysicsShapeConvexHullBuilderArray_getitem(njli::PhysicsShapeConvexHullBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsShapeConvexHullBuilderArray_setitem(njli::PhysicsShapeConvexHullBuilder **ary, int index, njli::PhysicsShapeConvexHullBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsShapeConvexTriangleMesh **new_PhysicsShapeConvexTriangleMeshArray(int nelements) { 

        return njli::PhysicsShapeConvexTriangleMesh::createArray(nelements);
        
}
    
    static void delete_PhysicsShapeConvexTriangleMeshArray(njli::PhysicsShapeConvexTriangleMesh **ary) { 

        njli::PhysicsShapeConvexTriangleMesh::destroyArray(ary);
        
}
    
    static njli::PhysicsShapeConvexTriangleMesh *PhysicsShapeConvexTriangleMeshArray_getitem(njli::PhysicsShapeConvexTriangleMesh **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsShapeConvexTriangleMeshArray_setitem(njli::PhysicsShapeConvexTriangleMesh **ary, int index, njli::PhysicsShapeConvexTriangleMesh *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsShapeConvexTriangleMeshBuilder **new_PhysicsShapeConvexTriangleMeshBuilderArray(int nelements) { 

        return njli::PhysicsShapeConvexTriangleMeshBuilder::createArray(nelements);
        
}
    
    static void delete_PhysicsShapeConvexTriangleMeshBuilderArray(njli::PhysicsShapeConvexTriangleMeshBuilder **ary) { 

        njli::PhysicsShapeConvexTriangleMeshBuilder::destroyArray(ary);
        
}
    
    static njli::PhysicsShapeConvexTriangleMeshBuilder *PhysicsShapeConvexTriangleMeshBuilderArray_getitem(njli::PhysicsShapeConvexTriangleMeshBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsShapeConvexTriangleMeshBuilderArray_setitem(njli::PhysicsShapeConvexTriangleMeshBuilder **ary, int index, njli::PhysicsShapeConvexTriangleMeshBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsShapeCylinder **new_PhysicsShapeCylinderArray(int nelements) { 

        return njli::PhysicsShapeCylinder::createArray(nelements);
        
}
    
    static void delete_PhysicsShapeCylinderArray(njli::PhysicsShapeCylinder **ary) { 

        njli::PhysicsShapeCylinder::destroyArray(ary);
        
}
    
    static njli::PhysicsShapeCylinder *PhysicsShapeCylinderArray_getitem(njli::PhysicsShapeCylinder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsShapeCylinderArray_setitem(njli::PhysicsShapeCylinder **ary, int index, njli::PhysicsShapeCylinder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsShapeCylinderBuilder **new_PhysicsShapeCylinderBuilderArray(int nelements) { 

        return njli::PhysicsShapeCylinderBuilder::createArray(nelements);
        
}
    
    static void delete_PhysicsShapeCylinderBuilderArray(njli::PhysicsShapeCylinderBuilder **ary) { 

        njli::PhysicsShapeCylinderBuilder::destroyArray(ary);
        
}
    
    static njli::PhysicsShapeCylinderBuilder *PhysicsShapeCylinderBuilderArray_getitem(njli::PhysicsShapeCylinderBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsShapeCylinderBuilderArray_setitem(njli::PhysicsShapeCylinderBuilder **ary, int index, njli::PhysicsShapeCylinderBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsShapeHeightfieldTerrain **new_PhysicsShapeHeightfieldTerrainArray(int nelements) { 

        return njli::PhysicsShapeHeightfieldTerrain::createArray(nelements);
        
}
    
    static void delete_PhysicsShapeHeightfieldTerrainArray(njli::PhysicsShapeHeightfieldTerrain **ary) { 

        njli::PhysicsShapeHeightfieldTerrain::destroyArray(ary);
        
}
    
    static njli::PhysicsShapeHeightfieldTerrain *PhysicsShapeHeightfieldTerrainArray_getitem(njli::PhysicsShapeHeightfieldTerrain **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsShapeHeightfieldTerrainArray_setitem(njli::PhysicsShapeHeightfieldTerrain **ary, int index, njli::PhysicsShapeHeightfieldTerrain *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsShapeHeightfieldTerrainBuilder **new_PhysicsShapeHeightfieldTerrainBuilderArray(int nelements) { 

        return njli::PhysicsShapeHeightfieldTerrainBuilder::createArray(nelements);
        
}
    
    static void delete_PhysicsShapeHeightfieldTerrainBuilderArray(njli::PhysicsShapeHeightfieldTerrainBuilder **ary) { 

        njli::PhysicsShapeHeightfieldTerrainBuilder::destroyArray(ary);
        
}
    
    static njli::PhysicsShapeHeightfieldTerrainBuilder *PhysicsShapeHeightfieldTerrainBuilderArray_getitem(njli::PhysicsShapeHeightfieldTerrainBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsShapeHeightfieldTerrainBuilderArray_setitem(njli::PhysicsShapeHeightfieldTerrainBuilder **ary, int index, njli::PhysicsShapeHeightfieldTerrainBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsShapeMultiSphere **new_PhysicsShapeMultiSphereArray(int nelements) { 

        return njli::PhysicsShapeMultiSphere::createArray(nelements);
        
}
    
    static void delete_PhysicsShapeMultiSphereArray(njli::PhysicsShapeMultiSphere **ary) { 

        njli::PhysicsShapeMultiSphere::destroyArray(ary);
        
}
    
    static njli::PhysicsShapeMultiSphere *PhysicsShapeMultiSphereArray_getitem(njli::PhysicsShapeMultiSphere **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsShapeMultiSphereArray_setitem(njli::PhysicsShapeMultiSphere **ary, int index, njli::PhysicsShapeMultiSphere *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsShapeMultiSphereBuilder **new_PhysicsShapeMultiSphereBuilderArray(int nelements) { 

        return njli::PhysicsShapeMultiSphereBuilder::createArray(nelements);
        
}
    
    static void delete_PhysicsShapeMultiSphereBuilderArray(njli::PhysicsShapeMultiSphereBuilder **ary) { 

        njli::PhysicsShapeMultiSphereBuilder::destroyArray(ary);
        
}
    
    static njli::PhysicsShapeMultiSphereBuilder *PhysicsShapeMultiSphereBuilderArray_getitem(njli::PhysicsShapeMultiSphereBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsShapeMultiSphereBuilderArray_setitem(njli::PhysicsShapeMultiSphereBuilder **ary, int index, njli::PhysicsShapeMultiSphereBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsShapeSphere **new_PhysicsShapeSphereArray(int nelements) { 

        return njli::PhysicsShapeSphere::createArray(nelements);
        
}
    
    static void delete_PhysicsShapeSphereArray(njli::PhysicsShapeSphere **ary) { 

        njli::PhysicsShapeSphere::destroyArray(ary);
        
}
    
    static njli::PhysicsShapeSphere *PhysicsShapeSphereArray_getitem(njli::PhysicsShapeSphere **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsShapeSphereArray_setitem(njli::PhysicsShapeSphere **ary, int index, njli::PhysicsShapeSphere *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsShapeSphereBuilder **new_PhysicsShapeSphereBuilderArray(int nelements) { 

        return njli::PhysicsShapeSphereBuilder::createArray(nelements);
        
}
    
    static void delete_PhysicsShapeSphereBuilderArray(njli::PhysicsShapeSphereBuilder **ary) { 

        njli::PhysicsShapeSphereBuilder::destroyArray(ary);
        
}
    
    static njli::PhysicsShapeSphereBuilder *PhysicsShapeSphereBuilderArray_getitem(njli::PhysicsShapeSphereBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsShapeSphereBuilderArray_setitem(njli::PhysicsShapeSphereBuilder **ary, int index, njli::PhysicsShapeSphereBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsShapeStaticPlane **new_PhysicsShapeStaticPlaneArray(int nelements) { 

        return njli::PhysicsShapeStaticPlane::createArray(nelements);
        
}
    
    static void delete_PhysicsShapeStaticPlaneArray(njli::PhysicsShapeStaticPlane **ary) { 

        njli::PhysicsShapeStaticPlane::destroyArray(ary);
        
}
    
    static njli::PhysicsShapeStaticPlane *PhysicsShapeStaticPlaneArray_getitem(njli::PhysicsShapeStaticPlane **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsShapeStaticPlaneArray_setitem(njli::PhysicsShapeStaticPlane **ary, int index, njli::PhysicsShapeStaticPlane *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsShapeStaticPlaneBuilder **new_PhysicsShapeStaticPlaneBuilderArray(int nelements) { 

        return njli::PhysicsShapeStaticPlaneBuilder::createArray(nelements);
        
}
    
    static void delete_PhysicsShapeStaticPlaneBuilderArray(njli::PhysicsShapeStaticPlaneBuilder **ary) { 

        njli::PhysicsShapeStaticPlaneBuilder::destroyArray(ary);
        
}
    
    static njli::PhysicsShapeStaticPlaneBuilder *PhysicsShapeStaticPlaneBuilderArray_getitem(njli::PhysicsShapeStaticPlaneBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsShapeStaticPlaneBuilderArray_setitem(njli::PhysicsShapeStaticPlaneBuilder **ary, int index, njli::PhysicsShapeStaticPlaneBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsWorld **new_PhysicsWorldArray(int nelements) { 

        return njli::PhysicsWorld::createArray(nelements);
        
}
    
    static void delete_PhysicsWorldArray(njli::PhysicsWorld **ary) { 

        njli::PhysicsWorld::destroyArray(ary);
        
}
    
    static njli::PhysicsWorld *PhysicsWorldArray_getitem(njli::PhysicsWorld **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsWorldArray_setitem(njli::PhysicsWorld **ary, int index, njli::PhysicsWorld *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PhysicsWorldBuilder **new_PhysicsWorldBuilderArray(int nelements) { 

        return njli::PhysicsWorldBuilder::createArray(nelements);
        
}
    
    static void delete_PhysicsWorldBuilderArray(njli::PhysicsWorldBuilder **ary) { 

        njli::PhysicsWorldBuilder::destroyArray(ary);
        
}
    
    static njli::PhysicsWorldBuilder *PhysicsWorldBuilderArray_getitem(njli::PhysicsWorldBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PhysicsWorldBuilderArray_setitem(njli::PhysicsWorldBuilder **ary, int index, njli::PhysicsWorldBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::Plane **new_PlaneArray(int nelements) { 

        return njli::Plane::createArray(nelements);
        
}
    
    static void delete_PlaneArray(njli::Plane **ary) { 

        njli::Plane::destroyArray(ary);
        
}
    
    static njli::Plane *PlaneArray_getitem(njli::Plane **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PlaneArray_setitem(njli::Plane **ary, int index, njli::Plane *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::PlaneBuilder **new_PlaneBuilderArray(int nelements) { 

        return njli::PlaneBuilder::createArray(nelements);
        
}
    
    static void delete_PlaneBuilderArray(njli::PlaneBuilder **ary) { 

        njli::PlaneBuilder::destroyArray(ary);
        
}
    
    static njli::PlaneBuilder *PlaneBuilderArray_getitem(njli::PlaneBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void PlaneBuilderArray_setitem(njli::PlaneBuilder **ary, int index, njli::PlaneBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::Scene **new_SceneArray(int nelements) { 

        return njli::Scene::createArray(nelements);
        
}
    
    static void delete_SceneArray(njli::Scene **ary) { 

        njli::Scene::destroyArray(ary);
        
}
    
    static njli::Scene *SceneArray_getitem(njli::Scene **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SceneArray_setitem(njli::Scene **ary, int index, njli::Scene *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SceneBuilder **new_SceneBuilderArray(int nelements) { 

        return njli::SceneBuilder::createArray(nelements);
        
}
    
    static void delete_SceneBuilderArray(njli::SceneBuilder **ary) { 

        njli::SceneBuilder::destroyArray(ary);
        
}
    
    static njli::SceneBuilder *SceneBuilderArray_getitem(njli::SceneBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SceneBuilderArray_setitem(njli::SceneBuilder **ary, int index, njli::SceneBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SceneState **new_SceneStateArray(int nelements) { 

        return njli::SceneState::createArray(nelements);
        
}
    
    static void delete_SceneStateArray(njli::SceneState **ary) { 

        njli::SceneState::destroyArray(ary);
        
}
    
    static njli::SceneState *SceneStateArray_getitem(njli::SceneState **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SceneStateArray_setitem(njli::SceneState **ary, int index, njli::SceneState *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SceneStateBuilder **new_SceneStateBuilderArray(int nelements) { 

        return njli::SceneStateBuilder::createArray(nelements);
        
}
    
    static void delete_SceneStateBuilderArray(njli::SceneStateBuilder **ary) { 

        njli::SceneStateBuilder::destroyArray(ary);
        
}
    
    static njli::SceneStateBuilder *SceneStateBuilderArray_getitem(njli::SceneStateBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SceneStateBuilderArray_setitem(njli::SceneStateBuilder **ary, int index, njli::SceneStateBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SceneStateMachine **new_SceneStateMachineArray(int nelements) { 

        return njli::SceneStateMachine::createArray(nelements);
        
}
    
    static void delete_SceneStateMachineArray(njli::SceneStateMachine **ary) { 

        njli::SceneStateMachine::destroyArray(ary);
        
}
    
    static njli::SceneStateMachine *SceneStateMachineArray_getitem(njli::SceneStateMachine **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SceneStateMachineArray_setitem(njli::SceneStateMachine **ary, int index, njli::SceneStateMachine *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SceneStateMachineBuilder **new_SceneStateMachineBuilderArray(int nelements) { 

        return njli::SceneStateMachineBuilder::createArray(nelements);
        
}
    
    static void delete_SceneStateMachineBuilderArray(njli::SceneStateMachineBuilder **ary) { 

        njli::SceneStateMachineBuilder::destroyArray(ary);
        
}
    
    static njli::SceneStateMachineBuilder *SceneStateMachineBuilderArray_getitem(njli::SceneStateMachineBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SceneStateMachineBuilderArray_setitem(njli::SceneStateMachineBuilder **ary, int index, njli::SceneStateMachineBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::ShaderProgram **new_ShaderProgramArray(int nelements) { 

        return njli::ShaderProgram::createArray(nelements);
        
}
    
    static void delete_ShaderProgramArray(njli::ShaderProgram **ary) { 

        njli::ShaderProgram::destroyArray(ary);
        
}
    
    static njli::ShaderProgram *ShaderProgramArray_getitem(njli::ShaderProgram **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void ShaderProgramArray_setitem(njli::ShaderProgram **ary, int index, njli::ShaderProgram *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::ShaderProgramBuilder **new_ShaderProgramBuilderArray(int nelements) { 

        return njli::ShaderProgramBuilder::createArray(nelements);
        
}
    
    static void delete_ShaderProgramBuilderArray(njli::ShaderProgramBuilder **ary) { 

        njli::ShaderProgramBuilder::destroyArray(ary);
        
}
    
    static njli::ShaderProgramBuilder *ShaderProgramBuilderArray_getitem(njli::ShaderProgramBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void ShaderProgramBuilderArray_setitem(njli::ShaderProgramBuilder **ary, int index, njli::ShaderProgramBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::Skinner **new_SkinnerArray(int nelements) { 

        return njli::Skinner::createArray(nelements);
        
}
    
    static void delete_SkinnerArray(njli::Skinner **ary) { 

        njli::Skinner::destroyArray(ary);
        
}
    
    static njli::Skinner *SkinnerArray_getitem(njli::Skinner **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SkinnerArray_setitem(njli::Skinner **ary, int index, njli::Skinner *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SkinnerBuilder **new_SkinnerBuilderArray(int nelements) { 

        return njli::SkinnerBuilder::createArray(nelements);
        
}
    
    static void delete_SkinnerBuilderArray(njli::SkinnerBuilder **ary) { 

        njli::SkinnerBuilder::destroyArray(ary);
        
}
    
    static njli::SkinnerBuilder *SkinnerBuilderArray_getitem(njli::SkinnerBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SkinnerBuilderArray_setitem(njli::SkinnerBuilder **ary, int index, njli::SkinnerBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SoundBuilder **new_SoundBuilderArray(int nelements) { 

        return njli::SoundBuilder::createArray(nelements);
        
}
    
    static void delete_SoundBuilderArray(njli::SoundBuilder **ary) { 

        njli::SoundBuilder::destroyArray(ary);
        
}
    
    static njli::SoundBuilder *SoundBuilderArray_getitem(njli::SoundBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SoundBuilderArray_setitem(njli::SoundBuilder **ary, int index, njli::SoundBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::Sprite2D **new_Sprite2DArray(int nelements) { 

        return njli::Sprite2D::createArray(nelements);
        
}
    
    static void delete_Sprite2DArray(njli::Sprite2D **ary) { 

        njli::Sprite2D::destroyArray(ary);
        
}
    
    static njli::Sprite2D *Sprite2DArray_getitem(njli::Sprite2D **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void Sprite2DArray_setitem(njli::Sprite2D **ary, int index, njli::Sprite2D *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::Sprite2DBuilder **new_Sprite2DBuilderArray(int nelements) { 

        return njli::Sprite2DBuilder::createArray(nelements);
        
}
    
    static void delete_Sprite2DBuilderArray(njli::Sprite2DBuilder **ary) { 

        njli::Sprite2DBuilder::destroyArray(ary);
        
}
    
    static njli::Sprite2DBuilder *Sprite2DBuilderArray_getitem(njli::Sprite2DBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void Sprite2DBuilderArray_setitem(njli::Sprite2DBuilder **ary, int index, njli::Sprite2DBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SpriteFrameAtlas **new_SpriteFrameAtlasArray(int nelements) { 

        return njli::SpriteFrameAtlas::createArray(nelements);
        
}
    
    static void delete_SpriteFrameAtlasArray(njli::SpriteFrameAtlas **ary) { 

        njli::SpriteFrameAtlas::destroyArray(ary);
        
}
    
    static njli::SpriteFrameAtlas *SpriteFrameAtlasArray_getitem(njli::SpriteFrameAtlas **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SpriteFrameAtlasArray_setitem(njli::SpriteFrameAtlas **ary, int index, njli::SpriteFrameAtlas *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SpriteFrameAtlasBuilder **new_SpriteFrameAtlasBuilderArray(int nelements) { 

        return njli::SpriteFrameAtlasBuilder::createArray(nelements);
        
}
    
    static void delete_SpriteFrameAtlasBuilderArray(njli::SpriteFrameAtlasBuilder **ary) { 

        njli::SpriteFrameAtlasBuilder::destroyArray(ary);
        
}
    
    static njli::SpriteFrameAtlasBuilder *SpriteFrameAtlasBuilderArray_getitem(njli::SpriteFrameAtlasBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SpriteFrameAtlasBuilderArray_setitem(njli::SpriteFrameAtlasBuilder **ary, int index, njli::SpriteFrameAtlasBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SteeringBehaviorAlignment **new_SteeringBehaviorAlignment(int nelements) { 

        return njli::SteeringBehaviorAlignment::createArray(nelements);
        
}
    
    static void delete_SteeringBehaviorAlignment(njli::SteeringBehaviorAlignment **ary) { 

        njli::SteeringBehaviorAlignment::destroyArray(ary);
        
}
    
    static njli::SteeringBehaviorAlignment *SteeringBehaviorAlignment_getitem(njli::SteeringBehaviorAlignment **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SteeringBehaviorAlignment_setitem(njli::SteeringBehaviorAlignment **ary, int index, njli::SteeringBehaviorAlignment *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SteeringBehaviorAlignmentBuilder **new_SteeringBehaviorAlignmentBuilder(int nelements) { 

        return njli::SteeringBehaviorAlignmentBuilder::createArray(nelements);
        
}
    
    static void delete_SteeringBehaviorAlignmentBuilder(njli::SteeringBehaviorAlignmentBuilder **ary) { 

        njli::SteeringBehaviorAlignmentBuilder::destroyArray(ary);
        
}
    
    static njli::SteeringBehaviorAlignmentBuilder *SteeringBehaviorAlignmentBuilder_getitem(njli::SteeringBehaviorAlignmentBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SteeringBehaviorAlignmentBuilder_setitem(njli::SteeringBehaviorAlignmentBuilder **ary, int index, njli::SteeringBehaviorAlignmentBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SteeringBehaviorArrive **new_SteeringBehaviorArrive(int nelements) { 

        return njli::SteeringBehaviorArrive::createArray(nelements);
        
}
    
    static void delete_SteeringBehaviorArrive(njli::SteeringBehaviorArrive **ary) { 

        njli::SteeringBehaviorArrive::destroyArray(ary);
        
}
    
    static njli::SteeringBehaviorArrive *SteeringBehaviorArrive_getitem(njli::SteeringBehaviorArrive **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SteeringBehaviorArrive_setitem(njli::SteeringBehaviorArrive **ary, int index, njli::SteeringBehaviorArrive *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SteeringBehaviorArriveBuilder **new_SteeringBehaviorArriveBuilder(int nelements) { 

        return njli::SteeringBehaviorArriveBuilder::createArray(nelements);
        
}
    
    static void delete_SteeringBehaviorArriveBuilder(njli::SteeringBehaviorArriveBuilder **ary) { 

        njli::SteeringBehaviorArriveBuilder::destroyArray(ary);
        
}
    
    static njli::SteeringBehaviorArriveBuilder *SteeringBehaviorArriveBuilder_getitem(njli::SteeringBehaviorArriveBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SteeringBehaviorArriveBuilder_setitem(njli::SteeringBehaviorArriveBuilder **ary, int index, njli::SteeringBehaviorArriveBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SteeringBehaviorCohesion **new_SteeringBehaviorCohesion(int nelements) { 

        return njli::SteeringBehaviorCohesion::createArray(nelements);
        
}
    
    static void delete_SteeringBehaviorCohesion(njli::SteeringBehaviorCohesion **ary) { 

        njli::SteeringBehaviorCohesion::destroyArray(ary);
        
}
    
    static njli::SteeringBehaviorCohesion *SteeringBehaviorCohesion_getitem(njli::SteeringBehaviorCohesion **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SteeringBehaviorCohesion_setitem(njli::SteeringBehaviorCohesion **ary, int index, njli::SteeringBehaviorCohesion *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SteeringBehaviorCohesionBuilder **new_SteeringBehaviorCohesionBuilder(int nelements) { 

        return njli::SteeringBehaviorCohesionBuilder::createArray(nelements);
        
}
    
    static void delete_SteeringBehaviorCohesionBuilder(njli::SteeringBehaviorCohesionBuilder **ary) { 

        njli::SteeringBehaviorCohesionBuilder::destroyArray(ary);
        
}
    
    static njli::SteeringBehaviorCohesionBuilder *SteeringBehaviorCohesionBuilder_getitem(njli::SteeringBehaviorCohesionBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SteeringBehaviorCohesionBuilder_setitem(njli::SteeringBehaviorCohesionBuilder **ary, int index, njli::SteeringBehaviorCohesionBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SteeringBehaviorEvade **new_SteeringBehaviorEvade(int nelements) { 

        return njli::SteeringBehaviorEvade::createArray(nelements);
        
}
    
    static void delete_SteeringBehaviorEvade(njli::SteeringBehaviorEvade **ary) { 

        njli::SteeringBehaviorEvade::destroyArray(ary);
        
}
    
    static njli::SteeringBehaviorEvade *SteeringBehaviorEvade_getitem(njli::SteeringBehaviorEvade **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SteeringBehaviorEvade_setitem(njli::SteeringBehaviorEvade **ary, int index, njli::SteeringBehaviorEvade *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SteeringBehaviorEvadeBuilder **new_SteeringBehaviorEvadeBuilder(int nelements) { 

        return njli::SteeringBehaviorEvadeBuilder::createArray(nelements);
        
}
    
    static void delete_SteeringBehaviorEvadeBuilder(njli::SteeringBehaviorEvadeBuilder **ary) { 

        njli::SteeringBehaviorEvadeBuilder::destroyArray(ary);
        
}
    
    static njli::SteeringBehaviorEvadeBuilder *SteeringBehaviorEvadeBuilder_getitem(njli::SteeringBehaviorEvadeBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SteeringBehaviorEvadeBuilder_setitem(njli::SteeringBehaviorEvadeBuilder **ary, int index, njli::SteeringBehaviorEvadeBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SteeringBehaviorFlee **new_SteeringBehaviorFlee(int nelements) { 

        return njli::SteeringBehaviorFlee::createArray(nelements);
        
}
    
    static void delete_SteeringBehaviorFlee(njli::SteeringBehaviorFlee **ary) { 

        njli::SteeringBehaviorFlee::destroyArray(ary);
        
}
    
    static njli::SteeringBehaviorFlee *SteeringBehaviorFlee_getitem(njli::SteeringBehaviorFlee **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SteeringBehaviorFlee_setitem(njli::SteeringBehaviorFlee **ary, int index, njli::SteeringBehaviorFlee *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SteeringBehaviorFleeBuilder **new_SteeringBehaviorFleeBuilder(int nelements) { 

        return njli::SteeringBehaviorFleeBuilder::createArray(nelements);
        
}
    
    static void delete_SteeringBehaviorFleeBuilder(njli::SteeringBehaviorFleeBuilder **ary) { 

        njli::SteeringBehaviorFleeBuilder::destroyArray(ary);
        
}
    
    static njli::SteeringBehaviorFleeBuilder *SteeringBehaviorFleeBuilder_getitem(njli::SteeringBehaviorFleeBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SteeringBehaviorFleeBuilder_setitem(njli::SteeringBehaviorFleeBuilder **ary, int index, njli::SteeringBehaviorFleeBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SteeringBehaviorFollowPath **new_SteeringBehaviorFollowPath(int nelements) { 

        return njli::SteeringBehaviorFollowPath::createArray(nelements);
        
}
    
    static void delete_SteeringBehaviorFollowPath(njli::SteeringBehaviorFollowPath **ary) { 

        njli::SteeringBehaviorFollowPath::destroyArray(ary);
        
}
    
    static njli::SteeringBehaviorFollowPath *SteeringBehaviorFollowPath_getitem(njli::SteeringBehaviorFollowPath **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SteeringBehaviorFollowPath_setitem(njli::SteeringBehaviorFollowPath **ary, int index, njli::SteeringBehaviorFollowPath *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SteeringBehaviorFollowPathBuilder **new_SteeringBehaviorFollowPathBuilder(int nelements) { 

        return njli::SteeringBehaviorFollowPathBuilder::createArray(nelements);
        
}
    
    static void delete_SteeringBehaviorFollowPathBuilder(njli::SteeringBehaviorFollowPathBuilder **ary) { 

        njli::SteeringBehaviorFollowPathBuilder::destroyArray(ary);
        
}
    
    static njli::SteeringBehaviorFollowPathBuilder *SteeringBehaviorFollowPathBuilder_getitem(njli::SteeringBehaviorFollowPathBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SteeringBehaviorFollowPathBuilder_setitem(njli::SteeringBehaviorFollowPathBuilder **ary, int index, njli::SteeringBehaviorFollowPathBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SteeringBehaviorHide **new_SteeringBehaviorHide(int nelements) { 

        return njli::SteeringBehaviorHide::createArray(nelements);
        
}
    
    static void delete_SteeringBehaviorHide(njli::SteeringBehaviorHide **ary) { 

        njli::SteeringBehaviorHide::destroyArray(ary);
        
}
    
    static njli::SteeringBehaviorHide *SteeringBehaviorHide_getitem(njli::SteeringBehaviorHide **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SteeringBehaviorHide_setitem(njli::SteeringBehaviorHide **ary, int index, njli::SteeringBehaviorHide *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SteeringBehaviorHideBuilder **new_SteeringBehaviorHideBuilder(int nelements) { 

        return njli::SteeringBehaviorHideBuilder::createArray(nelements);
        
}
    
    static void delete_SteeringBehaviorHideBuilder(njli::SteeringBehaviorHideBuilder **ary) { 

        njli::SteeringBehaviorHideBuilder::destroyArray(ary);
        
}
    
    static njli::SteeringBehaviorHideBuilder *SteeringBehaviorHideBuilder_getitem(njli::SteeringBehaviorHideBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SteeringBehaviorHideBuilder_setitem(njli::SteeringBehaviorHideBuilder **ary, int index, njli::SteeringBehaviorHideBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SteeringBehaviorInterpose **new_SteeringBehaviorInterpose(int nelements) { 

        return njli::SteeringBehaviorInterpose::createArray(nelements);
        
}
    
    static void delete_SteeringBehaviorInterpose(njli::SteeringBehaviorInterpose **ary) { 

        njli::SteeringBehaviorInterpose::destroyArray(ary);
        
}
    
    static njli::SteeringBehaviorInterpose *SteeringBehaviorInterpose_getitem(njli::SteeringBehaviorInterpose **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SteeringBehaviorInterpose_setitem(njli::SteeringBehaviorInterpose **ary, int index, njli::SteeringBehaviorInterpose *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SteeringBehaviorInterposeBuilder **new_SteeringBehaviorInterposeBuilder(int nelements) { 

        return njli::SteeringBehaviorInterposeBuilder::createArray(nelements);
        
}
    
    static void delete_SteeringBehaviorInterposeBuilder(njli::SteeringBehaviorInterposeBuilder **ary) { 

        njli::SteeringBehaviorInterposeBuilder::destroyArray(ary);
        
}
    
    static njli::SteeringBehaviorInterposeBuilder *SteeringBehaviorInterposeBuilder_getitem(njli::SteeringBehaviorInterposeBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SteeringBehaviorInterposeBuilder_setitem(njli::SteeringBehaviorInterposeBuilder **ary, int index, njli::SteeringBehaviorInterposeBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SteeringBehaviorMachineDithered **new_SteeringBehaviorMachineDithered(int nelements) { 

        return njli::SteeringBehaviorMachineDithered::createArray(nelements);
        
}
    
    static void delete_SteeringBehaviorMachineDithered(njli::SteeringBehaviorMachineDithered **ary) { 

        njli::SteeringBehaviorMachineDithered::destroyArray(ary);
        
}
    
    static njli::SteeringBehaviorMachineDithered *SteeringBehaviorMachineDithered_getitem(njli::SteeringBehaviorMachineDithered **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SteeringBehaviorMachineDithered_setitem(njli::SteeringBehaviorMachineDithered **ary, int index, njli::SteeringBehaviorMachineDithered *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SteeringBehaviorMachineDitheredBuilder **new_SteeringBehaviorMachineDitheredBuilder(int nelements) { 

        return njli::SteeringBehaviorMachineDitheredBuilder::createArray(nelements);
        
}
    
    static void delete_SteeringBehaviorMachineDitheredBuilder(njli::SteeringBehaviorMachineDitheredBuilder **ary) { 

        njli::SteeringBehaviorMachineDitheredBuilder::destroyArray(ary);
        
}
    
    static njli::SteeringBehaviorMachineDitheredBuilder *SteeringBehaviorMachineDitheredBuilder_getitem(njli::SteeringBehaviorMachineDitheredBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SteeringBehaviorMachineDitheredBuilder_setitem(njli::SteeringBehaviorMachineDitheredBuilder **ary, int index, njli::SteeringBehaviorMachineDitheredBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SteeringBehaviorMachinePrioritized **new_SteeringBehaviorMachinePrioritized(int nelements) { 

        return njli::SteeringBehaviorMachinePrioritized::createArray(nelements);
        
}
    
    static void delete_SteeringBehaviorMachinePrioritized(njli::SteeringBehaviorMachinePrioritized **ary) { 

        njli::SteeringBehaviorMachinePrioritized::destroyArray(ary);
        
}
    
    static njli::SteeringBehaviorMachinePrioritized *SteeringBehaviorMachinePrioritized_getitem(njli::SteeringBehaviorMachinePrioritized **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SteeringBehaviorMachinePrioritized_setitem(njli::SteeringBehaviorMachinePrioritized **ary, int index, njli::SteeringBehaviorMachinePrioritized *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SteeringBehaviorMachinePrioritizedBuilder **new_SteeringBehaviorMachinePrioritizedBuilder(int nelements) { 

        return njli::SteeringBehaviorMachinePrioritizedBuilder::createArray(nelements);
        
}
    
    static void delete_SteeringBehaviorMachinePrioritizedBuilder(njli::SteeringBehaviorMachinePrioritizedBuilder **ary) { 

        njli::SteeringBehaviorMachinePrioritizedBuilder::destroyArray(ary);
        
}
    
    static njli::SteeringBehaviorMachinePrioritizedBuilder *SteeringBehaviorMachinePrioritizedBuilder_getitem(njli::SteeringBehaviorMachinePrioritizedBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SteeringBehaviorMachinePrioritizedBuilder_setitem(njli::SteeringBehaviorMachinePrioritizedBuilder **ary, int index, njli::SteeringBehaviorMachinePrioritizedBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SteeringBehaviorMachineWeighted **new_SteeringBehaviorMachineWeighted(int nelements) { 

        return njli::SteeringBehaviorMachineWeighted::createArray(nelements);
        
}
    
    static void delete_SteeringBehaviorMachineWeighted(njli::SteeringBehaviorMachineWeighted **ary) { 

        njli::SteeringBehaviorMachineWeighted::destroyArray(ary);
        
}
    
    static njli::SteeringBehaviorMachineWeighted *SteeringBehaviorMachineWeighted_getitem(njli::SteeringBehaviorMachineWeighted **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SteeringBehaviorMachineWeighted_setitem(njli::SteeringBehaviorMachineWeighted **ary, int index, njli::SteeringBehaviorMachineWeighted *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SteeringBehaviorMachineWeightedBuilder **new_SteeringBehaviorMachineWeightedBuilder(int nelements) { 

        return njli::SteeringBehaviorMachineWeightedBuilder::createArray(nelements);
        
}
    
    static void delete_SteeringBehaviorMachineWeightedBuilder(njli::SteeringBehaviorMachineWeightedBuilder **ary) { 

        njli::SteeringBehaviorMachineWeightedBuilder::destroyArray(ary);
        
}
    
    static njli::SteeringBehaviorMachineWeightedBuilder *SteeringBehaviorMachineWeightedBuilder_getitem(njli::SteeringBehaviorMachineWeightedBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SteeringBehaviorMachineWeightedBuilder_setitem(njli::SteeringBehaviorMachineWeightedBuilder **ary, int index, njli::SteeringBehaviorMachineWeightedBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SteeringBehaviorObstacleAvoidance **new_SteeringBehaviorObstacleAvoidance(int nelements) { 

        return njli::SteeringBehaviorObstacleAvoidance::createArray(nelements);
        
}
    
    static void delete_SteeringBehaviorObstacleAvoidance(njli::SteeringBehaviorObstacleAvoidance **ary) { 

        njli::SteeringBehaviorObstacleAvoidance::destroyArray(ary);
        
}
    
    static njli::SteeringBehaviorObstacleAvoidance *SteeringBehaviorObstacleAvoidance_getitem(njli::SteeringBehaviorObstacleAvoidance **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SteeringBehaviorObstacleAvoidance_setitem(njli::SteeringBehaviorObstacleAvoidance **ary, int index, njli::SteeringBehaviorObstacleAvoidance *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SteeringBehaviorObstacleAvoidanceBuilder **new_SteeringBehaviorObstacleAvoidanceBuilder(int nelements) { 

        return njli::SteeringBehaviorObstacleAvoidanceBuilder::createArray(nelements);
        
}
    
    static void delete_SteeringBehaviorObstacleAvoidanceBuilder(njli::SteeringBehaviorObstacleAvoidanceBuilder **ary) { 

        njli::SteeringBehaviorObstacleAvoidanceBuilder::destroyArray(ary);
        
}
    
    static njli::SteeringBehaviorObstacleAvoidanceBuilder *SteeringBehaviorObstacleAvoidanceBuilder_getitem(njli::SteeringBehaviorObstacleAvoidanceBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SteeringBehaviorObstacleAvoidanceBuilder_setitem(njli::SteeringBehaviorObstacleAvoidanceBuilder **ary, int index, njli::SteeringBehaviorObstacleAvoidanceBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SteeringBehaviorOffsetPursuit **new_SteeringBehaviorOffsetPursuit(int nelements) { 

        return njli::SteeringBehaviorOffsetPursuit::createArray(nelements);
        
}
    
    static void delete_SteeringBehaviorOffsetPursuit(njli::SteeringBehaviorOffsetPursuit **ary) { 

        njli::SteeringBehaviorOffsetPursuit::destroyArray(ary);
        
}
    
    static njli::SteeringBehaviorOffsetPursuit *SteeringBehaviorOffsetPursuit_getitem(njli::SteeringBehaviorOffsetPursuit **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SteeringBehaviorOffsetPursuit_setitem(njli::SteeringBehaviorOffsetPursuit **ary, int index, njli::SteeringBehaviorOffsetPursuit *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SteeringBehaviorOffsetPursuitBuilder **new_SteeringBehaviorOffsetPursuitBuilder(int nelements) { 

        return njli::SteeringBehaviorOffsetPursuitBuilder::createArray(nelements);
        
}
    
    static void delete_SteeringBehaviorOffsetPursuitBuilder(njli::SteeringBehaviorOffsetPursuitBuilder **ary) { 

        njli::SteeringBehaviorOffsetPursuitBuilder::destroyArray(ary);
        
}
    
    static njli::SteeringBehaviorOffsetPursuitBuilder *SteeringBehaviorOffsetPursuitBuilder_getitem(njli::SteeringBehaviorOffsetPursuitBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SteeringBehaviorOffsetPursuitBuilder_setitem(njli::SteeringBehaviorOffsetPursuitBuilder **ary, int index, njli::SteeringBehaviorOffsetPursuitBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SteeringBehaviorPursuit **new_SteeringBehaviorPursuit(int nelements) { 

        return njli::SteeringBehaviorPursuit::createArray(nelements);
        
}
    
    static void delete_SteeringBehaviorPursuit(njli::SteeringBehaviorPursuit **ary) { 

        njli::SteeringBehaviorPursuit::destroyArray(ary);
        
}
    
    static njli::SteeringBehaviorPursuit *SteeringBehaviorPursuit_getitem(njli::SteeringBehaviorPursuit **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SteeringBehaviorPursuit_setitem(njli::SteeringBehaviorPursuit **ary, int index, njli::SteeringBehaviorPursuit *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SteeringBehaviorPursuitBuilder **new_SteeringBehaviorPursuitBuilder(int nelements) { 

        return njli::SteeringBehaviorPursuitBuilder::createArray(nelements);
        
}
    
    static void delete_SteeringBehaviorPursuitBuilder(njli::SteeringBehaviorPursuitBuilder **ary) { 

        njli::SteeringBehaviorPursuitBuilder::destroyArray(ary);
        
}
    
    static njli::SteeringBehaviorPursuitBuilder *SteeringBehaviorPursuitBuilder_getitem(njli::SteeringBehaviorPursuitBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SteeringBehaviorPursuitBuilder_setitem(njli::SteeringBehaviorPursuitBuilder **ary, int index, njli::SteeringBehaviorPursuitBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SteeringBehaviorSeek **new_SteeringBehaviorSeek(int nelements) { 

        return njli::SteeringBehaviorSeek::createArray(nelements);
        
}
    
    static void delete_SteeringBehaviorSeek(njli::SteeringBehaviorSeek **ary) { 

        njli::SteeringBehaviorSeek::destroyArray(ary);
        
}
    
    static njli::SteeringBehaviorSeek *SteeringBehaviorSeek_getitem(njli::SteeringBehaviorSeek **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SteeringBehaviorSeek_setitem(njli::SteeringBehaviorSeek **ary, int index, njli::SteeringBehaviorSeek *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SteeringBehaviorSeekBuilder **new_SteeringBehaviorSeekBuilder(int nelements) { 

        return njli::SteeringBehaviorSeekBuilder::createArray(nelements);
        
}
    
    static void delete_SteeringBehaviorSeekBuilder(njli::SteeringBehaviorSeekBuilder **ary) { 

        njli::SteeringBehaviorSeekBuilder::destroyArray(ary);
        
}
    
    static njli::SteeringBehaviorSeekBuilder *SteeringBehaviorSeekBuilder_getitem(njli::SteeringBehaviorSeekBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SteeringBehaviorSeekBuilder_setitem(njli::SteeringBehaviorSeekBuilder **ary, int index, njli::SteeringBehaviorSeekBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SteeringBehaviorSeparation **new_SteeringBehaviorSeparation(int nelements) { 

        return njli::SteeringBehaviorSeparation::createArray(nelements);
        
}
    
    static void delete_SteeringBehaviorSeparation(njli::SteeringBehaviorSeparation **ary) { 

        njli::SteeringBehaviorSeparation::destroyArray(ary);
        
}
    
    static njli::SteeringBehaviorSeparation *SteeringBehaviorSeparation_getitem(njli::SteeringBehaviorSeparation **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SteeringBehaviorSeparation_setitem(njli::SteeringBehaviorSeparation **ary, int index, njli::SteeringBehaviorSeparation *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SteeringBehaviorSeparationBuilder **new_SteeringBehaviorSeparationBuilder(int nelements) { 

        return njli::SteeringBehaviorSeparationBuilder::createArray(nelements);
        
}
    
    static void delete_SteeringBehaviorSeparationBuilder(njli::SteeringBehaviorSeparationBuilder **ary) { 

        njli::SteeringBehaviorSeparationBuilder::destroyArray(ary);
        
}
    
    static njli::SteeringBehaviorSeparationBuilder *SteeringBehaviorSeparationBuilder_getitem(njli::SteeringBehaviorSeparationBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SteeringBehaviorSeparationBuilder_setitem(njli::SteeringBehaviorSeparationBuilder **ary, int index, njli::SteeringBehaviorSeparationBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SteeringBehaviorWallAvoidance **new_SteeringBehaviorWallAvoidance(int nelements) { 

        return njli::SteeringBehaviorWallAvoidance::createArray(nelements);
        
}
    
    static void delete_SteeringBehaviorWallAvoidance(njli::SteeringBehaviorWallAvoidance **ary) { 

        njli::SteeringBehaviorWallAvoidance::destroyArray(ary);
        
}
    
    static njli::SteeringBehaviorWallAvoidance *SteeringBehaviorWallAvoidance_getitem(njli::SteeringBehaviorWallAvoidance **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SteeringBehaviorWallAvoidance_setitem(njli::SteeringBehaviorWallAvoidance **ary, int index, njli::SteeringBehaviorWallAvoidance *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SteeringBehaviorWallAvoidanceBuilder **new_SteeringBehaviorWallAvoidanceBuilder(int nelements) { 

        return njli::SteeringBehaviorWallAvoidanceBuilder::createArray(nelements);
        
}
    
    static void delete_SteeringBehaviorWallAvoidanceBuilder(njli::SteeringBehaviorWallAvoidanceBuilder **ary) { 

        njli::SteeringBehaviorWallAvoidanceBuilder::destroyArray(ary);
        
}
    
    static njli::SteeringBehaviorWallAvoidanceBuilder *SteeringBehaviorWallAvoidanceBuilder_getitem(njli::SteeringBehaviorWallAvoidanceBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SteeringBehaviorWallAvoidanceBuilder_setitem(njli::SteeringBehaviorWallAvoidanceBuilder **ary, int index, njli::SteeringBehaviorWallAvoidanceBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SteeringBehaviorWander **new_SteeringBehaviorWander(int nelements) { 

        return njli::SteeringBehaviorWander::createArray(nelements);
        
}
    
    static void delete_SteeringBehaviorWander(njli::SteeringBehaviorWander **ary) { 

        njli::SteeringBehaviorWander::destroyArray(ary);
        
}
    
    static njli::SteeringBehaviorWander *SteeringBehaviorWander_getitem(njli::SteeringBehaviorWander **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SteeringBehaviorWander_setitem(njli::SteeringBehaviorWander **ary, int index, njli::SteeringBehaviorWander *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SteeringBehaviorWanderBuilder **new_SteeringBehaviorWanderBuilder(int nelements) { 

        return njli::SteeringBehaviorWanderBuilder::createArray(nelements);
        
}
    
    static void delete_SteeringBehaviorWanderBuilder(njli::SteeringBehaviorWanderBuilder **ary) { 

        njli::SteeringBehaviorWanderBuilder::destroyArray(ary);
        
}
    
    static njli::SteeringBehaviorWanderBuilder *SteeringBehaviorWanderBuilder_getitem(njli::SteeringBehaviorWanderBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SteeringBehaviorWanderBuilder_setitem(njli::SteeringBehaviorWanderBuilder **ary, int index, njli::SteeringBehaviorWanderBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::StopWatch **new_StopWatchArray(int nelements) { 

        return njli::StopWatch::createArray(nelements);
        
}
    
    static void delete_StopWatchArray(njli::StopWatch **ary) { 

        njli::StopWatch::destroyArray(ary);
        
}
    
    static njli::StopWatch *StopWatchArray_getitem(njli::StopWatch **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void StopWatchArray_setitem(njli::StopWatch **ary, int index, njli::StopWatch *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::StopWatchBuilder **new_StopWatchBuilderArray(int nelements) { 

        return njli::StopWatchBuilder::createArray(nelements);
        
}
    
    static void delete_StopWatchBuilderArray(njli::StopWatchBuilder **ary) { 

        njli::StopWatchBuilder::destroyArray(ary);
        
}
    
    static njli::StopWatchBuilder *StopWatchBuilderArray_getitem(njli::StopWatchBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void StopWatchBuilderArray_setitem(njli::StopWatchBuilder **ary, int index, njli::StopWatchBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::Timer **new_TimerArray(int nelements) { 

        return njli::Timer::createArray(nelements);
        
}
    
    static void delete_TimerArray(njli::Timer **ary) { 

        njli::Timer::destroyArray(ary);
        
}
    
    static njli::Timer *TimerArray_getitem(njli::Timer **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void TimerArray_setitem(njli::Timer **ary, int index, njli::Timer *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::TimerBuilder **new_TimerBuilderArray(int nelements) { 

        return njli::TimerBuilder::createArray(nelements);
        
}
    
    static void delete_TimerBuilderArray(njli::TimerBuilder **ary) { 

        njli::TimerBuilder::destroyArray(ary);
        
}
    
    static njli::TimerBuilder *TimerBuilderArray_getitem(njli::TimerBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void TimerBuilderArray_setitem(njli::TimerBuilder **ary, int index, njli::TimerBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::ButtonHUD **new_ButtonHUDArray(int nelements) { 

        return njli::ButtonHUD::createArray(nelements);
        
}
    
    static void delete_ButtonHUDArray(njli::ButtonHUD **ary) { 

        njli::ButtonHUD::destroyArray(ary);
        
}
    
    static njli::ButtonHUD *ButtonHUDArray_getitem(njli::ButtonHUD **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void ButtonHUDArray_setitem(njli::ButtonHUD **ary, int index, njli::ButtonHUD *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::ButtonHUDBuilder **new_ButtonHUDBuilderArray(int nelements) { 

        return njli::ButtonHUDBuilder::createArray(nelements);
        
}
    
    static void delete_ButtonHUDBuilderArray(njli::ButtonHUDBuilder **ary) { 

        njli::ButtonHUDBuilder::destroyArray(ary);
        
}
    
    static njli::ButtonHUDBuilder *ButtonHUDBuilderArray_getitem(njli::ButtonHUDBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void ButtonHUDBuilderArray_setitem(njli::ButtonHUDBuilder **ary, int index, njli::ButtonHUDBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::CheckboxHUD **new_CheckboxHUDArray(int nelements) { 

        return njli::CheckboxHUD::createArray(nelements);
        
}
    
    static void delete_CheckboxHUDArray(njli::CheckboxHUD **ary) { 

        njli::CheckboxHUD::destroyArray(ary);
        
}
    
    static njli::CheckboxHUD *CheckboxHUDArray_getitem(njli::CheckboxHUD **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void CheckboxHUDArray_setitem(njli::CheckboxHUD **ary, int index, njli::CheckboxHUD *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::CheckboxHUDBuilder **new_CheckboxHUDBuilderArray(int nelements) { 

        return njli::CheckboxHUDBuilder::createArray(nelements);
        
}
    
    static void delete_CheckboxHUDBuilderArray(njli::CheckboxHUDBuilder **ary) { 

        njli::CheckboxHUDBuilder::destroyArray(ary);
        
}
    
    static njli::CheckboxHUDBuilder *CheckboxHUDBuilderArray_getitem(njli::CheckboxHUDBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void CheckboxHUDBuilderArray_setitem(njli::CheckboxHUDBuilder **ary, int index, njli::CheckboxHUDBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::DropdownHUD **new_DropdownHUDArray(int nelements) { 

        return njli::DropdownHUD::createArray(nelements);
        
}
    
    static void delete_DropdownHUDArray(njli::DropdownHUD **ary) { 

        njli::DropdownHUD::destroyArray(ary);
        
}
    
    static njli::DropdownHUD *DropdownHUDArray_getitem(njli::DropdownHUD **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void DropdownHUDArray_setitem(njli::DropdownHUD **ary, int index, njli::DropdownHUD *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::DropdownHUDBuilder **new_DropdownHUDBuilderArray(int nelements) { 

        return njli::DropdownHUDBuilder::createArray(nelements);
        
}
    
    static void delete_DropdownHUDBuilderArray(njli::DropdownHUDBuilder **ary) { 

        njli::DropdownHUDBuilder::destroyArray(ary);
        
}
    
    static njli::DropdownHUDBuilder *DropdownHUDBuilderArray_getitem(njli::DropdownHUDBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void DropdownHUDBuilderArray_setitem(njli::DropdownHUDBuilder **ary, int index, njli::DropdownHUDBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::LabelHUD **new_LabelHUDArray(int nelements) { 

        return njli::LabelHUD::createArray(nelements);
        
}
    
    static void delete_LabelHUDArray(njli::LabelHUD **ary) { 

        njli::LabelHUD::destroyArray(ary);
        
}
    
    static njli::LabelHUD *LabelHUDArray_getitem(njli::LabelHUD **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void LabelHUDArray_setitem(njli::LabelHUD **ary, int index, njli::LabelHUD *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::LabelHUDBuilder **new_LabelHUDBuilderArray(int nelements) { 

        return njli::LabelHUDBuilder::createArray(nelements);
        
}
    
    static void delete_LabelHUDBuilderArray(njli::LabelHUDBuilder **ary) { 

        njli::LabelHUDBuilder::destroyArray(ary);
        
}
    
    static njli::LabelHUDBuilder *LabelHUDBuilderArray_getitem(njli::LabelHUDBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void LabelHUDBuilderArray_setitem(njli::LabelHUDBuilder **ary, int index, njli::LabelHUDBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SliderHUD **new_SliderHUDArray(int nelements) { 

        return njli::SliderHUD::createArray(nelements);
        
}
    
    static void delete_SliderHUDArray(njli::SliderHUD **ary) { 

        njli::SliderHUD::destroyArray(ary);
        
}
    
    static njli::SliderHUD *SliderHUDArray_getitem(njli::SliderHUD **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SliderHUDArray_setitem(njli::SliderHUD **ary, int index, njli::SliderHUD *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::SliderHUDBuilder **new_SliderHUDBuilderArray(int nelements) { 

        return njli::SliderHUDBuilder::createArray(nelements);
        
}
    
    static void delete_SliderHUDBuilderArray(njli::SliderHUDBuilder **ary) { 

        njli::SliderHUDBuilder::destroyArray(ary);
        
}
    
    static njli::SliderHUDBuilder *SliderHUDBuilderArray_getitem(njli::SliderHUDBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void SliderHUDBuilderArray_setitem(njli::SliderHUDBuilder **ary, int index, njli::SliderHUDBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::TextboxHUD **new_TextboxHUDArray(int nelements) { 

        return njli::TextboxHUD::createArray(nelements);
        
}
    
    static void delete_TextboxHUDArray(njli::TextboxHUD **ary) { 

        njli::TextboxHUD::destroyArray(ary);
        
}
    
    static njli::TextboxHUD *TextboxHUDArray_getitem(njli::TextboxHUD **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void TextboxHUDArray_setitem(njli::TextboxHUD **ary, int index, njli::TextboxHUD *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::TextboxHUDBuilder **new_TextboxHUDBuilderArray(int nelements) { 

        return njli::TextboxHUDBuilder::createArray(nelements);
        
}
    
    static void delete_TextboxHUDBuilderArray(njli::TextboxHUDBuilder **ary) { 

        njli::TextboxHUDBuilder::destroyArray(ary);
        
}
    
    static njli::TextboxHUDBuilder *TextboxHUDBuilderArray_getitem(njli::TextboxHUDBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void TextboxHUDBuilderArray_setitem(njli::TextboxHUDBuilder **ary, int index, njli::TextboxHUDBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::WorldState **new_WorldStateArray(int nelements) { 

        return njli::WorldState::createArray(nelements);
        
}
    
    static void delete_WorldStateArray(njli::WorldState **ary) { 

        njli::WorldState::destroyArray(ary);
        
}
    
    static njli::WorldState *WorldStateArray_getitem(njli::WorldState **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void WorldStateArray_setitem(njli::WorldState **ary, int index, njli::WorldState *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::WorldStateBuilder **new_WorldStateBuilderArray(int nelements) { 

        return njli::WorldStateBuilder::createArray(nelements);
        
}
    
    static void delete_WorldStateBuilderArray(njli::WorldStateBuilder **ary) { 

        njli::WorldStateBuilder::destroyArray(ary);
        
}
    
    static njli::WorldStateBuilder *WorldStateBuilderArray_getitem(njli::WorldStateBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void WorldStateBuilderArray_setitem(njli::WorldStateBuilder **ary, int index, njli::WorldStateBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::WorldStateMachine **new_WorldStateMachineArray(int nelements) { 

        return njli::WorldStateMachine::createArray(nelements);
        
}
    
    static void delete_WorldStateMachineArray(njli::WorldStateMachine **ary) { 

        njli::WorldStateMachine::destroyArray(ary);
        
}
    
    static njli::WorldStateMachine *WorldStateMachineArray_getitem(njli::WorldStateMachine **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void WorldStateMachineArray_setitem(njli::WorldStateMachine **ary, int index, njli::WorldStateMachine *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::WorldStateMachineBuilder **new_WorldStateMachineBuilderArray(int nelements) { 

        return njli::WorldStateMachineBuilder::createArray(nelements);
        
}
    
    static void delete_WorldStateMachineBuilderArray(njli::WorldStateMachineBuilder **ary) { 

        njli::WorldStateMachineBuilder::destroyArray(ary);
        
}
    
    static njli::WorldStateMachineBuilder *WorldStateMachineBuilderArray_getitem(njli::WorldStateMachineBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void WorldStateMachineBuilderArray_setitem(njli::WorldStateMachineBuilder **ary, int index, njli::WorldStateMachineBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::Xml **new_XmlArray(int nelements) { 

        return njli::Xml::createArray(nelements);
        
}
    
    static void delete_XmlArray(njli::Xml **ary) { 

        njli::Xml::destroyArray(ary);
        
}
    
    static njli::Xml *XmlArray_getitem(njli::Xml **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void XmlArray_setitem(njli::Xml **ary, int index, njli::Xml *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    

    static njli::XmlBuilder **new_XmlBuilderArray(int nelements) { 

        return njli::XmlBuilder::createArray(nelements);
        
}
    
    static void delete_XmlBuilderArray(njli::XmlBuilder **ary) { 

        njli::XmlBuilder::destroyArray(ary);
        
}
    
    static njli::XmlBuilder *XmlBuilderArray_getitem(njli::XmlBuilder **ary, int index) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        return ary[index-1];
    }
    static void XmlBuilderArray_setitem(njli::XmlBuilder **ary, int index, njli::XmlBuilder *value) {
           do                                                                                {                                                                                    do                                                                                {                                                                                 char string[3584];                                                              snprintf(string, (3584 - 1), "%s","index must be greater than zero.");                                      if (((index > 0)) == ASSERT_FAIL)                                                   {                                                                                 SDL_LogError(SDL_LOG_CATEGORY_TEST, "Assert '%s': %s", string,                               "Failed");                                                       }                                                                             else                                                                              {                                                                                              }                                                                           }                                                                             while (0);                                      SDL_assert((index > 0));                                                      }                                                                             while (0);
        ary[index-1] = value;
    }
    
EMSCRIPTEN_BINDINGS(njli) {
	.constructor<int>()
	.constructor<int>()
	.function("getObjectType", &btTypedObject::getObjectType)
	.constructor<r.q(const).btScalar,r.q(const).btScalar,r.q(const).btScalar>()
	.function("operator +=", &btVector3::operator +=)
	.function("operator -=", &btVector3::operator -=)
	.function("operator *=_r.q(const).btScalar", select_overload<btVector3(r.q(const).btScalar)>(&btVector3::operator *=))
	.function("operator /=", &btVector3::operator /=)
	.function("length2", &btVector3::length2)
	.function("length", &btVector3::length)
	.function("norm", &btVector3::norm)
	.function("safeNorm", &btVector3::safeNorm)
	.function("distance2", &btVector3::distance2)
	.function("distance", &btVector3::distance)
	.function("safeNormalize", &btVector3::safeNormalize)
	.function("normalize", &btVector3::normalize)
	.function("normalized", &btVector3::normalized)
	.function("rotate", &btVector3::rotate)
	.function("angle", &btVector3::angle)
	.function("absolute", &btVector3::absolute)
	.function("cross", &btVector3::cross)
	.function("triple", &btVector3::triple)
	.function("minAxis", &btVector3::minAxis)
	.function("maxAxis", &btVector3::maxAxis)
	.function("furthestAxis", &btVector3::furthestAxis)
	.function("closestAxis", &btVector3::closestAxis)
	.function("setInterpolate3", &btVector3::setInterpolate3)
	.function("lerp", &btVector3::lerp)
	.function("operator *=_r.q(const).btVector3", select_overload<btVector3(r.q(const).btVector3)>(&btVector3::operator *=))
	.function("getX", &btVector3::getX)
	.function("getY", &btVector3::getY)
	.function("getZ", &btVector3::getZ)
	.function("setX", &btVector3::setX)
	.function("setY", &btVector3::setY)
	.function("setZ", &btVector3::setZ)
	.function("setW", &btVector3::setW)
	.function("x", &btVector3::x)
	.function("y", &btVector3::y)
	.function("z", &btVector3::z)
	.function("w", &btVector3::w)
	.function("operator btScalar*", &btVector3::operator btScalar*)
	.function("operator const btScalar*", &btVector3::operator const btScalar*)
	.function("operator ==", &btVector3::operator ==)
	.function("operator !=", &btVector3::operator !=)
	.function("setMax", &btVector3::setMax)
	.function("setMin", &btVector3::setMin)
	.function("setValue", &btVector3::setValue)
	.function("getSkewSymmetricMatrix", &btVector3::getSkewSymmetricMatrix)
	.function("setZero", &btVector3::setZero)
	.function("isZero", &btVector3::isZero)
	.function("fuzzyZero", &btVector3::fuzzyZero)
	.function("serialize", &btVector3::serialize)
	.function("deSerialize", &btVector3::deSerialize)
	.function("serializeFloat", &btVector3::serializeFloat)
	.function("deSerializeFloat", &btVector3::deSerializeFloat)
	.function("serializeDouble", &btVector3::serializeDouble)
	.function("deSerializeDouble", &btVector3::deSerializeDouble)
	.function("maxDot", &btVector3::maxDot)
	.function("minDot", &btVector3::minDot)
	.function("dot3", &btVector3::dot3)
	.constructor<r.q(const).btScalar,r.q(const).btScalar,r.q(const).btScalar,r.q(const).btScalar>()
	.function("absolute4", &btVector4::absolute4)
	.function("getW", &btVector4::getW)
	.function("maxAxis4", &btVector4::maxAxis4)
	.function("minAxis4", &btVector4::minAxis4)
	.function("closestAxis4", &btVector4::closestAxis4)
	.function("setValue", &btVector4::setValue)
	.constructor<r.q(const).btScalar,r.q(const).btScalar>()
	.constructor<r.q(const).btVector2>()
	.constructor<r.q(const).btVector3>()
	.function("operator btVector3", &btVector2::operator btVector3)
	.function("operator const btScalar*", &btVector2::operator const btScalar*)
	.function("x", &btVector2::x)
	.function("y", &btVector2::y)
	.function("setX", &btVector2::setX)
	.function("setY", &btVector2::setY)
	.function("operator =", &btVector2::operator =)
	.function("operator +=", &btVector2::operator +=)
	.function("operator -=", &btVector2::operator -=)
	.function("operator *=_r.q(const).btVector2", select_overload<btVector2(r.q(const).btVector2)>(&btVector2::operator *=))
	.function("operator *=_r.q(const).btScalar", select_overload<btVector2(r.q(const).btScalar)>(&btVector2::operator *=))
	.function("operator /=", &btVector2::operator /=)
	.function("length2", &btVector2::length2)
	.function("length", &btVector2::length)
	.function("distance2", &btVector2::distance2)
	.function("distance", &btVector2::distance)
	.function("normalize", &btVector2::normalize)
	.function("normalized", &btVector2::normalized)
	.function("rotate", &btVector2::rotate)
	.function("rotated", &btVector2::rotated)
	.function("absolute", &btVector2::absolute)
	.function("angle", &btVector2::angle)
	.function("serializeFloat", &btVector2::serializeFloat)
	.function("deSerializeFloat", &btVector2::deSerializeFloat)
	.function("serializeDouble", &btVector2::serializeDouble)
	.function("deSerializeDouble", &btVector2::deSerializeDouble)
	.function("serialize", &btVector2::serialize)
	.function("deSerialize", &btVector2::deSerialize)
	enum_<BroadphaseNativeTypes>("BroadphaseNativeTypes")
		;
	enum_<btBroadphaseProxy::CollisionFilterGroups>("btBroadphaseProxy::CollisionFilterGroups")
		;
	.function("getUid", &btBroadphaseProxy::getUid)
	.constructor<r.q(const).btVector3,r.q(const).btVector3,p.void,int,int>()
	.class_function("isPolyhedral", &btBroadphaseProxy::isPolyhedral)
	.class_function("isConvex", &btBroadphaseProxy::isConvex)
	.class_function("isNonMoving", &btBroadphaseProxy::isNonMoving)
	.class_function("isConcave", &btBroadphaseProxy::isConcave)
	.class_function("isCompound", &btBroadphaseProxy::isCompound)
	.class_function("isSoftBody", &btBroadphaseProxy::isSoftBody)
	.class_function("isInfinite", &btBroadphaseProxy::isInfinite)
	.class_function("isConvex2d", &btBroadphaseProxy::isConvex2d)
	.constructor<r.q(const).btBroadphasePair>()
	.constructor<r.btBroadphaseProxy,r.btBroadphaseProxy>()
	.function("operator ()", &btBroadphasePairSortPredicate::operator ())
	.function("process", &btBroadphaseAabbCallback::process)
	.function("createProxy", &btBroadphaseInterface::createProxy)
	.function("destroyProxy", &btBroadphaseInterface::destroyProxy)
	.function("setAabb", &btBroadphaseInterface::setAabb)
	.function("getAabb", &btBroadphaseInterface::getAabb)
	.function("rayTest_r.q(const).btVector3_r.q(const).btVector3_r.btBroadphaseRayCallback_r.q(const).btVector3_r.q(const).btVector3", select_overload<void(r.q(const).btVector3, r.q(const).btVector3, r.btBroadphaseRayCallback, r.q(const).btVector3, r.q(const).btVector3)>(&btBroadphaseInterface::rayTest))
	.function("rayTest_r.q(const).btVector3_r.q(const).btVector3_r.btBroadphaseRayCallback_r.q(const).btVector3", select_overload<void(r.q(const).btVector3, r.q(const).btVector3, r.btBroadphaseRayCallback, r.q(const).btVector3)>(&btBroadphaseInterface::rayTest))
	.function("rayTest_r.q(const).btVector3_r.q(const).btVector3_r.btBroadphaseRayCallback", select_overload<void(r.q(const).btVector3, r.q(const).btVector3, r.btBroadphaseRayCallback)>(&btBroadphaseInterface::rayTest))
	.function("aabbTest", &btBroadphaseInterface::aabbTest)
	.function("calculateOverlappingPairs", &btBroadphaseInterface::calculateOverlappingPairs)
	.function("getOverlappingPairCache", select_overload<btOverlappingPairCache()>(&btBroadphaseInterface::getOverlappingPairCache))
	.function("getOverlappingPairCache", select_overload<q(const).btOverlappingPairCache()const>(&btBroadphaseInterface::getOverlappingPairCache))
	.function("getBroadphaseAabb", &btBroadphaseInterface::getBroadphaseAabb)
	.function("resetPool", &btBroadphaseInterface::resetPool)
	.function("printStats", &btBroadphaseInterface::printStats)
	.constructor<p.btDispatcher,int>()
	.constructor<r.q(const).btCollisionAlgorithmConstructionInfo>()
	.function("processCollision", &btCollisionAlgorithm::processCollision)
	.function("calculateTimeOfImpact", &btCollisionAlgorithm::calculateTimeOfImpact)
	.function("getAllContactManifolds", &btCollisionAlgorithm::getAllContactManifolds)
	.function("getX", &btQuadWord::getX)
	.function("getY", &btQuadWord::getY)
	.function("getZ", &btQuadWord::getZ)
	.function("setX", &btQuadWord::setX)
	.function("setY", &btQuadWord::setY)
	.function("setZ", &btQuadWord::setZ)
	.function("setW", &btQuadWord::setW)
	.function("x", &btQuadWord::x)
	.function("y", &btQuadWord::y)
	.function("z", &btQuadWord::z)
	.function("w", &btQuadWord::w)
	.function("operator btScalar*", &btQuadWord::operator btScalar*)
	.function("operator const btScalar*", &btQuadWord::operator const btScalar*)
	.function("operator ==", &btQuadWord::operator ==)
	.function("operator !=", &btQuadWord::operator !=)
	.function("setValue_r.q(const).btScalar_r.q(const).btScalar_r.q(const).btScalar", select_overload<void(r.q(const).btScalar, r.q(const).btScalar, r.q(const).btScalar)>(&btQuadWord::setValue))
	.function("setValue_r.q(const).btScalar_r.q(const).btScalar_r.q(const).btScalar_r.q(const).btScalar", select_overload<void(r.q(const).btScalar, r.q(const).btScalar, r.q(const).btScalar, r.q(const).btScalar)>(&btQuadWord::setValue))
	.constructor<r.q(const).btScalar,r.q(const).btScalar,r.q(const).btScalar>()
	.constructor<r.q(const).btScalar,r.q(const).btScalar,r.q(const).btScalar,r.q(const).btScalar>()
	.function("setMax", &btQuadWord::setMax)
	.function("setMin", &btQuadWord::setMin)
	.constructor<r.q(const).btScalar,r.q(const).btScalar,r.q(const).btScalar,r.q(const).btScalar>()
	.constructor<r.q(const).btVector3,r.q(const).btScalar>()
	.constructor<r.q(const).btScalar,r.q(const).btScalar,r.q(const).btScalar>()
	.function("setRotation", &btQuaternion::setRotation)
	.function("setEuler", &btQuaternion::setEuler)
	.function("setEulerZYX", &btQuaternion::setEulerZYX)
	.function("operator +=", &btQuaternion::operator +=)
	.function("operator -=", &btQuaternion::operator -=)
	.function("operator *=_r.q(const).btScalar", select_overload<btQuaternion(r.q(const).btScalar)>(&btQuaternion::operator *=))
	.function("operator *=_r.q(const).btQuaternion", select_overload<btQuaternion(r.q(const).btQuaternion)>(&btQuaternion::operator *=))
	.function("length2", &btQuaternion::length2)
	.function("length", &btQuaternion::length)
	.function("normalize", &btQuaternion::normalize)
	.function("operator *", &btQuaternion::operator *)
	.function("operator /", &btQuaternion::operator /)
	.function("operator /=", &btQuaternion::operator /=)
	.function("normalized", &btQuaternion::normalized)
	.function("angle", &btQuaternion::angle)
	.function("angleShortestPath", &btQuaternion::angleShortestPath)
	.function("getAngle", &btQuaternion::getAngle)
	.function("getAngleShortestPath", &btQuaternion::getAngleShortestPath)
	.function("getAxis", &btQuaternion::getAxis)
	.function("inverse", &btQuaternion::inverse)
	.function("operator +", &btQuaternion::operator +)
	.function("operator -_r.q(const).btQuaternion", select_overload<btQuaternion(r.q(const).btQuaternion)const>(&btQuaternion::operator -))
	.function("operator -", select_overload<btQuaternion()const>(&btQuaternion::operator -))
	.function("farthest", &btQuaternion::farthest)
	.function("nearest", &btQuaternion::nearest)
	.function("slerp", &btQuaternion::slerp)
	.class_function("getIdentity", &btQuaternion::getIdentity)
	.function("getW", &btQuaternion::getW)
	.function("serialize", &btQuaternion::serialize)
	.function("deSerialize", &btQuaternion::deSerialize)
	.function("serializeFloat", &btQuaternion::serializeFloat)
	.function("deSerializeFloat", &btQuaternion::deSerializeFloat)
	.function("serializeDouble", &btQuaternion::serializeDouble)
	.function("deSerializeDouble", &btQuaternion::deSerializeDouble)
	.constructor<r.q(const).btQuaternion>()
	.constructor<r.q(const).btScalar,r.q(const).btScalar,r.q(const).btScalar,r.q(const).btScalar,r.q(const).btScalar,r.q(const).btScalar,r.q(const).btScalar,r.q(const).btScalar,r.q(const).btScalar>()
	.constructor<r.q(const).btMatrix3x3>()
	.function("operator =", &btMatrix3x3::operator =)
	.function("getColumn", &btMatrix3x3::getColumn)
	.function("getRow", &btMatrix3x3::getRow)
	.function("operator []_int", select_overload<btVector3(int)>(&btMatrix3x3::operator []))
	.function("operator []_int", select_overload<q(const).btVector3(int)const>(&btMatrix3x3::operator []))
	.function("operator *=", &btMatrix3x3::operator *=)
	.function("operator +=", &btMatrix3x3::operator +=)
	.function("operator -=", &btMatrix3x3::operator -=)
	.function("setValue", &btMatrix3x3::setValue)
	.function("setRotation", &btMatrix3x3::setRotation)
	.function("setEulerYPR", &btMatrix3x3::setEulerYPR)
	.function("setEulerZYX", &btMatrix3x3::setEulerZYX)
	.function("setIdentity", &btMatrix3x3::setIdentity)
	.class_function("getIdentity", &btMatrix3x3::getIdentity)
	.function("getOpenGLSubMatrix", &btMatrix3x3::getOpenGLSubMatrix)
	.function("getRotation", &btMatrix3x3::getRotation)
	.function("getEulerYPR", &btMatrix3x3::getEulerYPR)
	.function("getEulerZYX_r.btScalar_r.btScalar_r.btScalar_unsigned int", select_overload<void(r.btScalar, r.btScalar, r.btScalar, unsigned int)const>(&btMatrix3x3::getEulerZYX))
	.function("getEulerZYX_r.btScalar_r.btScalar_r.btScalar", select_overload<void(r.btScalar, r.btScalar, r.btScalar)const>(&btMatrix3x3::getEulerZYX))
	.function("scaled", &btMatrix3x3::scaled)
	.function("determinant", &btMatrix3x3::determinant)
	.function("adjoint", &btMatrix3x3::adjoint)
	.function("absolute", &btMatrix3x3::absolute)
	.function("transpose", &btMatrix3x3::transpose)
	.function("inverse", &btMatrix3x3::inverse)
	.function("solve33", &btMatrix3x3::solve33)
	.function("transposeTimes", &btMatrix3x3::transposeTimes)
	.function("timesTranspose", &btMatrix3x3::timesTranspose)
	.function("tdotx", &btMatrix3x3::tdotx)
	.function("tdoty", &btMatrix3x3::tdoty)
	.function("tdotz", &btMatrix3x3::tdotz)
	.function("diagonalize", &btMatrix3x3::diagonalize)
	.function("cofac", &btMatrix3x3::cofac)
	.function("serialize", &btMatrix3x3::serialize)
	.function("serializeFloat", &btMatrix3x3::serializeFloat)
	.function("deSerialize", &btMatrix3x3::deSerialize)
	.function("deSerializeFloat", &btMatrix3x3::deSerializeFloat)
	.function("deSerializeDouble", &btMatrix3x3::deSerializeDouble)
	.constructor<r.q(const).btQuaternion,r.q(const).btVector3>()
	.constructor<r.q(const).btQuaternion>()
	.constructor<r.q(const).btMatrix3x3,r.q(const).btVector3>()
	.constructor<r.q(const).btMatrix3x3>()
	.constructor<r.q(const).btTransform>()
	.function("operator =", &btTransform::operator =)
	.function("mult", &btTransform::mult)
	.function("operator ()", &btTransform::operator ())
	.function("operator *_r.q(const).btVector3", select_overload<btVector3(r.q(const).btVector3)const>(&btTransform::operator *))
	.function("operator *_r.q(const).btQuaternion", select_overload<btQuaternion(r.q(const).btQuaternion)const>(&btTransform::operator *))
	.function("getBasis", select_overload<btMatrix3x3()>(&btTransform::getBasis))
	.function("getBasis", select_overload<q(const).btMatrix3x3()const>(&btTransform::getBasis))
	.function("getOrigin", select_overload<btVector3()>(&btTransform::getOrigin))
	.function("getOrigin", select_overload<q(const).btVector3()const>(&btTransform::getOrigin))
	.function("getRotation", &btTransform::getRotation)
	.function("getOpenGLMatrix", &btTransform::getOpenGLMatrix)
	.function("setOrigin", &btTransform::setOrigin)
	.function("invXform", &btTransform::invXform)
	.function("setBasis", &btTransform::setBasis)
	.function("setRotation", &btTransform::setRotation)
	.function("setIdentity", &btTransform::setIdentity)
	.function("operator *=", &btTransform::operator *=)
	.function("inverse", &btTransform::inverse)
	.function("inverseTimes", &btTransform::inverseTimes)
	.function("operator *_r.q(const).btTransform", select_overload<btTransform(r.q(const).btTransform)const>(&btTransform::operator *))
	.class_function("getIdentity", &btTransform::getIdentity)
	.function("serialize", &btTransform::serialize)
	.function("serializeFloat", &btTransform::serializeFloat)
	.function("deSerialize", &btTransform::deSerialize)
	.function("deSerializeDouble", &btTransform::deSerializeDouble)
	.function("deSerializeFloat", &btTransform::deSerializeFloat)
	.function("Center", &btDbvtAabbMm::Center)
	.function("Lengths", &btDbvtAabbMm::Lengths)
	.function("Extents", &btDbvtAabbMm::Extents)
	.function("Mins", &btDbvtAabbMm::Mins)
	.function("Maxs", &btDbvtAabbMm::Maxs)
	.class_function("FromCE", &btDbvtAabbMm::FromCE)
	.class_function("FromCR", &btDbvtAabbMm::FromCR)
	.class_function("FromMM", &btDbvtAabbMm::FromMM)
	.class_function("FromPoints", &btDbvtAabbMm::FromPoints)
	.class_function("FromPoints", &btDbvtAabbMm::FromPoints)
	.function("Expand", &btDbvtAabbMm::Expand)
	.function("SignedExpand", &btDbvtAabbMm::SignedExpand)
	.function("Contain", &btDbvtAabbMm::Contain)
	.function("Classify", &btDbvtAabbMm::Classify)
	.function("ProjectMinimum", &btDbvtAabbMm::ProjectMinimum)
	.function("tMins", &btDbvtAabbMm::tMins)
	.function("tMaxs", &btDbvtAabbMm::tMaxs)
	.function("AddSpan", &btDbvtAabbMm::AddSpan)
	.function("isleaf", &btDbvtNode::isleaf)
	.function("isinternal", &btDbvtNode::isinternal)
	enum_<>("")
		;
	.function("clear", &btDbvt::clear)
	.function("empty", &btDbvt::empty)
	.function("optimizeBottomUp", &btDbvt::optimizeBottomUp)
	.function("optimizeTopDown_int", select_overload<void(int)>(&btDbvt::optimizeTopDown))
	.function("optimizeTopDown", select_overload<void()>(&btDbvt::optimizeTopDown))
	.function("optimizeIncremental", &btDbvt::optimizeIncremental)
	.function("insert", &btDbvt::insert)
	.function("update_p.btDbvtNode_int", select_overload<void(p.btDbvtNode, int)>(&btDbvt::update))
	.function("update_p.btDbvtNode", select_overload<void(p.btDbvtNode)>(&btDbvt::update))
	.function("update_p.btDbvtNode_r.btDbvtVolume", select_overload<void(p.btDbvtNode, r.btDbvtVolume)>(&btDbvt::update))
	.function("update_p.btDbvtNode_r.btDbvtVolume_r.q(const).btVector3_btScalar", select_overload<bool(p.btDbvtNode, r.btDbvtVolume, r.q(const).btVector3, btScalar)>(&btDbvt::update))
	.function("update_p.btDbvtNode_r.btDbvtVolume_r.q(const).btVector3", select_overload<bool(p.btDbvtNode, r.btDbvtVolume, r.q(const).btVector3)>(&btDbvt::update))
	.function("update_p.btDbvtNode_r.btDbvtVolume_btScalar", select_overload<bool(p.btDbvtNode, r.btDbvtVolume, btScalar)>(&btDbvt::update))
	.function("remove", &btDbvt::remove)
	.function("write", &btDbvt::write)
	.function("clone_r.btDbvt_p.btDbvt::IClone", select_overload<void(r.btDbvt, p.btDbvt::IClone)const>(&btDbvt::clone))
	.function("clone_r.btDbvt", select_overload<void(r.btDbvt)const>(&btDbvt::clone))
	.class_function("maxdepth", &btDbvt::maxdepth)
	.class_function("countLeaves", &btDbvt::countLeaves)
	.class_function("extractLeaves", &btDbvt::extractLeaves)
	.class_function("benchmark", &btDbvt::benchmark)
	.class_function("enumNodes", &btDbvt::enumNodes)
	.class_function("enumLeaves", &btDbvt::enumLeaves)
	.function("collideTT", &btDbvt::collideTT)
	.function("collideTTpersistentStack", &btDbvt::collideTTpersistentStack)
	.function("collideTV", &btDbvt::collideTV)
	.function("collideTVNoStackAlloc", &btDbvt::collideTVNoStackAlloc)
	.class_function("rayTest", &btDbvt::rayTest)
	.function("rayTestInternal", &btDbvt::rayTestInternal)
	.class_function("collideKDOP", &btDbvt::collideKDOP)
	.class_function("collideOCL", &btDbvt::collideOCL)
	.class_function("collideOCL", &btDbvt::collideOCL)
	.class_function("collideTU", &btDbvt::collideTU)
	.class_function("nearest", &btDbvt::nearest)
	.class_function("allocate", &btDbvt::allocate)
	.constructor<r.q(const).btDbvt>()
	.function("addOverlappingPair", &btOverlappingPairCallback::addOverlappingPair)
	.function("removeOverlappingPair", &btOverlappingPairCallback::removeOverlappingPair)
	.function("removeOverlappingPairsContainingProxy", &btOverlappingPairCallback::removeOverlappingPairsContainingProxy)
	.function("processOverlap", &btOverlapCallback::processOverlap)
	.function("needBroadphaseCollision", &btOverlapFilterCallback::needBroadphaseCollision)
	.function("getOverlappingPairArrayPtr", select_overload<btBroadphasePair()>(&btOverlappingPairCache::getOverlappingPairArrayPtr))
	.function("getOverlappingPairArrayPtr", select_overload<q(const).btBroadphasePair()const>(&btOverlappingPairCache::getOverlappingPairArrayPtr))
	.function("getOverlappingPairArray", &btOverlappingPairCache::getOverlappingPairArray)
	.function("cleanOverlappingPair", &btOverlappingPairCache::cleanOverlappingPair)
	.function("getNumOverlappingPairs", &btOverlappingPairCache::getNumOverlappingPairs)
	.function("cleanProxyFromPairs", &btOverlappingPairCache::cleanProxyFromPairs)
	.function("setOverlapFilterCallback", &btOverlappingPairCache::setOverlapFilterCallback)
	.function("processAllOverlappingPairs", &btOverlappingPairCache::processAllOverlappingPairs)
	.function("findPair", &btOverlappingPairCache::findPair)
	.function("hasDeferredRemoval", &btOverlappingPairCache::hasDeferredRemoval)
	.function("setInternalGhostPairCallback", &btOverlappingPairCache::setInternalGhostPairCallback)
	.function("sortOverlappingPairs", &btOverlappingPairCache::sortOverlappingPairs)
	.function("needsBroadphaseCollision", &btHashedOverlappingPairCache::needsBroadphaseCollision)
	.function("getOverlappingPairArrayPtr", select_overload<btBroadphasePair()>(&btHashedOverlappingPairCache::getOverlappingPairArrayPtr))
	.function("getOverlappingPairArrayPtr", select_overload<q(const).btBroadphasePair()const>(&btHashedOverlappingPairCache::getOverlappingPairArrayPtr))
	.function("getOverlappingPairArray", select_overload<btBroadphasePairArray()>(&btHashedOverlappingPairCache::getOverlappingPairArray))
	.function("getOverlappingPairArray", select_overload<q(const).btBroadphasePairArray()const>(&btHashedOverlappingPairCache::getOverlappingPairArray))
	.function("GetCount", &btHashedOverlappingPairCache::GetCount)
	.function("getOverlapFilterCallback", &btHashedOverlappingPairCache::getOverlapFilterCallback)
	.function("internalAddPair", &btHashedOverlappingPairCache::internalAddPair)
	.function("growTables", &btHashedOverlappingPairCache::growTables)
	.function("equalsPair", &btHashedOverlappingPairCache::equalsPair)
	.function("getHash", &btHashedOverlappingPairCache::getHash)
	.function("internalFindPair", &btHashedOverlappingPairCache::internalFindPair)
	.function("hasDeferredRemoval", &btHashedOverlappingPairCache::hasDeferredRemoval)
	.function("setInternalGhostPairCallback", &btHashedOverlappingPairCache::setInternalGhostPairCallback)
	.function("sortOverlappingPairs", &btHashedOverlappingPairCache::sortOverlappingPairs)
	.function("needsBroadphaseCollision", &btSortedOverlappingPairCache::needsBroadphaseCollision)
	.function("getOverlappingPairArray", select_overload<btBroadphasePairArray()>(&btSortedOverlappingPairCache::getOverlappingPairArray))
	.function("getOverlappingPairArray", select_overload<q(const).btBroadphasePairArray()const>(&btSortedOverlappingPairCache::getOverlappingPairArray))
	.function("getOverlappingPairArrayPtr", select_overload<btBroadphasePair()>(&btSortedOverlappingPairCache::getOverlappingPairArrayPtr))
	.function("getOverlappingPairArrayPtr", select_overload<q(const).btBroadphasePair()const>(&btSortedOverlappingPairCache::getOverlappingPairArrayPtr))
	.function("getOverlapFilterCallback", &btSortedOverlappingPairCache::getOverlapFilterCallback)
	.function("getOverlappingPairArrayPtr", select_overload<btBroadphasePair()>(&btNullPairCache::getOverlappingPairArrayPtr))
	.function("getOverlappingPairArrayPtr", select_overload<q(const).btBroadphasePair()const>(&btNullPairCache::getOverlappingPairArrayPtr))
	.constructor<r.q(const).btVector3,r.q(const).btVector3,p.void,int,int>()
	enum_<>("")
		;
	.constructor<p.btOverlappingPairCache>()
	.function("collide", &btDbvtBroadphase::collide)
	.function("optimize", &btDbvtBroadphase::optimize)
	.function("rayTest_r.q(const).btVector3_r.q(const).btVector3_r.btBroadphaseRayCallback_r.q(const).btVector3_r.q(const).btVector3", select_overload<void(r.q(const).btVector3, r.q(const).btVector3, r.btBroadphaseRayCallback, r.q(const).btVector3, r.q(const).btVector3)>(&btDbvtBroadphase::rayTest))
	.function("rayTest_r.q(const).btVector3_r.q(const).btVector3_r.btBroadphaseRayCallback_r.q(const).btVector3", select_overload<void(r.q(const).btVector3, r.q(const).btVector3, r.btBroadphaseRayCallback, r.q(const).btVector3)>(&btDbvtBroadphase::rayTest))
	.function("rayTest_r.q(const).btVector3_r.q(const).btVector3_r.btBroadphaseRayCallback", select_overload<void(r.q(const).btVector3, r.q(const).btVector3, r.btBroadphaseRayCallback)>(&btDbvtBroadphase::rayTest))
	.function("getOverlappingPairCache", select_overload<btOverlappingPairCache()>(&btDbvtBroadphase::getOverlappingPairCache))
	.function("getOverlappingPairCache", select_overload<q(const).btOverlappingPairCache()const>(&btDbvtBroadphase::getOverlappingPairCache))
	.function("performDeferredRemoval", &btDbvtBroadphase::performDeferredRemoval)
	.function("setVelocityPrediction", &btDbvtBroadphase::setVelocityPrediction)
	.function("getVelocityPrediction", &btDbvtBroadphase::getVelocityPrediction)
	.function("setAabbForceUpdate", &btDbvtBroadphase::setAabbForceUpdate)
	.class_function("benchmark", &btDbvtBroadphase::benchmark)
	enum_<btDispatcherInfo::DispatchFunc>("btDispatcherInfo::DispatchFunc")
		;
	enum_<ebtDispatcherQueryType>("ebtDispatcherQueryType")
		;
	.function("findAlgorithm", &btDispatcher::findAlgorithm)
	.function("getNewManifold", &btDispatcher::getNewManifold)
	.function("releaseManifold", &btDispatcher::releaseManifold)
	.function("clearManifold", &btDispatcher::clearManifold)
	.function("needsCollision", &btDispatcher::needsCollision)
	.function("needsResponse", &btDispatcher::needsResponse)
	.function("dispatchAllCollisionPairs", &btDispatcher::dispatchAllCollisionPairs)
	.function("getNumManifolds", &btDispatcher::getNumManifolds)
	.function("getManifoldByIndexInternal", &btDispatcher::getManifoldByIndexInternal)
	.function("getInternalManifoldPointer", &btDispatcher::getInternalManifoldPointer)
	.function("getInternalManifoldPool", select_overload<btPoolAllocator()>(&btDispatcher::getInternalManifoldPool))
	.function("getInternalManifoldPool", select_overload<q(const).btPoolAllocator()const>(&btDispatcher::getInternalManifoldPool))
	.function("allocateCollisionAlgorithm", &btDispatcher::allocateCollisionAlgorithm)
	.function("freeCollisionAlgorithm", &btDispatcher::freeCollisionAlgorithm)
	.function("isLeafNode", &btQuantizedBvhNode::isLeafNode)
	.function("getEscapeIndex", &btQuantizedBvhNode::getEscapeIndex)
	.function("getTriangleIndex", &btQuantizedBvhNode::getTriangleIndex)
	.function("getPartId", &btQuantizedBvhNode::getPartId)
	.function("setAabbFromQuantizeNode", &btBvhSubtreeInfo::setAabbFromQuantizeNode)
	.function("processNode", &btNodeOverlapCallback::processNode)
	enum_<btQuantizedBvh::btTraversalMode>("btQuantizedBvh::btTraversalMode")
		;
	.function("setInternalNodeAabbMin", &btQuantizedBvh::setInternalNodeAabbMin)
	.function("setInternalNodeAabbMax", &btQuantizedBvh::setInternalNodeAabbMax)
	.function("getAabbMin", &btQuantizedBvh::getAabbMin)
	.function("getAabbMax", &btQuantizedBvh::getAabbMax)
	.function("setInternalNodeEscapeIndex", &btQuantizedBvh::setInternalNodeEscapeIndex)
	.function("mergeInternalNodeAabb", &btQuantizedBvh::mergeInternalNodeAabb)
	.function("swapLeafNodes", &btQuantizedBvh::swapLeafNodes)
	.function("assignInternalNodeFromLeafNode", &btQuantizedBvh::assignInternalNodeFromLeafNode)
	.function("buildTree", &btQuantizedBvh::buildTree)
	.function("calcSplittingAxis", &btQuantizedBvh::calcSplittingAxis)
	.function("sortAndCalcSplittingIndex", &btQuantizedBvh::sortAndCalcSplittingIndex)
	.function("walkStacklessTree", &btQuantizedBvh::walkStacklessTree)
	.function("walkStacklessQuantizedTreeAgainstRay", &btQuantizedBvh::walkStacklessQuantizedTreeAgainstRay)
	.function("walkStacklessQuantizedTree", &btQuantizedBvh::walkStacklessQuantizedTree)
	.function("walkStacklessTreeAgainstRay", &btQuantizedBvh::walkStacklessTreeAgainstRay)
	.function("walkStacklessQuantizedTreeCacheFriendly", &btQuantizedBvh::walkStacklessQuantizedTreeCacheFriendly)
	.function("walkRecursiveQuantizedTreeAgainstQueryAabb", &btQuantizedBvh::walkRecursiveQuantizedTreeAgainstQueryAabb)
	.function("walkRecursiveQuantizedTreeAgainstQuantizedTree", &btQuantizedBvh::walkRecursiveQuantizedTreeAgainstQuantizedTree)
	.function("updateSubtreeHeaders", &btQuantizedBvh::updateSubtreeHeaders)
	.function("setQuantizationValues_r.q(const).btVector3_r.q(const).btVector3_btScalar", select_overload<void(r.q(const).btVector3, r.q(const).btVector3, btScalar)>(&btQuantizedBvh::setQuantizationValues))
	.function("setQuantizationValues_r.q(const).btVector3_r.q(const).btVector3", select_overload<void(r.q(const).btVector3, r.q(const).btVector3)>(&btQuantizedBvh::setQuantizationValues))
	.function("getLeafNodeArray", &btQuantizedBvh::getLeafNodeArray)
	.function("buildInternal", &btQuantizedBvh::buildInternal)
	.function("reportAabbOverlappingNodex", &btQuantizedBvh::reportAabbOverlappingNodex)
	.function("reportRayOverlappingNodex", &btQuantizedBvh::reportRayOverlappingNodex)
	.function("reportBoxCastOverlappingNodex", &btQuantizedBvh::reportBoxCastOverlappingNodex)
	.function("quantize", &btQuantizedBvh::quantize)
	.function("quantizeWithClamp", &btQuantizedBvh::quantizeWithClamp)
	.function("unQuantize", &btQuantizedBvh::unQuantize)
	.function("setTraversalMode", &btQuantizedBvh::setTraversalMode)
	.function("getQuantizedNodeArray", &btQuantizedBvh::getQuantizedNodeArray)
	.function("getSubtreeInfoArray", &btQuantizedBvh::getSubtreeInfoArray)
	.function("calculateSerializeBufferSize", &btQuantizedBvh::calculateSerializeBufferSize)
	.function("serialize_p.void_unsigned int_bool", select_overload<bool(p.void, unsigned int, bool)const>(&btQuantizedBvh::serialize))
	.class_function("deSerializeInPlace", &btQuantizedBvh::deSerializeInPlace)
	.class_function("getAlignmentSerializationPadding", &btQuantizedBvh::getAlignmentSerializationPadding)
	.function("calculateSerializeBufferSizeNew", &btQuantizedBvh::calculateSerializeBufferSizeNew)
	.function("serialize_p.void_p.btSerializer", select_overload<q(const).char(p.void, p.btSerializer)const>(&btQuantizedBvh::serialize))
	.function("deSerializeFloat", &btQuantizedBvh::deSerializeFloat)
	.function("deSerializeDouble", &btQuantizedBvh::deSerializeDouble)
	.function("isQuantized", &btQuantizedBvh::isQuantized)
	.constructor<r.btQuantizedBvh,bool>()
	.constructor<r.q(const).btVector3,r.q(const).btVector3,int,p.void,int,int>()
	.function("SetNextFree", &btSimpleBroadphaseProxy::SetNextFree)
	.function("GetNextFree", &btSimpleBroadphaseProxy::GetNextFree)
	.function("allocHandle", &btSimpleBroadphase::allocHandle)
	.function("freeHandle", &btSimpleBroadphase::freeHandle)
	.function("getSimpleProxyFromProxy", &btSimpleBroadphase::getSimpleProxyFromProxy)
	.function("getSimpleProxyFromProxy", &btSimpleBroadphase::getSimpleProxyFromProxy)
	.function("resetPool", &btSimpleBroadphase::resetPool)
	.function("validate", &btSimpleBroadphase::validate)
	.constructor<int,p.btOverlappingPairCache>()
	.constructor<int>()
	.class_function("aabbOverlap", &btSimpleBroadphase::aabbOverlap)
	.function("rayTest_r.q(const).btVector3_r.q(const).btVector3_r.btBroadphaseRayCallback_r.q(const).btVector3_r.q(const).btVector3", select_overload<void(r.q(const).btVector3, r.q(const).btVector3, r.btBroadphaseRayCallback, r.q(const).btVector3, r.q(const).btVector3)>(&btSimpleBroadphase::rayTest))
	.function("rayTest_r.q(const).btVector3_r.q(const).btVector3_r.btBroadphaseRayCallback_r.q(const).btVector3", select_overload<void(r.q(const).btVector3, r.q(const).btVector3, r.btBroadphaseRayCallback, r.q(const).btVector3)>(&btSimpleBroadphase::rayTest))
	.function("rayTest_r.q(const).btVector3_r.q(const).btVector3_r.btBroadphaseRayCallback", select_overload<void(r.q(const).btVector3, r.q(const).btVector3, r.btBroadphaseRayCallback)>(&btSimpleBroadphase::rayTest))
	.function("getOverlappingPairCache", select_overload<btOverlappingPairCache()>(&btSimpleBroadphase::getOverlappingPairCache))
	.function("getOverlappingPairCache", select_overload<q(const).btOverlappingPairCache()const>(&btSimpleBroadphase::getOverlappingPairCache))
	.function("testAabbOverlap", &btSimpleBroadphase::testAabbOverlap)
	.constructor<r.q(const).btCollisionAlgorithmConstructionInfo>()
	.constructor<r.q(const).btCollisionAlgorithmConstructionInfo,p.q(const).btCollisionObjectWrapper,p.q(const).btCollisionObjectWrapper>()
	.function("CreateCollisionAlgorithm", &btCollisionAlgorithmCreateFunc::CreateCollisionAlgorithm)
	.constructor<r.q(const).btCollisionAlgorithmConstructionInfo>()
	.constructor<p.btPersistentManifold,r.q(const).btCollisionAlgorithmConstructionInfo,p.q(const).btCollisionObjectWrapper,p.q(const).btCollisionObjectWrapper>()
	.constructor<r.q(const).btCollisionAlgorithmConstructionInfo>()
	.constructor<p.btPersistentManifold,r.q(const).btCollisionAlgorithmConstructionInfo,p.q(const).btCollisionObjectWrapper,p.q(const).btCollisionObjectWrapper>()
	.function("getClosestPoints_r.q(const).btDiscreteCollisionDetectorInterface::ClosestPointInput_r.btDiscreteCollisionDetectorInterface::Result_p.btIDebugDraw_bool", select_overload<void(r.q(const).btDiscreteCollisionDetectorInterface::ClosestPointInput, r.btDiscreteCollisionDetectorInterface::Result, p.btIDebugDraw, bool)>(&btDiscreteCollisionDetectorInterface::getClosestPoints))
	.function("getClosestPoints_r.q(const).btDiscreteCollisionDetectorInterface::ClosestPointInput_r.btDiscreteCollisionDetectorInterface::Result_p.btIDebugDraw", select_overload<void(r.q(const).btDiscreteCollisionDetectorInterface::ClosestPointInput, r.btDiscreteCollisionDetectorInterface::Result, p.btIDebugDraw)>(&btDiscreteCollisionDetectorInterface::getClosestPoints))
	.constructor<p.q(const).btBoxShape,p.q(const).btBoxShape>()
	.function("getClosestPoints_r.q(const).btDiscreteCollisionDetectorInterface::ClosestPointInput_r.btDiscreteCollisionDetectorInterface::Result_p.btIDebugDraw_bool", select_overload<void(r.q(const).btDiscreteCollisionDetectorInterface::ClosestPointInput, r.btDiscreteCollisionDetectorInterface::Result, p.btIDebugDraw, bool)>(&btBoxBoxDetector::getClosestPoints))
	.function("getClosestPoints_r.q(const).btDiscreteCollisionDetectorInterface::ClosestPointInput_r.btDiscreteCollisionDetectorInterface::Result_p.btIDebugDraw", select_overload<void(r.q(const).btDiscreteCollisionDetectorInterface::ClosestPointInput, r.btDiscreteCollisionDetectorInterface::Result, p.btIDebugDraw)>(&btBoxBoxDetector::getClosestPoints))
	.function("getPersistentManifoldPool", &btCollisionConfiguration::getPersistentManifoldPool)
	.function("getCollisionAlgorithmPool", &btCollisionConfiguration::getCollisionAlgorithmPool)
	.function("getCollisionAlgorithmCreateFunc", &btCollisionConfiguration::getCollisionAlgorithmCreateFunc)
	.function("getClosestPointsAlgorithmCreateFunc", &btCollisionConfiguration::getClosestPointsAlgorithmCreateFunc)
	.class_function("integrateTransform", &btTransformUtil::integrateTransform)
	.class_function("calculateVelocityQuaternion", &btTransformUtil::calculateVelocityQuaternion)
	.class_function("calculateDiffAxisAngleQuaternion", &btTransformUtil::calculateDiffAxisAngleQuaternion)
	.class_function("calculateVelocity", &btTransformUtil::calculateVelocity)
	.class_function("calculateDiffAxisAngle", &btTransformUtil::calculateDiffAxisAngle)
	.constructor<btScalar,btScalar>()
	.function("getConservativeSeparatingDistance", &btConvexSeparatingDistanceUtil::getConservativeSeparatingDistance)
	.function("updateSeparatingDistance", &btConvexSeparatingDistanceUtil::updateSeparatingDistance)
	.function("initSeparatingDistance", &btConvexSeparatingDistanceUtil::initSeparatingDistance)
	enum_<btContactPointFlags>("btContactPointFlags")
		;
	.constructor<r.q(const).btVector3,r.q(const).btVector3,r.q(const).btVector3,btScalar>()
	.function("getDistance", &btManifoldPoint::getDistance)
	.function("getLifeTime", &btManifoldPoint::getLifeTime)
	.function("getPositionWorldOnA", &btManifoldPoint::getPositionWorldOnA)
	.function("getPositionWorldOnB", &btManifoldPoint::getPositionWorldOnB)
	.function("setDistance", &btManifoldPoint::setDistance)
	.function("getAppliedImpulse", &btManifoldPoint::getAppliedImpulse)
	enum_<btContactManifoldTypes>("btContactManifoldTypes")
		;
	.function("sortCachedPoints", &btPersistentManifold::sortCachedPoints)
	.function("findContactPoint", &btPersistentManifold::findContactPoint)
	.constructor<p.q(const).btCollisionObject,p.q(const).btCollisionObject,int,btScalar,btScalar>()
	.function("getBody0", &btPersistentManifold::getBody0)
	.function("getBody1", &btPersistentManifold::getBody1)
	.function("setBodies", &btPersistentManifold::setBodies)
	.function("clearUserCache", &btPersistentManifold::clearUserCache)
	.function("getNumContacts", &btPersistentManifold::getNumContacts)
	.function("setNumContacts", &btPersistentManifold::setNumContacts)
	.function("getContactPoint_int", select_overload<q(const).btManifoldPoint(int)const>(&btPersistentManifold::getContactPoint))
	.function("getContactPoint_int", select_overload<btManifoldPoint(int)>(&btPersistentManifold::getContactPoint))
	.function("getContactBreakingThreshold", &btPersistentManifold::getContactBreakingThreshold)
	.function("getContactProcessingThreshold", &btPersistentManifold::getContactProcessingThreshold)
	.function("setContactBreakingThreshold", &btPersistentManifold::setContactBreakingThreshold)
	.function("setContactProcessingThreshold", &btPersistentManifold::setContactProcessingThreshold)
	.function("getCacheEntry", &btPersistentManifold::getCacheEntry)
	.function("addManifoldPoint_r.q(const).btManifoldPoint_bool", select_overload<int(r.q(const).btManifoldPoint, bool)>(&btPersistentManifold::addManifoldPoint))
	.function("addManifoldPoint_r.q(const).btManifoldPoint", select_overload<int(r.q(const).btManifoldPoint)>(&btPersistentManifold::addManifoldPoint))
	.function("removeContactPoint", &btPersistentManifold::removeContactPoint)
	.function("replaceContactPoint", &btPersistentManifold::replaceContactPoint)
	.function("validContactDistance", &btPersistentManifold::validContactDistance)
	.function("refreshContactPoints", &btPersistentManifold::refreshContactPoints)
	.function("clearManifold", &btPersistentManifold::clearManifold)
	.function("getWorldTransform", &btMotionState::getWorldTransform)
	.function("setWorldTransform", &btMotionState::setWorldTransform)
	enum_<btCollisionObject::CollisionFlags>("btCollisionObject::CollisionFlags")
		;
	enum_<btCollisionObject::CollisionObjectTypes>("btCollisionObject::CollisionObjectTypes")
		;
	enum_<btCollisionObject::AnisotropicFrictionFlags>("btCollisionObject::AnisotropicFrictionFlags")
		;
	.function("mergesSimulationIslands", &btCollisionObject::mergesSimulationIslands)
	.function("getAnisotropicFriction", &btCollisionObject::getAnisotropicFriction)
	.function("setAnisotropicFriction_r.q(const).btVector3_int", select_overload<void(r.q(const).btVector3, int)>(&btCollisionObject::setAnisotropicFriction))
	.function("setAnisotropicFriction_r.q(const).btVector3", select_overload<void(r.q(const).btVector3)>(&btCollisionObject::setAnisotropicFriction))
	.function("hasAnisotropicFriction_int", select_overload<bool(int)const>(&btCollisionObject::hasAnisotropicFriction))
	.function("hasAnisotropicFriction", select_overload<bool()const>(&btCollisionObject::hasAnisotropicFriction))
	.function("setContactProcessingThreshold", &btCollisionObject::setContactProcessingThreshold)
	.function("getContactProcessingThreshold", &btCollisionObject::getContactProcessingThreshold)
	.function("isStaticObject", &btCollisionObject::isStaticObject)
	.function("isKinematicObject", &btCollisionObject::isKinematicObject)
	.function("isStaticOrKinematicObject", &btCollisionObject::isStaticOrKinematicObject)
	.function("hasContactResponse", &btCollisionObject::hasContactResponse)
	.function("setCollisionShape", &btCollisionObject::setCollisionShape)
	.function("getCollisionShape", select_overload<q(const).btCollisionShape()const>(&btCollisionObject::getCollisionShape))
	.function("getCollisionShape", select_overload<btCollisionShape()>(&btCollisionObject::getCollisionShape))
	.function("setIgnoreCollisionCheck", &btCollisionObject::setIgnoreCollisionCheck)
	.function("checkCollideWithOverride", &btCollisionObject::checkCollideWithOverride)
	.function("internalGetExtensionPointer", &btCollisionObject::internalGetExtensionPointer)
	.function("internalSetExtensionPointer", &btCollisionObject::internalSetExtensionPointer)
	.function("getActivationState", &btCollisionObject::getActivationState)
	.function("setActivationState", &btCollisionObject::setActivationState)
	.function("setDeactivationTime", &btCollisionObject::setDeactivationTime)
	.function("getDeactivationTime", &btCollisionObject::getDeactivationTime)
	.function("forceActivationState", &btCollisionObject::forceActivationState)
	.function("activate_bool", select_overload<void(bool)const>(&btCollisionObject::activate))
	.function("activate", select_overload<void()const>(&btCollisionObject::activate))
	.function("isActive", &btCollisionObject::isActive)
	.function("setRestitution", &btCollisionObject::setRestitution)
	.function("getRestitution", &btCollisionObject::getRestitution)
	.function("setFriction", &btCollisionObject::setFriction)
	.function("getFriction", &btCollisionObject::getFriction)
	.function("setRollingFriction", &btCollisionObject::setRollingFriction)
	.function("getRollingFriction", &btCollisionObject::getRollingFriction)
	.function("setSpinningFriction", &btCollisionObject::setSpinningFriction)
	.function("getSpinningFriction", &btCollisionObject::getSpinningFriction)
	.function("setContactStiffnessAndDamping", &btCollisionObject::setContactStiffnessAndDamping)
	.function("getContactStiffness", &btCollisionObject::getContactStiffness)
	.function("getContactDamping", &btCollisionObject::getContactDamping)
	.function("getInternalType", &btCollisionObject::getInternalType)
	.function("getWorldTransform", select_overload<btTransform()>(&btCollisionObject::getWorldTransform))
	.function("getWorldTransform", select_overload<q(const).btTransform()const>(&btCollisionObject::getWorldTransform))
	.function("setWorldTransform", &btCollisionObject::setWorldTransform)
	.function("getBroadphaseHandle", select_overload<btBroadphaseProxy()>(&btCollisionObject::getBroadphaseHandle))
	.function("getBroadphaseHandle", select_overload<q(const).btBroadphaseProxy()const>(&btCollisionObject::getBroadphaseHandle))
	.function("setBroadphaseHandle", &btCollisionObject::setBroadphaseHandle)
	.function("getInterpolationWorldTransform", select_overload<q(const).btTransform()const>(&btCollisionObject::getInterpolationWorldTransform))
	.function("getInterpolationWorldTransform", select_overload<btTransform()>(&btCollisionObject::getInterpolationWorldTransform))
	.function("setInterpolationWorldTransform", &btCollisionObject::setInterpolationWorldTransform)
	.function("setInterpolationLinearVelocity", &btCollisionObject::setInterpolationLinearVelocity)
	.function("setInterpolationAngularVelocity", &btCollisionObject::setInterpolationAngularVelocity)
	.function("getInterpolationLinearVelocity", &btCollisionObject::getInterpolationLinearVelocity)
	.function("getInterpolationAngularVelocity", &btCollisionObject::getInterpolationAngularVelocity)
	.function("getIslandTag", &btCollisionObject::getIslandTag)
	.function("setIslandTag", &btCollisionObject::setIslandTag)
	.function("getCompanionId", &btCollisionObject::getCompanionId)
	.function("setCompanionId", &btCollisionObject::setCompanionId)
	.function("getWorldArrayIndex", &btCollisionObject::getWorldArrayIndex)
	.function("setWorldArrayIndex", &btCollisionObject::setWorldArrayIndex)
	.function("getHitFraction", &btCollisionObject::getHitFraction)
	.function("setHitFraction", &btCollisionObject::setHitFraction)
	.function("getCollisionFlags", &btCollisionObject::getCollisionFlags)
	.function("setCollisionFlags", &btCollisionObject::setCollisionFlags)
	.function("getCcdSweptSphereRadius", &btCollisionObject::getCcdSweptSphereRadius)
	.function("setCcdSweptSphereRadius", &btCollisionObject::setCcdSweptSphereRadius)
	.function("getCcdMotionThreshold", &btCollisionObject::getCcdMotionThreshold)
	.function("getCcdSquareMotionThreshold", &btCollisionObject::getCcdSquareMotionThreshold)
	.function("setCcdMotionThreshold", &btCollisionObject::setCcdMotionThreshold)
	.function("getUserPointer", &btCollisionObject::getUserPointer)
	.function("getUserIndex", &btCollisionObject::getUserIndex)
	.function("getUserIndex2", &btCollisionObject::getUserIndex2)
	.function("setUserPointer", &btCollisionObject::setUserPointer)
	.function("setUserIndex", &btCollisionObject::setUserIndex)
	.function("setUserIndex2", &btCollisionObject::setUserIndex2)
	.function("getUpdateRevisionInternal", &btCollisionObject::getUpdateRevisionInternal)
	.function("setCustomDebugColor", &btCollisionObject::setCustomDebugColor)
	.function("removeCustomDebugColor", &btCollisionObject::removeCustomDebugColor)
	.function("getCustomDebugColor", &btCollisionObject::getCustomDebugColor)
	.function("checkCollideWith", &btCollisionObject::checkCollideWith)
	.function("calculateSerializeBufferSize", &btCollisionObject::calculateSerializeBufferSize)
	.function("serialize", &btCollisionObject::serialize)
	.function("serializeSingleObject", &btCollisionObject::serializeSingleObject)
	.constructor<p.q(const).btCollisionObjectWrapper,p.q(const).btCollisionObjectWrapper>()
	.function("setPersistentManifold", &btManifoldResult::setPersistentManifold)
	.function("getPersistentManifold", select_overload<q(const).btPersistentManifold()const>(&btManifoldResult::getPersistentManifold))
	.function("getPersistentManifold", select_overload<btPersistentManifold()>(&btManifoldResult::getPersistentManifold))
	.function("setShapeIdentifiersA", &btManifoldResult::setShapeIdentifiersA)
	.function("setShapeIdentifiersB", &btManifoldResult::setShapeIdentifiersB)
	.function("addContactPoint", &btManifoldResult::addContactPoint)
	.function("refreshContactPoints", &btManifoldResult::refreshContactPoints)
	.function("getBody0Wrap", &btManifoldResult::getBody0Wrap)
	.function("getBody1Wrap", &btManifoldResult::getBody1Wrap)
	.function("setBody0Wrap", &btManifoldResult::setBody0Wrap)
	.function("setBody1Wrap", &btManifoldResult::setBody1Wrap)
	.function("getBody0Internal", &btManifoldResult::getBody0Internal)
	.function("getBody1Internal", &btManifoldResult::getBody1Internal)
	.class_function("calculateCombinedRestitution", &btManifoldResult::calculateCombinedRestitution)
	.class_function("calculateCombinedFriction", &btManifoldResult::calculateCombinedFriction)
	.class_function("calculateCombinedRollingFriction", &btManifoldResult::calculateCombinedRollingFriction)
	.class_function("calculateCombinedSpinningFriction", &btManifoldResult::calculateCombinedSpinningFriction)
	.class_function("calculateCombinedContactDamping", &btManifoldResult::calculateCombinedContactDamping)
	.class_function("calculateCombinedContactStiffness", &btManifoldResult::calculateCombinedContactStiffness)
	enum_<btCollisionDispatcher::DispatcherFlags>("btCollisionDispatcher::DispatcherFlags")
		;
	.function("getDispatcherFlags", &btCollisionDispatcher::getDispatcherFlags)
	.function("setDispatcherFlags", &btCollisionDispatcher::setDispatcherFlags)
	.function("registerCollisionCreateFunc", &btCollisionDispatcher::registerCollisionCreateFunc)
	.function("registerClosestPointsCreateFunc", &btCollisionDispatcher::registerClosestPointsCreateFunc)
	.function("getManifoldByIndexInternal_int", select_overload<btPersistentManifold(int)>(&btCollisionDispatcher::getManifoldByIndexInternal))
	.function("getManifoldByIndexInternal_int", select_overload<q(const).btPersistentManifold(int)const>(&btCollisionDispatcher::getManifoldByIndexInternal))
	.constructor<p.btCollisionConfiguration>()
	.function("setNearCallback", &btCollisionDispatcher::setNearCallback)
	.function("getNearCallback", &btCollisionDispatcher::getNearCallback)
	.class_function("defaultNearCallback", &btCollisionDispatcher::defaultNearCallback)
	.function("getCollisionConfiguration", select_overload<btCollisionConfiguration()>(&btCollisionDispatcher::getCollisionConfiguration))
	.function("getCollisionConfiguration", select_overload<q(const).btCollisionConfiguration()const>(&btCollisionDispatcher::getCollisionConfiguration))
	.function("setCollisionConfiguration", &btCollisionDispatcher::setCollisionConfiguration)
	.function("getInternalManifoldPool", select_overload<btPoolAllocator()>(&btCollisionDispatcher::getInternalManifoldPool))
	.function("getInternalManifoldPool", select_overload<q(const).btPoolAllocator()const>(&btCollisionDispatcher::getInternalManifoldPool))
	.function("serializeCollisionObjects", &btCollisionWorld::serializeCollisionObjects)
	.constructor<p.btDispatcher,p.btBroadphaseInterface,p.btCollisionConfiguration>()
	.function("setBroadphase", &btCollisionWorld::setBroadphase)
	.function("getBroadphase", select_overload<q(const).btBroadphaseInterface()const>(&btCollisionWorld::getBroadphase))
	.function("getBroadphase", select_overload<btBroadphaseInterface()>(&btCollisionWorld::getBroadphase))
	.function("getPairCache", &btCollisionWorld::getPairCache)
	.function("getDispatcher", select_overload<btDispatcher()>(&btCollisionWorld::getDispatcher))
	.function("getDispatcher", select_overload<q(const).btDispatcher()const>(&btCollisionWorld::getDispatcher))
	.function("updateSingleAabb", &btCollisionWorld::updateSingleAabb)
	.function("updateAabbs", &btCollisionWorld::updateAabbs)
	.function("computeOverlappingPairs", &btCollisionWorld::computeOverlappingPairs)
	.function("setDebugDrawer", &btCollisionWorld::setDebugDrawer)
	.function("getDebugDrawer", &btCollisionWorld::getDebugDrawer)
	.function("debugDrawWorld", &btCollisionWorld::debugDrawWorld)
	.function("debugDrawObject", &btCollisionWorld::debugDrawObject)
	.function("getNumCollisionObjects", &btCollisionWorld::getNumCollisionObjects)
	.function("rayTest", &btCollisionWorld::rayTest)
	.function("convexSweepTest_p.q(const).btConvexShape_r.q(const).btTransform_r.q(const).btTransform_r.btCollisionWorld::ConvexResultCallback_btScalar", select_overload<void(p.q(const).btConvexShape, r.q(const).btTransform, r.q(const).btTransform, r.btCollisionWorld::ConvexResultCallback, btScalar)const>(&btCollisionWorld::convexSweepTest))
	.function("convexSweepTest_p.q(const).btConvexShape_r.q(const).btTransform_r.q(const).btTransform_r.btCollisionWorld::ConvexResultCallback", select_overload<void(p.q(const).btConvexShape, r.q(const).btTransform, r.q(const).btTransform, r.btCollisionWorld::ConvexResultCallback)const>(&btCollisionWorld::convexSweepTest))
	.function("contactTest", &btCollisionWorld::contactTest)
	.function("contactPairTest", &btCollisionWorld::contactPairTest)
	.class_function("rayTestSingle", &btCollisionWorld::rayTestSingle)
	.class_function("rayTestSingleInternal", &btCollisionWorld::rayTestSingleInternal)
	.class_function("objectQuerySingle", &btCollisionWorld::objectQuerySingle)
	.class_function("objectQuerySingleInternal", &btCollisionWorld::objectQuerySingleInternal)
	.function("addCollisionObject_p.btCollisionObject_int_int", select_overload<void(p.btCollisionObject, int, int)>(&btCollisionWorld::addCollisionObject))
	.function("addCollisionObject_p.btCollisionObject_int", select_overload<void(p.btCollisionObject, int)>(&btCollisionWorld::addCollisionObject))
	.function("addCollisionObject_p.btCollisionObject", select_overload<void(p.btCollisionObject)>(&btCollisionWorld::addCollisionObject))
	.function("getCollisionObjectArray", select_overload<btCollisionObjectArray()>(&btCollisionWorld::getCollisionObjectArray))
	.function("getCollisionObjectArray", select_overload<q(const).btCollisionObjectArray()const>(&btCollisionWorld::getCollisionObjectArray))
	.function("removeCollisionObject", &btCollisionWorld::removeCollisionObject)
	.function("performDiscreteCollisionDetection", &btCollisionWorld::performDiscreteCollisionDetection)
	.function("getDispatchInfo", select_overload<btDispatcherInfo()>(&btCollisionWorld::getDispatchInfo))
	.function("getDispatchInfo", select_overload<q(const).btDispatcherInfo()const>(&btCollisionWorld::getDispatchInfo))
	.function("getForceUpdateAllAabbs", &btCollisionWorld::getForceUpdateAllAabbs)
	.function("setForceUpdateAllAabbs", &btCollisionWorld::setForceUpdateAllAabbs)
	.function("serialize", &btCollisionWorld::serialize)
	.function("removeChildAlgorithms", &btCompoundCollisionAlgorithm::removeChildAlgorithms)
	.function("preallocateChildAlgorithms", &btCompoundCollisionAlgorithm::preallocateChildAlgorithms)
	.constructor<r.q(const).btCollisionAlgorithmConstructionInfo,p.q(const).btCollisionObjectWrapper,p.q(const).btCollisionObjectWrapper,bool>()
	.function("getChildAlgorithm", &btCompoundCollisionAlgorithm::getChildAlgorithm)
	.constructor<int,int>()
	.function("removeAllPairs", &btHashedSimplePairCache::removeAllPairs)
	.function("removeOverlappingPair", &btHashedSimplePairCache::removeOverlappingPair)
	.function("addOverlappingPair", &btHashedSimplePairCache::addOverlappingPair)
	.function("getOverlappingPairArrayPtr", select_overload<btSimplePair()>(&btHashedSimplePairCache::getOverlappingPairArrayPtr))
	.function("getOverlappingPairArrayPtr", select_overload<q(const).btSimplePair()const>(&btHashedSimplePairCache::getOverlappingPairArrayPtr))
	.function("getOverlappingPairArray", select_overload<btSimplePairArray()>(&btHashedSimplePairCache::getOverlappingPairArray))
	.function("getOverlappingPairArray", select_overload<q(const).btSimplePairArray()const>(&btHashedSimplePairCache::getOverlappingPairArray))
	.function("findPair", &btHashedSimplePairCache::findPair)
	.function("GetCount", &btHashedSimplePairCache::GetCount)
	.function("getNumOverlappingPairs", &btHashedSimplePairCache::getNumOverlappingPairs)
	.function("internalAddPair", &btHashedSimplePairCache::internalAddPair)
	.function("growTables", &btHashedSimplePairCache::growTables)
	.function("equalsPair", &btHashedSimplePairCache::equalsPair)
	.function("getHash", &btHashedSimplePairCache::getHash)
	.function("internalFindPair", &btHashedSimplePairCache::internalFindPair)
	.function("removeChildAlgorithms", &btCompoundCompoundCollisionAlgorithm::removeChildAlgorithms)
	.constructor<r.q(const).btCollisionAlgorithmConstructionInfo,p.q(const).btCollisionObjectWrapper,p.q(const).btCollisionObjectWrapper,bool>()
	.function("reset", &btUsageBitfield::reset)
	.function("reset", &btSubSimplexClosestResult::reset)
	.function("isValid", &btSubSimplexClosestResult::isValid)
	.function("setBarycentricCoordinates_btScalar_btScalar_btScalar_btScalar", select_overload<void(btScalar, btScalar, btScalar, btScalar)>(&btSubSimplexClosestResult::setBarycentricCoordinates))
	.function("setBarycentricCoordinates_btScalar_btScalar_btScalar", select_overload<void(btScalar, btScalar, btScalar)>(&btSubSimplexClosestResult::setBarycentricCoordinates))
	.function("setBarycentricCoordinates_btScalar_btScalar", select_overload<void(btScalar, btScalar)>(&btSubSimplexClosestResult::setBarycentricCoordinates))
	.function("setBarycentricCoordinates_btScalar", select_overload<void(btScalar)>(&btSubSimplexClosestResult::setBarycentricCoordinates))
	.function("setBarycentricCoordinates", select_overload<void()>(&btSubSimplexClosestResult::setBarycentricCoordinates))
	.function("removeVertex", &btVoronoiSimplexSolver::removeVertex)
	.function("reduceVertices", &btVoronoiSimplexSolver::reduceVertices)
	.function("updateClosestVectorAndPoints", &btVoronoiSimplexSolver::updateClosestVectorAndPoints)
	.function("closestPtPointTetrahedron", &btVoronoiSimplexSolver::closestPtPointTetrahedron)
	.function("pointOutsideOfPlane", &btVoronoiSimplexSolver::pointOutsideOfPlane)
	.function("closestPtPointTriangle", &btVoronoiSimplexSolver::closestPtPointTriangle)
	.function("reset", &btVoronoiSimplexSolver::reset)
	.function("addVertex", &btVoronoiSimplexSolver::addVertex)
	.function("setEqualVertexThreshold", &btVoronoiSimplexSolver::setEqualVertexThreshold)
	.function("getEqualVertexThreshold", &btVoronoiSimplexSolver::getEqualVertexThreshold)
	.function("closest", &btVoronoiSimplexSolver::closest)
	.function("maxVertex", &btVoronoiSimplexSolver::maxVertex)
	.function("fullSimplex", &btVoronoiSimplexSolver::fullSimplex)
	.function("getSimplex", &btVoronoiSimplexSolver::getSimplex)
	.function("inSimplex", &btVoronoiSimplexSolver::inSimplex)
	.function("backup_closest", &btVoronoiSimplexSolver::backup_closest)
	.function("emptySimplex", &btVoronoiSimplexSolver::emptySimplex)
	.function("compute_points", &btVoronoiSimplexSolver::compute_points)
	.function("numVertices", &btVoronoiSimplexSolver::numVertices)
	.constructor<p.q(const).btConvexShape,p.q(const).btConvexShape,p.btVoronoiSimplexSolver,p.btConvexPenetrationDepthSolver>()
	.constructor<p.q(const).btConvexShape,p.q(const).btConvexShape,int,int,btScalar,btScalar,p.btVoronoiSimplexSolver,p.btConvexPenetrationDepthSolver>()
	.function("getClosestPoints_r.q(const).btDiscreteCollisionDetectorInterface::ClosestPointInput_r.btDiscreteCollisionDetectorInterface::Result_p.btIDebugDraw_bool", select_overload<void(r.q(const).btDiscreteCollisionDetectorInterface::ClosestPointInput, r.btDiscreteCollisionDetectorInterface::Result, p.btIDebugDraw, bool)>(&btGjkPairDetector::getClosestPoints))
	.function("getClosestPoints_r.q(const).btDiscreteCollisionDetectorInterface::ClosestPointInput_r.btDiscreteCollisionDetectorInterface::Result_p.btIDebugDraw", select_overload<void(r.q(const).btDiscreteCollisionDetectorInterface::ClosestPointInput, r.btDiscreteCollisionDetectorInterface::Result, p.btIDebugDraw)>(&btGjkPairDetector::getClosestPoints))
	.function("getClosestPointsNonVirtual", &btGjkPairDetector::getClosestPointsNonVirtual)
	.function("setMinkowskiA", &btGjkPairDetector::setMinkowskiA)
	.function("setMinkowskiB", &btGjkPairDetector::setMinkowskiB)
	.function("setCachedSeperatingAxis", &btGjkPairDetector::setCachedSeperatingAxis)
	.function("getCachedSeparatingAxis", &btGjkPairDetector::getCachedSeparatingAxis)
	.function("getCachedSeparatingDistance", &btGjkPairDetector::getCachedSeparatingDistance)
	.function("setPenetrationDepthSolver", &btGjkPairDetector::setPenetrationDepthSolver)
	.function("setIgnoreMargin", &btGjkPairDetector::setIgnoreMargin)
	.constructor<p.btPersistentManifold,r.q(const).btCollisionAlgorithmConstructionInfo,p.q(const).btCollisionObjectWrapper,p.q(const).btCollisionObjectWrapper,p.btVoronoiSimplexSolver,p.btConvexPenetrationDepthSolver,int,int>()
	.function("setLowLevelOfDetail", &btConvex2dConvex2dAlgorithm::setLowLevelOfDetail)
	.function("getManifold", &btConvex2dConvex2dAlgorithm::getManifold)
	.function("processTriangle", &btTriangleCallback::processTriangle)
	.function("internalProcessTriangleIndex", &btInternalTriangleIndexCallback::internalProcessTriangleIndex)
	.constructor<p.btDispatcher,p.q(const).btCollisionObjectWrapper,p.q(const).btCollisionObjectWrapper,bool>()
	.function("setTimeStepAndCounters", &btConvexTriangleCallback::setTimeStepAndCounters)
	.function("clearWrapperData", &btConvexTriangleCallback::clearWrapperData)
	.function("clearCache", &btConvexTriangleCallback::clearCache)
	.function("getAabbMin", &btConvexTriangleCallback::getAabbMin)
	.function("getAabbMax", &btConvexTriangleCallback::getAabbMax)
	.constructor<r.q(const).btCollisionAlgorithmConstructionInfo,p.q(const).btCollisionObjectWrapper,p.q(const).btCollisionObjectWrapper,bool>()
	.function("clearCache", &btConvexConcaveCollisionAlgorithm::clearCache)
	.class_function("clipHullAgainstHull", &btPolyhedralContactClipping::clipHullAgainstHull)
	.class_function("clipFaceAgainstHull", &btPolyhedralContactClipping::clipFaceAgainstHull)
	.class_function("findSeparatingAxis", &btPolyhedralContactClipping::findSeparatingAxis)
	.class_function("clipFace", &btPolyhedralContactClipping::clipFace)
	.constructor<p.btPersistentManifold,r.q(const).btCollisionAlgorithmConstructionInfo,p.q(const).btCollisionObjectWrapper,p.q(const).btCollisionObjectWrapper,p.btConvexPenetrationDepthSolver,int,int>()
	.function("setLowLevelOfDetail", &btConvexConvexAlgorithm::setLowLevelOfDetail)
	.function("getManifold", &btConvexConvexAlgorithm::getManifold)
	.constructor<p.btPersistentManifold,r.q(const).btCollisionAlgorithmConstructionInfo,p.q(const).btCollisionObjectWrapper,p.q(const).btCollisionObjectWrapper,bool,int,int>()
	.function("collideSingleContact", &btConvexPlaneCollisionAlgorithm::collideSingleContact)
	.constructor<r.q(const).btDefaultCollisionConstructionInfo>()
	.function("setConvexConvexMultipointIterations_int_int", select_overload<void(int, int)>(&btDefaultCollisionConfiguration::setConvexConvexMultipointIterations))
	.function("setConvexConvexMultipointIterations_int", select_overload<void(int)>(&btDefaultCollisionConfiguration::setConvexConvexMultipointIterations))
	.function("setConvexConvexMultipointIterations", select_overload<void()>(&btDefaultCollisionConfiguration::setConvexConvexMultipointIterations))
	.function("setPlaneConvexMultipointIterations_int_int", select_overload<void(int, int)>(&btDefaultCollisionConfiguration::setPlaneConvexMultipointIterations))
	.function("setPlaneConvexMultipointIterations_int", select_overload<void(int)>(&btDefaultCollisionConfiguration::setPlaneConvexMultipointIterations))
	.function("setPlaneConvexMultipointIterations", select_overload<void()>(&btDefaultCollisionConfiguration::setPlaneConvexMultipointIterations))
	.constructor<r.q(const).btCollisionAlgorithmConstructionInfo>()
	.function("convexSweepTest_p.q(const).btConvexShape_r.q(const).btTransform_r.q(const).btTransform_r.btCollisionWorld::ConvexResultCallback_btScalar", select_overload<void(p.q(const).btConvexShape, r.q(const).btTransform, r.q(const).btTransform, r.btCollisionWorld::ConvexResultCallback, btScalar)const>(&btGhostObject::convexSweepTest))
	.function("convexSweepTest_p.q(const).btConvexShape_r.q(const).btTransform_r.q(const).btTransform_r.btCollisionWorld::ConvexResultCallback", select_overload<void(p.q(const).btConvexShape, r.q(const).btTransform, r.q(const).btTransform, r.btCollisionWorld::ConvexResultCallback)const>(&btGhostObject::convexSweepTest))
	.function("rayTest", &btGhostObject::rayTest)
	.function("addOverlappingObjectInternal_p.btBroadphaseProxy_p.btBroadphaseProxy", select_overload<void(p.btBroadphaseProxy, p.btBroadphaseProxy)>(&btGhostObject::addOverlappingObjectInternal))
	.function("addOverlappingObjectInternal_p.btBroadphaseProxy", select_overload<void(p.btBroadphaseProxy)>(&btGhostObject::addOverlappingObjectInternal))
	.function("removeOverlappingObjectInternal_p.btBroadphaseProxy_p.btDispatcher_p.btBroadphaseProxy", select_overload<void(p.btBroadphaseProxy, p.btDispatcher, p.btBroadphaseProxy)>(&btGhostObject::removeOverlappingObjectInternal))
	.function("removeOverlappingObjectInternal_p.btBroadphaseProxy_p.btDispatcher", select_overload<void(p.btBroadphaseProxy, p.btDispatcher)>(&btGhostObject::removeOverlappingObjectInternal))
	.function("getNumOverlappingObjects", &btGhostObject::getNumOverlappingObjects)
	.function("getOverlappingObject_int", select_overload<btCollisionObject(int)>(&btGhostObject::getOverlappingObject))
	.function("getOverlappingObject_int", select_overload<q(const).btCollisionObject(int)const>(&btGhostObject::getOverlappingObject))
	.function("getOverlappingPairs", select_overload<btAlignedObjectArray<(p.btCollisionObject)>()>(&btGhostObject::getOverlappingPairs))
	.function("getOverlappingPairs", select_overload<q(const).btAlignedObjectArray<(p.btCollisionObject)>()const>(&btGhostObject::getOverlappingPairs))
	.class_function("upcast", &btGhostObject::upcast)
	.class_function("upcast", &btGhostObject::upcast)
	.function("addOverlappingObjectInternal_p.btBroadphaseProxy_p.btBroadphaseProxy", select_overload<void(p.btBroadphaseProxy, p.btBroadphaseProxy)>(&btPairCachingGhostObject::addOverlappingObjectInternal))
	.function("addOverlappingObjectInternal_p.btBroadphaseProxy", select_overload<void(p.btBroadphaseProxy)>(&btPairCachingGhostObject::addOverlappingObjectInternal))
	.function("removeOverlappingObjectInternal_p.btBroadphaseProxy_p.btDispatcher_p.btBroadphaseProxy", select_overload<void(p.btBroadphaseProxy, p.btDispatcher, p.btBroadphaseProxy)>(&btPairCachingGhostObject::removeOverlappingObjectInternal))
	.function("removeOverlappingObjectInternal_p.btBroadphaseProxy_p.btDispatcher", select_overload<void(p.btBroadphaseProxy, p.btDispatcher)>(&btPairCachingGhostObject::removeOverlappingObjectInternal))
	.function("getOverlappingPairCache", &btPairCachingGhostObject::getOverlappingPairCache)
	.constructor<int>()
	.function("getUid1", &btHashInt::getUid1)
	.function("setUid1", &btHashInt::setUid1)
	.function("equals", &btHashInt::equals)
	.function("getHash", &btHashInt::getHash)
	.constructor<p.q(const).void>()
	.function("getPointer", &btHashPtr::getPointer)
	.function("equals", &btHashPtr::equals)
	.function("getHash", &btHashPtr::getHash)
	enum_<btSerializationFlags>("btSerializationFlags")
		;
	.function("getBufferPointer", &btSerializer::getBufferPointer)
	.function("getCurrentBufferSize", &btSerializer::getCurrentBufferSize)
	.function("allocate", &btSerializer::allocate)
	.function("finalizeChunk", &btSerializer::finalizeChunk)
	.function("findPointer", &btSerializer::findPointer)
	.function("getUniquePointer", &btSerializer::getUniquePointer)
	.function("startSerialization", &btSerializer::startSerialization)
	.function("finishSerialization", &btSerializer::finishSerialization)
	.function("findNameForPointer", &btSerializer::findNameForPointer)
	.function("registerNameForPointer", &btSerializer::registerNameForPointer)
	.function("serializeName", &btSerializer::serializeName)
	.function("getSerializationFlags", &btSerializer::getSerializationFlags)
	.function("setSerializationFlags", &btSerializer::setSerializationFlags)
	.function("getNumChunks", &btSerializer::getNumChunks)
	.function("getChunk", &btSerializer::getChunk)
	.function("findPointer", &btDefaultSerializer::findPointer)
	.function("writeDNA", &btDefaultSerializer::writeDNA)
	.function("getReverseType", &btDefaultSerializer::getReverseType)
	.function("initDNA", &btDefaultSerializer::initDNA)
	.constructor<int,p.unsigned char>()
	.constructor<int>()
	.class_function("getMemoryDnaSizeInBytes", &btDefaultSerializer::getMemoryDnaSizeInBytes)
	.class_function("getMemoryDna", &btDefaultSerializer::getMemoryDna)
	.function("insertHeader", &btDefaultSerializer::insertHeader)
	.function("writeHeader", &btDefaultSerializer::writeHeader)
	.function("internalAlloc", &btDefaultSerializer::internalAlloc)
	.function("calculateSerializeBufferSize", &btTriangleInfoMap::calculateSerializeBufferSize)
	.function("serialize", &btTriangleInfoMap::serialize)
	.function("deSerialize", &btTriangleInfoMap::deSerialize)
	enum_<btInternalEdgeAdjustFlags>("btInternalEdgeAdjustFlags")
		;
	.function("sortIslands", &btUnionFind::sortIslands)
	.function("reset", &btUnionFind::reset)
	.function("getNumElements", &btUnionFind::getNumElements)
	.function("isRoot", &btUnionFind::isRoot)
	.function("getElement_int", select_overload<btElement(int)>(&btUnionFind::getElement))
	.function("getElement_int", select_overload<q(const).btElement(int)const>(&btUnionFind::getElement))
	.function("allocate", &btUnionFind::allocate)
	.function("Free", &btUnionFind::Free)
	.function("find_int_int", select_overload<int(int, int)>(&btUnionFind::find))
	.function("unite", &btUnionFind::unite)
	.function("find_int", select_overload<int(int)>(&btUnionFind::find))
	.function("initUnionFind", &btSimulationIslandManager::initUnionFind)
	.function("getUnionFind", &btSimulationIslandManager::getUnionFind)
	.function("updateActivationState", &btSimulationIslandManager::updateActivationState)
	.function("storeIslandActivationState", &btSimulationIslandManager::storeIslandActivationState)
	.function("findUnions", &btSimulationIslandManager::findUnions)
	.function("buildAndProcessIslands", &btSimulationIslandManager::buildAndProcessIslands)
	.function("buildIslands", &btSimulationIslandManager::buildIslands)
	.function("getSplitIslands", &btSimulationIslandManager::getSplitIslands)
	.function("setSplitIslands", &btSimulationIslandManager::setSplitIslands)
	.constructor<p.btPersistentManifold,r.q(const).btCollisionAlgorithmConstructionInfo,p.q(const).btCollisionObjectWrapper,p.q(const).btCollisionObjectWrapper,bool>()
	.function("getSphereDistance", &btSphereBoxCollisionAlgorithm::getSphereDistance)
	.function("getSpherePenetration", &btSphereBoxCollisionAlgorithm::getSpherePenetration)
	.constructor<p.btPersistentManifold,r.q(const).btCollisionAlgorithmConstructionInfo,p.q(const).btCollisionObjectWrapper,p.q(const).btCollisionObjectWrapper>()
	.constructor<r.q(const).btCollisionAlgorithmConstructionInfo>()
	.constructor<p.btPersistentManifold,r.q(const).btCollisionAlgorithmConstructionInfo,p.q(const).btCollisionObjectWrapper,p.q(const).btCollisionObjectWrapper,bool>()
	.constructor<r.q(const).btCollisionAlgorithmConstructionInfo>()
	.function("getClosestPoints_r.q(const).btDiscreteCollisionDetectorInterface::ClosestPointInput_r.btDiscreteCollisionDetectorInterface::Result_p.btIDebugDraw_bool", select_overload<void(r.q(const).btDiscreteCollisionDetectorInterface::ClosestPointInput, r.btDiscreteCollisionDetectorInterface::Result, p.btIDebugDraw, bool)>(&SphereTriangleDetector::getClosestPoints))
	.function("getClosestPoints_r.q(const).btDiscreteCollisionDetectorInterface::ClosestPointInput_r.btDiscreteCollisionDetectorInterface::Result_p.btIDebugDraw", select_overload<void(r.q(const).btDiscreteCollisionDetectorInterface::ClosestPointInput, r.btDiscreteCollisionDetectorInterface::Result, p.btIDebugDraw)>(&SphereTriangleDetector::getClosestPoints))
	.constructor<p.btSphereShape,p.btTriangleShape,btScalar>()
	.function("collide", &SphereTriangleDetector::collide)
	.function("pointInTriangle", &SphereTriangleDetector::pointInTriangle)
	.function("facecontains", &SphereTriangleDetector::facecontains)
	.function("getAabb", &btCollisionShape::getAabb)
	.function("getBoundingSphere", &btCollisionShape::getBoundingSphere)
	.function("getAngularMotionDisc", &btCollisionShape::getAngularMotionDisc)
	.function("getContactBreakingThreshold", &btCollisionShape::getContactBreakingThreshold)
	.function("calculateTemporalAabb", &btCollisionShape::calculateTemporalAabb)
	.function("isPolyhedral", &btCollisionShape::isPolyhedral)
	.function("isConvex2d", &btCollisionShape::isConvex2d)
	.function("isConvex", &btCollisionShape::isConvex)
	.function("isNonMoving", &btCollisionShape::isNonMoving)
	.function("isConcave", &btCollisionShape::isConcave)
	.function("isCompound", &btCollisionShape::isCompound)
	.function("isSoftBody", &btCollisionShape::isSoftBody)
	.function("isInfinite", &btCollisionShape::isInfinite)
	.function("setLocalScaling", &btCollisionShape::setLocalScaling)
	.function("getLocalScaling", &btCollisionShape::getLocalScaling)
	.function("calculateLocalInertia", &btCollisionShape::calculateLocalInertia)
	.function("getName", &btCollisionShape::getName)
	.function("getShapeType", &btCollisionShape::getShapeType)
	.function("getAnisotropicRollingFrictionDirection", &btCollisionShape::getAnisotropicRollingFrictionDirection)
	.function("setMargin", &btCollisionShape::setMargin)
	.function("getMargin", &btCollisionShape::getMargin)
	.function("setUserPointer", &btCollisionShape::setUserPointer)
	.function("getUserPointer", &btCollisionShape::getUserPointer)
	.function("setUserIndex", &btCollisionShape::setUserIndex)
	.function("getUserIndex", &btCollisionShape::getUserIndex)
	.function("calculateSerializeBufferSize", &btCollisionShape::calculateSerializeBufferSize)
	.function("serialize", &btCollisionShape::serialize)
	.function("serializeSingleShape", &btCollisionShape::serializeSingleShape)
	.function("localGetSupportingVertex", &btConvexShape::localGetSupportingVertex)
	.function("localGetSupportingVertexWithoutMargin", &btConvexShape::localGetSupportingVertexWithoutMargin)
	.function("localGetSupportVertexWithoutMarginNonVirtual", &btConvexShape::localGetSupportVertexWithoutMarginNonVirtual)
	.function("localGetSupportVertexNonVirtual", &btConvexShape::localGetSupportVertexNonVirtual)
	.function("getMarginNonVirtual", &btConvexShape::getMarginNonVirtual)
	.function("getAabbNonVirtual", &btConvexShape::getAabbNonVirtual)
	.function("project", &btConvexShape::project)
	.function("batchedUnitVectorGetSupportingVertexWithoutMargin", &btConvexShape::batchedUnitVectorGetSupportingVertexWithoutMargin)
	.function("getAabbSlow", &btConvexShape::getAabbSlow)
	.function("getNumPreferredPenetrationDirections", &btConvexShape::getNumPreferredPenetrationDirections)
	.function("getPreferredPenetrationDirection", &btConvexShape::getPreferredPenetrationDirection)
	.function("getImplicitShapeDimensions", &btConvexInternalShape::getImplicitShapeDimensions)
	.function("setImplicitShapeDimensions", &btConvexInternalShape::setImplicitShapeDimensions)
	.function("setSafeMargin_btScalar_btScalar", select_overload<void(btScalar, btScalar)>(&btConvexInternalShape::setSafeMargin))
	.function("setSafeMargin_btScalar", select_overload<void(btScalar)>(&btConvexInternalShape::setSafeMargin))
	.function("setSafeMargin_r.q(const).btVector3_btScalar", select_overload<void(r.q(const).btVector3, btScalar)>(&btConvexInternalShape::setSafeMargin))
	.function("setSafeMargin_r.q(const).btVector3", select_overload<void(r.q(const).btVector3)>(&btConvexInternalShape::setSafeMargin))
	.function("getLocalScalingNV", &btConvexInternalShape::getLocalScalingNV)
	.function("getMarginNV", &btConvexInternalShape::getMarginNV)
	.function("setCachedLocalAabb", &btConvexInternalAabbCachingShape::setCachedLocalAabb)
	.function("getCachedLocalAabb", &btConvexInternalAabbCachingShape::getCachedLocalAabb)
	.function("getNonvirtualAabb", &btConvexInternalAabbCachingShape::getNonvirtualAabb)
	.function("recalcLocalAabb", &btConvexInternalAabbCachingShape::recalcLocalAabb)
	.function("initializePolyhedralFeatures_int", select_overload<bool(int)>(&btPolyhedralConvexShape::initializePolyhedralFeatures))
	.function("initializePolyhedralFeatures", select_overload<bool()>(&btPolyhedralConvexShape::initializePolyhedralFeatures))
	.function("getConvexPolyhedron", &btPolyhedralConvexShape::getConvexPolyhedron)
	.function("getNumVertices", &btPolyhedralConvexShape::getNumVertices)
	.function("getNumEdges", &btPolyhedralConvexShape::getNumEdges)
	.function("getEdge", &btPolyhedralConvexShape::getEdge)
	.function("getVertex", &btPolyhedralConvexShape::getVertex)
	.function("getNumPlanes", &btPolyhedralConvexShape::getNumPlanes)
	.function("getPlane", &btPolyhedralConvexShape::getPlane)
	.function("setCachedLocalAabb", &btPolyhedralConvexAabbCachingShape::setCachedLocalAabb)
	.function("getCachedLocalAabb", &btPolyhedralConvexAabbCachingShape::getCachedLocalAabb)
	.function("getNonvirtualAabb", &btPolyhedralConvexAabbCachingShape::getNonvirtualAabb)
	.function("recalcLocalAabb", &btPolyhedralConvexAabbCachingShape::recalcLocalAabb)
	.function("getHalfExtentsWithMargin", &btBox2dShape::getHalfExtentsWithMargin)
	.function("getHalfExtentsWithoutMargin", &btBox2dShape::getHalfExtentsWithoutMargin)
	.constructor<r.q(const).btVector3>()
	.function("getVertexCount", &btBox2dShape::getVertexCount)
	.function("getVertices", &btBox2dShape::getVertices)
	.function("getNormals", &btBox2dShape::getNormals)
	.function("getCentroid", &btBox2dShape::getCentroid)
	.function("getPlaneEquation", &btBox2dShape::getPlaneEquation)
	.function("getHalfExtentsWithMargin", &btBoxShape::getHalfExtentsWithMargin)
	.function("getHalfExtentsWithoutMargin", &btBoxShape::getHalfExtentsWithoutMargin)
	.constructor<r.q(const).btVector3>()
	.function("getPlaneEquation", &btBoxShape::getPlaneEquation)
	enum_<PHY_ScalarType>("PHY_ScalarType")
		;
	.function("processAllTriangles", &btConcaveShape::processAllTriangles)
	.function("InternalProcessAllTriangles", &btStridingMeshInterface::InternalProcessAllTriangles)
	.function("calculateAabbBruteForce", &btStridingMeshInterface::calculateAabbBruteForce)
	.function("getLockedVertexIndexBase_p.p.unsigned char_r.int_r.PHY_ScalarType_r.int_p.p.unsigned char_r.int_r.int_r.PHY_ScalarType_int", select_overload<void(p.p.unsigned char, r.int, r.PHY_ScalarType, r.int, p.p.unsigned char, r.int, r.int, r.PHY_ScalarType, int)>(&btStridingMeshInterface::getLockedVertexIndexBase))
	.function("getLockedVertexIndexBase_p.p.unsigned char_r.int_r.PHY_ScalarType_r.int_p.p.unsigned char_r.int_r.int_r.PHY_ScalarType", select_overload<void(p.p.unsigned char, r.int, r.PHY_ScalarType, r.int, p.p.unsigned char, r.int, r.int, r.PHY_ScalarType)>(&btStridingMeshInterface::getLockedVertexIndexBase))
	.function("getLockedReadOnlyVertexIndexBase_p.p.q(const).unsigned char_r.int_r.PHY_ScalarType_r.int_p.p.q(const).unsigned char_r.int_r.int_r.PHY_ScalarType_int", select_overload<void(p.p.q(const).unsigned char, r.int, r.PHY_ScalarType, r.int, p.p.q(const).unsigned char, r.int, r.int, r.PHY_ScalarType, int)const>(&btStridingMeshInterface::getLockedReadOnlyVertexIndexBase))
	.function("getLockedReadOnlyVertexIndexBase_p.p.q(const).unsigned char_r.int_r.PHY_ScalarType_r.int_p.p.q(const).unsigned char_r.int_r.int_r.PHY_ScalarType", select_overload<void(p.p.q(const).unsigned char, r.int, r.PHY_ScalarType, r.int, p.p.q(const).unsigned char, r.int, r.int, r.PHY_ScalarType)const>(&btStridingMeshInterface::getLockedReadOnlyVertexIndexBase))
	.function("unLockVertexBase", &btStridingMeshInterface::unLockVertexBase)
	.function("unLockReadOnlyVertexBase", &btStridingMeshInterface::unLockReadOnlyVertexBase)
	.function("getNumSubParts", &btStridingMeshInterface::getNumSubParts)
	.function("preallocateVertices", &btStridingMeshInterface::preallocateVertices)
	.function("preallocateIndices", &btStridingMeshInterface::preallocateIndices)
	.function("hasPremadeAabb", &btStridingMeshInterface::hasPremadeAabb)
	.function("setPremadeAabb", &btStridingMeshInterface::setPremadeAabb)
	.function("getPremadeAabb", &btStridingMeshInterface::getPremadeAabb)
	.function("getScaling", &btStridingMeshInterface::getScaling)
	.function("setScaling", &btStridingMeshInterface::setScaling)
	.function("calculateSerializeBufferSize", &btStridingMeshInterface::calculateSerializeBufferSize)
	.function("serialize", &btStridingMeshInterface::serialize)
	.constructor<p.btStridingMeshInterface>()
	.function("localGetSupportingVertex", &btTriangleMeshShape::localGetSupportingVertex)
	.function("localGetSupportingVertexWithoutMargin", &btTriangleMeshShape::localGetSupportingVertexWithoutMargin)
	.function("recalcLocalAabb", &btTriangleMeshShape::recalcLocalAabb)
	.function("getMeshInterface", select_overload<btStridingMeshInterface()>(&btTriangleMeshShape::getMeshInterface))
	.function("getMeshInterface", select_overload<q(const).btStridingMeshInterface()const>(&btTriangleMeshShape::getMeshInterface))
	.function("getLocalAabbMin", &btTriangleMeshShape::getLocalAabbMin)
	.function("getLocalAabbMax", &btTriangleMeshShape::getLocalAabbMax)
	.function("build", &btOptimizedBvh::build)
	.function("refit", &btOptimizedBvh::refit)
	.function("refitPartial", &btOptimizedBvh::refitPartial)
	.function("updateBvhNodes", &btOptimizedBvh::updateBvhNodes)
	.function("serializeInPlace", &btOptimizedBvh::serializeInPlace)
	.class_function("deSerializeInPlace", &btOptimizedBvh::deSerializeInPlace)
	.constructor<p.btStridingMeshInterface,bool,bool>()
	.constructor<p.btStridingMeshInterface,bool>()
	.constructor<p.btStridingMeshInterface,bool,r.q(const).btVector3,r.q(const).btVector3,bool>()
	.constructor<p.btStridingMeshInterface,bool,r.q(const).btVector3,r.q(const).btVector3>()
	.function("getOwnsBvh", &btBvhTriangleMeshShape::getOwnsBvh)
	.function("performRaycast", &btBvhTriangleMeshShape::performRaycast)
	.function("performConvexcast", &btBvhTriangleMeshShape::performConvexcast)
	.function("refitTree", &btBvhTriangleMeshShape::refitTree)
	.function("partialRefitTree", &btBvhTriangleMeshShape::partialRefitTree)
	.function("getOptimizedBvh", &btBvhTriangleMeshShape::getOptimizedBvh)
	.function("setOptimizedBvh_p.btOptimizedBvh_r.q(const).btVector3", select_overload<void(p.btOptimizedBvh, r.q(const).btVector3)>(&btBvhTriangleMeshShape::setOptimizedBvh))
	.function("setOptimizedBvh_p.btOptimizedBvh", select_overload<void(p.btOptimizedBvh)>(&btBvhTriangleMeshShape::setOptimizedBvh))
	.function("buildOptimizedBvh", &btBvhTriangleMeshShape::buildOptimizedBvh)
	.function("usesQuantizedAabbCompression", &btBvhTriangleMeshShape::usesQuantizedAabbCompression)
	.function("setTriangleInfoMap", &btBvhTriangleMeshShape::setTriangleInfoMap)
	.function("getTriangleInfoMap", select_overload<q(const).btTriangleInfoMap()const>(&btBvhTriangleMeshShape::getTriangleInfoMap))
	.function("getTriangleInfoMap", select_overload<btTriangleInfoMap()>(&btBvhTriangleMeshShape::getTriangleInfoMap))
	.function("serializeSingleBvh", &btBvhTriangleMeshShape::serializeSingleBvh)
	.function("serializeSingleTriangleInfoMap", &btBvhTriangleMeshShape::serializeSingleTriangleInfoMap)
	.constructor<btScalar,btScalar>()
	.function("getUpAxis", &btCapsuleShape::getUpAxis)
	.function("getRadius", &btCapsuleShape::getRadius)
	.function("getHalfHeight", &btCapsuleShape::getHalfHeight)
	.function("deSerializeFloat", &btCapsuleShape::deSerializeFloat)
	.constructor<btScalar,btScalar>()
	.constructor<btScalar,btScalar>()
	.constructor<bool,q(const).int>()
	.constructor<bool>()
	.function("addChildShape", &btCompoundShape::addChildShape)
	.function("removeChildShape", &btCompoundShape::removeChildShape)
	.function("removeChildShapeByIndex", &btCompoundShape::removeChildShapeByIndex)
	.function("getNumChildShapes", &btCompoundShape::getNumChildShapes)
	.function("getChildShape_int", select_overload<btCollisionShape(int)>(&btCompoundShape::getChildShape))
	.function("getChildShape_int", select_overload<q(const).btCollisionShape(int)const>(&btCompoundShape::getChildShape))
	.function("getChildTransform_int", select_overload<btTransform(int)>(&btCompoundShape::getChildTransform))
	.function("getChildTransform_int", select_overload<q(const).btTransform(int)const>(&btCompoundShape::getChildTransform))
	.function("updateChildTransform_int_r.q(const).btTransform_bool", select_overload<void(int, r.q(const).btTransform, bool)>(&btCompoundShape::updateChildTransform))
	.function("updateChildTransform_int_r.q(const).btTransform", select_overload<void(int, r.q(const).btTransform)>(&btCompoundShape::updateChildTransform))
	.function("getChildList", &btCompoundShape::getChildList)
	.function("recalculateLocalAabb", &btCompoundShape::recalculateLocalAabb)
	.function("getDynamicAabbTree", select_overload<q(const).btDbvt()const>(&btCompoundShape::getDynamicAabbTree))
	.function("getDynamicAabbTree", select_overload<btDbvt()>(&btCompoundShape::getDynamicAabbTree))
	.function("createAabbTreeFromChildren", &btCompoundShape::createAabbTreeFromChildren)
	.function("calculatePrincipalAxisTransform", &btCompoundShape::calculatePrincipalAxisTransform)
	.function("getUpdateRevision", &btCompoundShape::getUpdateRevision)
	.function("coneLocalSupport", &btConeShape::coneLocalSupport)
	.constructor<btScalar,btScalar>()
	.function("getRadius", &btConeShape::getRadius)
	.function("getHeight", &btConeShape::getHeight)
	.function("setRadius", &btConeShape::setRadius)
	.function("setHeight", &btConeShape::setHeight)
	.function("setConeUpIndex", &btConeShape::setConeUpIndex)
	.function("getConeUpIndex", &btConeShape::getConeUpIndex)
	.constructor<btScalar,btScalar>()
	.constructor<btScalar,btScalar>()
	.constructor<p.btConvexShape>()
	.function("getChildShape", select_overload<btConvexShape()>(&btConvex2dShape::getChildShape))
	.function("getChildShape", select_overload<q(const).btConvexShape()const>(&btConvex2dShape::getChildShape))
	.constructor<p.q(const).btScalar,int,int>()
	.constructor<p.q(const).btScalar,int>()
	.constructor<p.q(const).btScalar>()
	.function("addPoint_r.q(const).btVector3_bool", select_overload<void(r.q(const).btVector3, bool)>(&btConvexHullShape::addPoint))
	.function("addPoint_r.q(const).btVector3", select_overload<void(r.q(const).btVector3)>(&btConvexHullShape::addPoint))
	.function("getUnscaledPoints", select_overload<btVector3()>(&btConvexHullShape::getUnscaledPoints))
	.function("getUnscaledPoints", select_overload<q(const).btVector3()const>(&btConvexHullShape::getUnscaledPoints))
	.function("getPoints", &btConvexHullShape::getPoints)
	.function("optimizeConvexHull", &btConvexHullShape::optimizeConvexHull)
	.function("getScaledPoint", &btConvexHullShape::getScaledPoint)
	.function("getNumPoints", &btConvexHullShape::getNumPoints)
	.constructor<p.btVector3,int,r.q(const).btVector3,bool>()
	.constructor<p.btVector3,int,r.q(const).btVector3>()
	.function("setPoints_p.btVector3_int_bool_r.q(const).btVector3", select_overload<void(p.btVector3, int, bool, r.q(const).btVector3)>(&btConvexPointCloudShape::setPoints))
	.function("setPoints_p.btVector3_int_bool", select_overload<void(p.btVector3, int, bool)>(&btConvexPointCloudShape::setPoints))
	.function("setPoints_p.btVector3_int", select_overload<void(p.btVector3, int)>(&btConvexPointCloudShape::setPoints))
	.function("getUnscaledPoints", select_overload<btVector3()>(&btConvexPointCloudShape::getUnscaledPoints))
	.function("getUnscaledPoints", select_overload<q(const).btVector3()const>(&btConvexPointCloudShape::getUnscaledPoints))
	.function("getNumPoints", &btConvexPointCloudShape::getNumPoints)
	.function("getScaledPoint", &btConvexPointCloudShape::getScaledPoint)
	.function("initialize", &btConvexPolyhedron::initialize)
	.function("testContainment", &btConvexPolyhedron::testContainment)
	.function("project", &btConvexPolyhedron::project)
	.constructor<p.btStridingMeshInterface,bool>()
	.constructor<p.btStridingMeshInterface>()
	.function("getMeshInterface", select_overload<btStridingMeshInterface()>(&btConvexTriangleMeshShape::getMeshInterface))
	.function("getMeshInterface", select_overload<q(const).btStridingMeshInterface()const>(&btConvexTriangleMeshShape::getMeshInterface))
	.function("calculatePrincipalAxisTransform", &btConvexTriangleMeshShape::calculatePrincipalAxisTransform)
	.function("getHalfExtentsWithMargin", &btCylinderShape::getHalfExtentsWithMargin)
	.function("getHalfExtentsWithoutMargin", &btCylinderShape::getHalfExtentsWithoutMargin)
	.constructor<r.q(const).btVector3>()
	.function("getUpAxis", &btCylinderShape::getUpAxis)
	.function("getRadius", &btCylinderShape::getRadius)
	.constructor<r.q(const).btVector3>()
	.constructor<r.q(const).btVector3>()
	.function("getRawHeightFieldValue", &btHeightfieldTerrainShape::getRawHeightFieldValue)
	.function("quantizeWithClamp", &btHeightfieldTerrainShape::quantizeWithClamp)
	.function("getVertex", &btHeightfieldTerrainShape::getVertex)
	.function("initialize", &btHeightfieldTerrainShape::initialize)
	.constructor<int,int,p.q(const).void,btScalar,btScalar,btScalar,int,PHY_ScalarType,bool>()
	.constructor<int,int,p.q(const).void,btScalar,int,bool,bool>()
	.function("setUseDiamondSubdivision_bool", select_overload<void(bool)>(&btHeightfieldTerrainShape::setUseDiamondSubdivision))
	.function("setUseDiamondSubdivision", select_overload<void()>(&btHeightfieldTerrainShape::setUseDiamondSubdivision))
	.function("setUseZigzagSubdivision_bool", select_overload<void(bool)>(&btHeightfieldTerrainShape::setUseZigzagSubdivision))
	.function("setUseZigzagSubdivision", select_overload<void()>(&btHeightfieldTerrainShape::setUseZigzagSubdivision))
	.constructor<btScalar,btScalar>()
	.constructor<p.q(const).btConvexShape,p.q(const).btConvexShape>()
	.function("setTransformA", &btMinkowskiSumShape::setTransformA)
	.function("setTransformB", &btMinkowskiSumShape::setTransformB)
	.function("getTransformA", &btMinkowskiSumShape::getTransformA)
	.function("GetTransformB", &btMinkowskiSumShape::GetTransformB)
	.function("getShapeA", &btMinkowskiSumShape::getShapeA)
	.function("getShapeB", &btMinkowskiSumShape::getShapeB)
	.constructor<p.btStridingMeshInterface,bool,bool>()
	.constructor<p.btStridingMeshInterface,bool>()
	.constructor<p.btStridingMeshInterface,bool,r.q(const).btVector3,r.q(const).btVector3,bool>()
	.constructor<p.btStridingMeshInterface,bool,r.q(const).btVector3,r.q(const).btVector3>()
	.function("getMaterialProperties", &btMultimaterialTriangleMeshShape::getMaterialProperties)
	.constructor<p.q(const).btVector3,p.q(const).btScalar,int>()
	.function("getSphereCount", &btMultiSphereShape::getSphereCount)
	.function("getSpherePosition", &btMultiSphereShape::getSpherePosition)
	.function("getSphereRadius", &btMultiSphereShape::getSphereRadius)
	.constructor<p.btBvhTriangleMeshShape,r.q(const).btVector3>()
	.function("getChildShape", select_overload<btBvhTriangleMeshShape()>(&btScaledBvhTriangleMeshShape::getChildShape))
	.function("getChildShape", select_overload<q(const).btBvhTriangleMeshShape()const>(&btScaledBvhTriangleMeshShape::getChildShape))
	.class_function("getUnitSpherePoints", &btShapeHull::getUnitSpherePoints)
	.constructor<p.q(const).btConvexShape>()
	.function("buildHull", &btShapeHull::buildHull)
	.function("numTriangles", &btShapeHull::numTriangles)
	.function("numVertices", &btShapeHull::numVertices)
	.function("numIndices", &btShapeHull::numIndices)
	.function("getVertexPointer", &btShapeHull::getVertexPointer)
	.function("getIndexPointer", &btShapeHull::getIndexPointer)
	.constructor<btScalar>()
	.function("getRadius", &btSphereShape::getRadius)
	.function("setUnscaledRadius", &btSphereShape::setUnscaledRadius)
	.constructor<r.q(const).btVector3,btScalar>()
	.function("getPlaneNormal", &btStaticPlaneShape::getPlaneNormal)
	.function("getPlaneConstant", &btStaticPlaneShape::getPlaneConstant)
	.constructor<r.q(const).btVector3>()
	.constructor<r.q(const).btVector3,r.q(const).btVector3>()
	.constructor<r.q(const).btVector3,r.q(const).btVector3,r.q(const).btVector3>()
	.constructor<r.q(const).btVector3,r.q(const).btVector3,r.q(const).btVector3,r.q(const).btVector3>()
	.function("reset", &btBU_Simplex1to4::reset)
	.function("addVertex", &btBU_Simplex1to4::addVertex)
	.function("getIndex", &btBU_Simplex1to4::getIndex)
	.function("getNumTriangles", &btTriangleBuffer::getNumTriangles)
	.function("getTriangle", &btTriangleBuffer::getTriangle)
	.function("clearBuffer", &btTriangleBuffer::clearBuffer)
	.constructor<int,p.int,int,int,p.btScalar,int>()
	.function("addIndexedMesh_r.q(const).btIndexedMesh_PHY_ScalarType", select_overload<void(r.q(const).btIndexedMesh, PHY_ScalarType)>(&btTriangleIndexVertexArray::addIndexedMesh))
	.function("addIndexedMesh_r.q(const).btIndexedMesh", select_overload<void(r.q(const).btIndexedMesh)>(&btTriangleIndexVertexArray::addIndexedMesh))
	.function("getLockedVertexIndexBase_p.p.unsigned char_r.int_r.PHY_ScalarType_r.int_p.p.unsigned char_r.int_r.int_r.PHY_ScalarType_int", select_overload<void(p.p.unsigned char, r.int, r.PHY_ScalarType, r.int, p.p.unsigned char, r.int, r.int, r.PHY_ScalarType, int)>(&btTriangleIndexVertexArray::getLockedVertexIndexBase))
	.function("getLockedVertexIndexBase_p.p.unsigned char_r.int_r.PHY_ScalarType_r.int_p.p.unsigned char_r.int_r.int_r.PHY_ScalarType", select_overload<void(p.p.unsigned char, r.int, r.PHY_ScalarType, r.int, p.p.unsigned char, r.int, r.int, r.PHY_ScalarType)>(&btTriangleIndexVertexArray::getLockedVertexIndexBase))
	.function("getLockedReadOnlyVertexIndexBase_p.p.q(const).unsigned char_r.int_r.PHY_ScalarType_r.int_p.p.q(const).unsigned char_r.int_r.int_r.PHY_ScalarType_int", select_overload<void(p.p.q(const).unsigned char, r.int, r.PHY_ScalarType, r.int, p.p.q(const).unsigned char, r.int, r.int, r.PHY_ScalarType, int)const>(&btTriangleIndexVertexArray::getLockedReadOnlyVertexIndexBase))
	.function("getLockedReadOnlyVertexIndexBase_p.p.q(const).unsigned char_r.int_r.PHY_ScalarType_r.int_p.p.q(const).unsigned char_r.int_r.int_r.PHY_ScalarType", select_overload<void(p.p.q(const).unsigned char, r.int, r.PHY_ScalarType, r.int, p.p.q(const).unsigned char, r.int, r.int, r.PHY_ScalarType)const>(&btTriangleIndexVertexArray::getLockedReadOnlyVertexIndexBase))
	.function("getIndexedMeshArray", select_overload<IndexedMeshArray()>(&btTriangleIndexVertexArray::getIndexedMeshArray))
	.function("getIndexedMeshArray", select_overload<q(const).IndexedMeshArray()const>(&btTriangleIndexVertexArray::getIndexedMeshArray))
	.constructor<int,p.int,int,int,p.btScalar,int,int,p.unsigned char,int,p.int,int>()
	.function("addMaterialProperties_r.q(const).btMaterialProperties_PHY_ScalarType", select_overload<void(r.q(const).btMaterialProperties, PHY_ScalarType)>(&btTriangleIndexVertexMaterialArray::addMaterialProperties))
	.function("addMaterialProperties_r.q(const).btMaterialProperties", select_overload<void(r.q(const).btMaterialProperties)>(&btTriangleIndexVertexMaterialArray::addMaterialProperties))
	.function("getLockedMaterialBase_p.p.unsigned char_r.int_r.PHY_ScalarType_r.int_p.p.unsigned char_r.int_r.int_r.PHY_ScalarType_int", select_overload<void(p.p.unsigned char, r.int, r.PHY_ScalarType, r.int, p.p.unsigned char, r.int, r.int, r.PHY_ScalarType, int)>(&btTriangleIndexVertexMaterialArray::getLockedMaterialBase))
	.function("getLockedMaterialBase_p.p.unsigned char_r.int_r.PHY_ScalarType_r.int_p.p.unsigned char_r.int_r.int_r.PHY_ScalarType", select_overload<void(p.p.unsigned char, r.int, r.PHY_ScalarType, r.int, p.p.unsigned char, r.int, r.int, r.PHY_ScalarType)>(&btTriangleIndexVertexMaterialArray::getLockedMaterialBase))
	.function("getLockedReadOnlyMaterialBase_p.p.q(const).unsigned char_r.int_r.PHY_ScalarType_r.int_p.p.q(const).unsigned char_r.int_r.int_r.PHY_ScalarType_int", select_overload<void(p.p.q(const).unsigned char, r.int, r.PHY_ScalarType, r.int, p.p.q(const).unsigned char, r.int, r.int, r.PHY_ScalarType, int)>(&btTriangleIndexVertexMaterialArray::getLockedReadOnlyMaterialBase))
	.function("getLockedReadOnlyMaterialBase_p.p.q(const).unsigned char_r.int_r.PHY_ScalarType_r.int_p.p.q(const).unsigned char_r.int_r.int_r.PHY_ScalarType", select_overload<void(p.p.q(const).unsigned char, r.int, r.PHY_ScalarType, r.int, p.p.q(const).unsigned char, r.int, r.int, r.PHY_ScalarType)>(&btTriangleIndexVertexMaterialArray::getLockedReadOnlyMaterialBase))
	.constructor<bool,bool>()
	.constructor<bool>()
	.function("getUse32bitIndices", &btTriangleMesh::getUse32bitIndices)
	.function("getUse4componentVertices", &btTriangleMesh::getUse4componentVertices)
	.function("addTriangle_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3_bool", select_overload<void(r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3, bool)>(&btTriangleMesh::addTriangle))
	.function("addTriangle_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3", select_overload<void(r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3)>(&btTriangleMesh::addTriangle))
	.function("addTriangleIndices", &btTriangleMesh::addTriangleIndices)
	.function("getNumTriangles", &btTriangleMesh::getNumTriangles)
	.function("findOrAddVertex", &btTriangleMesh::findOrAddVertex)
	.function("addIndex", &btTriangleMesh::addIndex)
	.function("getVertexPtr_int", select_overload<btVector3(int)>(&btTriangleShape::getVertexPtr))
	.function("getVertexPtr_int", select_overload<q(const).btVector3(int)const>(&btTriangleShape::getVertexPtr))
	.constructor<r.q(const).btVector3,r.q(const).btVector3,r.q(const).btVector3>()
	.function("calcNormal", &btTriangleShape::calcNormal)
	.function("getPlaneEquation", &btTriangleShape::getPlaneEquation)
	.constructor<p.btConvexShape,btScalar>()
	.function("getUniformScalingFactor", &btUniformScalingShape::getUniformScalingFactor)
	.function("getChildShape", select_overload<btConvexShape()>(&btUniformScalingShape::getChildShape))
	.function("getChildShape", select_overload<q(const).btConvexShape()const>(&btUniformScalingShape::getChildShape))
	enum_<btIDebugDraw::DebugDrawModes>("btIDebugDraw::DebugDrawModes")
		;
	.function("getDefaultColors", &btIDebugDraw::getDefaultColors)
	.function("setDefaultColors", &btIDebugDraw::setDefaultColors)
	.function("drawLine_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3", select_overload<void(r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3)>(&btIDebugDraw::drawLine))
	.function("drawLine_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3", select_overload<void(r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3)>(&btIDebugDraw::drawLine))
	.function("drawSphere_btScalar_r.q(const).btTransform_r.q(const).btVector3", select_overload<void(btScalar, r.q(const).btTransform, r.q(const).btVector3)>(&btIDebugDraw::drawSphere))
	.function("drawSphere_r.q(const).btVector3_btScalar_r.q(const).btVector3", select_overload<void(r.q(const).btVector3, btScalar, r.q(const).btVector3)>(&btIDebugDraw::drawSphere))
	.function("drawTriangle_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3_btScalar", select_overload<void(r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3, btScalar)>(&btIDebugDraw::drawTriangle))
	.function("drawTriangle_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3_btScalar", select_overload<void(r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3, btScalar)>(&btIDebugDraw::drawTriangle))
	.function("drawContactPoint", &btIDebugDraw::drawContactPoint)
	.function("reportErrorWarning", &btIDebugDraw::reportErrorWarning)
	.function("draw3dText", &btIDebugDraw::draw3dText)
	.function("setDebugMode", &btIDebugDraw::setDebugMode)
	.function("getDebugMode", &btIDebugDraw::getDebugMode)
	.function("drawAabb", &btIDebugDraw::drawAabb)
	.function("drawTransform", &btIDebugDraw::drawTransform)
	.function("drawArc_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3_btScalar_btScalar_btScalar_btScalar_r.q(const).btVector3_bool_btScalar", select_overload<void(r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3, btScalar, btScalar, btScalar, btScalar, r.q(const).btVector3, bool, btScalar)>(&btIDebugDraw::drawArc))
	.function("drawArc_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3_btScalar_btScalar_btScalar_btScalar_r.q(const).btVector3_bool", select_overload<void(r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3, btScalar, btScalar, btScalar, btScalar, r.q(const).btVector3, bool)>(&btIDebugDraw::drawArc))
	.function("drawSpherePatch_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3_btScalar_btScalar_btScalar_btScalar_btScalar_r.q(const).btVector3_btScalar_bool", select_overload<void(r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3, btScalar, btScalar, btScalar, btScalar, btScalar, r.q(const).btVector3, btScalar, bool)>(&btIDebugDraw::drawSpherePatch))
	.function("drawSpherePatch_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3_btScalar_btScalar_btScalar_btScalar_btScalar_r.q(const).btVector3_btScalar", select_overload<void(r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3, btScalar, btScalar, btScalar, btScalar, btScalar, r.q(const).btVector3, btScalar)>(&btIDebugDraw::drawSpherePatch))
	.function("drawSpherePatch_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3_btScalar_btScalar_btScalar_btScalar_btScalar_r.q(const).btVector3", select_overload<void(r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3, btScalar, btScalar, btScalar, btScalar, btScalar, r.q(const).btVector3)>(&btIDebugDraw::drawSpherePatch))
	.function("drawBox_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3", select_overload<void(r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3)>(&btIDebugDraw::drawBox))
	.function("drawBox_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btTransform_r.q(const).btVector3", select_overload<void(r.q(const).btVector3, r.q(const).btVector3, r.q(const).btTransform, r.q(const).btVector3)>(&btIDebugDraw::drawBox))
	.function("drawCapsule", &btIDebugDraw::drawCapsule)
	.function("drawCylinder", &btIDebugDraw::drawCylinder)
	.function("drawCone", &btIDebugDraw::drawCone)
	.function("drawPlane", &btIDebugDraw::drawPlane)
	.function("flushLines", &btIDebugDraw::flushLines)
	.function("calcTimeOfImpact", &btConvexCast::calcTimeOfImpact)
	.function("computeClosestPoints", &btContinuousConvexCollision::computeClosestPoints)
	.constructor<p.q(const).btConvexShape,p.q(const).btConvexShape,p.btVoronoiSimplexSolver,p.btConvexPenetrationDepthSolver>()
	.constructor<p.q(const).btConvexShape,p.q(const).btStaticPlaneShape>()
	.function("calcPenDepth", &btConvexPenetrationDepthSolver::calcPenDepth)
	.constructor<p.q(const).btConvexShape,p.q(const).btConvexShape,p.btVoronoiSimplexSolver>()
	.class_function("StackSizeRequirement", &btGjkEpaSolver2::StackSizeRequirement)
	.class_function("Distance", &btGjkEpaSolver2::Distance)
	.class_function("Penetration", &btGjkEpaSolver2::Penetration)
	.class_function("Penetration", &btGjkEpaSolver2::Penetration)
	.class_function("SignedDistance", &btGjkEpaSolver2::SignedDistance)
	.class_function("SignedDistance", &btGjkEpaSolver2::SignedDistance)
	.class_function("getPenetrationDirections", &btMinkowskiPenetrationDepthSolver::getPenetrationDirections)
	.function("setShapeIdentifiersA", &btPointCollector::setShapeIdentifiersA)
	.function("setShapeIdentifiersB", &btPointCollector::setShapeIdentifiersB)
	.function("addContactPoint", &btPointCollector::addContactPoint)
	enum_<btTriangleRaycastCallback::EFlags>("btTriangleRaycastCallback::EFlags")
		;
	.constructor<r.q(const).btVector3,r.q(const).btVector3,unsigned int>()
	.constructor<r.q(const).btVector3,r.q(const).btVector3>()
	.function("reportHit", &btTriangleRaycastCallback::reportHit)
	.constructor<p.q(const).btConvexShape,r.q(const).btTransform,r.q(const).btTransform,r.q(const).btTransform,q(const).btScalar>()
	.function("reportHit", &btTriangleConvexcastCallback::reportHit)
	.constructor<p.q(const).btConvexShape,p.q(const).btConvexShape,p.btVoronoiSimplexSolver>()
	enum_<btRigidBodyFlags>("btRigidBodyFlags")
		;
	.constructor<r.q(const).btRigidBody::btRigidBodyConstructionInfo>()
	.constructor<btScalar,p.btMotionState,p.btCollisionShape,r.q(const).btVector3>()
	.constructor<btScalar,p.btMotionState,p.btCollisionShape>()
	.function("setupRigidBody", &btRigidBody::setupRigidBody)
	.function("proceedToTransform", &btRigidBody::proceedToTransform)
	.class_function("upcast", &btRigidBody::upcast)
	.class_function("upcast", &btRigidBody::upcast)
	.function("predictIntegratedTransform", &btRigidBody::predictIntegratedTransform)
	.function("saveKinematicState", &btRigidBody::saveKinematicState)
	.function("applyGravity", &btRigidBody::applyGravity)
	.function("setGravity", &btRigidBody::setGravity)
	.function("getGravity", &btRigidBody::getGravity)
	.function("setDamping", &btRigidBody::setDamping)
	.function("getLinearDamping", &btRigidBody::getLinearDamping)
	.function("getAngularDamping", &btRigidBody::getAngularDamping)
	.function("getLinearSleepingThreshold", &btRigidBody::getLinearSleepingThreshold)
	.function("getAngularSleepingThreshold", &btRigidBody::getAngularSleepingThreshold)
	.function("applyDamping", &btRigidBody::applyDamping)
	.function("getCollisionShape", select_overload<q(const).btCollisionShape()const>(&btRigidBody::getCollisionShape))
	.function("getCollisionShape", select_overload<btCollisionShape()>(&btRigidBody::getCollisionShape))
	.function("setMassProps", &btRigidBody::setMassProps)
	.function("getLinearFactor", &btRigidBody::getLinearFactor)
	.function("setLinearFactor", &btRigidBody::setLinearFactor)
	.function("getInvMass", &btRigidBody::getInvMass)
	.function("getInvInertiaTensorWorld", &btRigidBody::getInvInertiaTensorWorld)
	.function("integrateVelocities", &btRigidBody::integrateVelocities)
	.function("setCenterOfMassTransform", &btRigidBody::setCenterOfMassTransform)
	.function("applyCentralForce", &btRigidBody::applyCentralForce)
	.function("getTotalForce", &btRigidBody::getTotalForce)
	.function("getTotalTorque", &btRigidBody::getTotalTorque)
	.function("getInvInertiaDiagLocal", &btRigidBody::getInvInertiaDiagLocal)
	.function("setInvInertiaDiagLocal", &btRigidBody::setInvInertiaDiagLocal)
	.function("setSleepingThresholds", &btRigidBody::setSleepingThresholds)
	.function("applyTorque", &btRigidBody::applyTorque)
	.function("applyForce", &btRigidBody::applyForce)
	.function("applyCentralImpulse", &btRigidBody::applyCentralImpulse)
	.function("applyTorqueImpulse", &btRigidBody::applyTorqueImpulse)
	.function("applyImpulse", &btRigidBody::applyImpulse)
	.function("clearForces", &btRigidBody::clearForces)
	.function("updateInertiaTensor", &btRigidBody::updateInertiaTensor)
	.function("getCenterOfMassPosition", &btRigidBody::getCenterOfMassPosition)
	.function("getOrientation", &btRigidBody::getOrientation)
	.function("getCenterOfMassTransform", &btRigidBody::getCenterOfMassTransform)
	.function("getLinearVelocity", &btRigidBody::getLinearVelocity)
	.function("getAngularVelocity", &btRigidBody::getAngularVelocity)
	.function("setLinearVelocity", &btRigidBody::setLinearVelocity)
	.function("setAngularVelocity", &btRigidBody::setAngularVelocity)
	.function("getVelocityInLocalPoint", &btRigidBody::getVelocityInLocalPoint)
	.function("translate", &btRigidBody::translate)
	.function("getAabb", &btRigidBody::getAabb)
	.function("computeImpulseDenominator", &btRigidBody::computeImpulseDenominator)
	.function("computeAngularImpulseDenominator", &btRigidBody::computeAngularImpulseDenominator)
	.function("updateDeactivation", &btRigidBody::updateDeactivation)
	.function("wantsSleeping", &btRigidBody::wantsSleeping)
	.function("getBroadphaseProxy", select_overload<q(const).btBroadphaseProxy()const>(&btRigidBody::getBroadphaseProxy))
	.function("getBroadphaseProxy", select_overload<btBroadphaseProxy()>(&btRigidBody::getBroadphaseProxy))
	.function("setNewBroadphaseProxy", &btRigidBody::setNewBroadphaseProxy)
	.function("getMotionState", select_overload<btMotionState()>(&btRigidBody::getMotionState))
	.function("getMotionState", select_overload<q(const).btMotionState()const>(&btRigidBody::getMotionState))
	.function("setMotionState", &btRigidBody::setMotionState)
	.function("setAngularFactor_r.q(const).btVector3", select_overload<void(r.q(const).btVector3)>(&btRigidBody::setAngularFactor))
	.function("setAngularFactor_btScalar", select_overload<void(btScalar)>(&btRigidBody::setAngularFactor))
	.function("getAngularFactor", &btRigidBody::getAngularFactor)
	.function("isInWorld", &btRigidBody::isInWorld)
	.function("addConstraintRef", &btRigidBody::addConstraintRef)
	.function("removeConstraintRef", &btRigidBody::removeConstraintRef)
	.function("getConstraintRef", &btRigidBody::getConstraintRef)
	.function("getNumConstraintRefs", &btRigidBody::getNumConstraintRefs)
	.function("setFlags", &btRigidBody::setFlags)
	.function("getFlags", &btRigidBody::getFlags)
	.function("computeGyroscopicImpulseImplicit_World", &btRigidBody::computeGyroscopicImpulseImplicit_World)
	.function("computeGyroscopicImpulseImplicit_Body", &btRigidBody::computeGyroscopicImpulseImplicit_Body)
	.function("computeGyroscopicForceExplicit", &btRigidBody::computeGyroscopicForceExplicit)
	.function("getLocalInertia", &btRigidBody::getLocalInertia)
	.class_function("getFixedBody", &btActionInterface::getFixedBody)
	.function("updateAction", &btActionInterface::updateAction)
	.function("debugDraw", &btActionInterface::debugDraw)
	.function("setWalkDirection", &btCharacterControllerInterface::setWalkDirection)
	.function("setVelocityForTimeInterval", &btCharacterControllerInterface::setVelocityForTimeInterval)
	.function("reset", &btCharacterControllerInterface::reset)
	.function("warp", &btCharacterControllerInterface::warp)
	.function("preStep", &btCharacterControllerInterface::preStep)
	.function("playerStep", &btCharacterControllerInterface::playerStep)
	.function("canJump", &btCharacterControllerInterface::canJump)
	.function("jump_r.q(const).btVector3", select_overload<void(r.q(const).btVector3)>(&btCharacterControllerInterface::jump))
	.function("jump", select_overload<void()>(&btCharacterControllerInterface::jump))
	.function("onGround", &btCharacterControllerInterface::onGround)
	.function("setUpInterpolate", &btCharacterControllerInterface::setUpInterpolate)
	.class_function("getUpAxisDirections", &btKinematicCharacterController::getUpAxisDirections)
	.function("computeReflectionDirection", &btKinematicCharacterController::computeReflectionDirection)
	.function("parallelComponent", &btKinematicCharacterController::parallelComponent)
	.function("perpindicularComponent", &btKinematicCharacterController::perpindicularComponent)
	.function("recoverFromPenetration", &btKinematicCharacterController::recoverFromPenetration)
	.function("stepUp", &btKinematicCharacterController::stepUp)
	.function("updateTargetPositionBasedOnCollision", &btKinematicCharacterController::updateTargetPositionBasedOnCollision)
	.function("updateTargetPositionBasedOnCollision", &btKinematicCharacterController::updateTargetPositionBasedOnCollision)
	.function("updateTargetPositionBasedOnCollision", &btKinematicCharacterController::updateTargetPositionBasedOnCollision)
	.function("stepForwardAndStrafe", &btKinematicCharacterController::stepForwardAndStrafe)
	.function("stepDown", &btKinematicCharacterController::stepDown)
	.function("needsCollision", &btKinematicCharacterController::needsCollision)
	.function("setUpVector", &btKinematicCharacterController::setUpVector)
	.function("getRotation", &btKinematicCharacterController::getRotation)
	.constructor<p.btPairCachingGhostObject,p.btConvexShape,btScalar,r.q(const).btVector3>()
	.constructor<p.btPairCachingGhostObject,p.btConvexShape,btScalar>()
	.function("setUp", &btKinematicCharacterController::setUp)
	.function("getUp", &btKinematicCharacterController::getUp)
	.function("setAngularVelocity", &btKinematicCharacterController::setAngularVelocity)
	.function("getAngularVelocity", &btKinematicCharacterController::getAngularVelocity)
	.function("setLinearVelocity", &btKinematicCharacterController::setLinearVelocity)
	.function("getLinearVelocity", &btKinematicCharacterController::getLinearVelocity)
	.function("setLinearDamping", &btKinematicCharacterController::setLinearDamping)
	.function("getLinearDamping", &btKinematicCharacterController::getLinearDamping)
	.function("setAngularDamping", &btKinematicCharacterController::setAngularDamping)
	.function("getAngularDamping", &btKinematicCharacterController::getAngularDamping)
	.function("setStepHeight", &btKinematicCharacterController::setStepHeight)
	.function("getStepHeight", &btKinematicCharacterController::getStepHeight)
	.function("setFallSpeed", &btKinematicCharacterController::setFallSpeed)
	.function("getFallSpeed", &btKinematicCharacterController::getFallSpeed)
	.function("setJumpSpeed", &btKinematicCharacterController::setJumpSpeed)
	.function("getJumpSpeed", &btKinematicCharacterController::getJumpSpeed)
	.function("setMaxJumpHeight", &btKinematicCharacterController::setMaxJumpHeight)
	.function("jump_r.q(const).btVector3", select_overload<void(r.q(const).btVector3)>(&btKinematicCharacterController::jump))
	.function("jump", select_overload<void()>(&btKinematicCharacterController::jump))
	.function("applyImpulse", &btKinematicCharacterController::applyImpulse)
	.function("setGravity", &btKinematicCharacterController::setGravity)
	.function("getGravity", &btKinematicCharacterController::getGravity)
	.function("setMaxSlope", &btKinematicCharacterController::setMaxSlope)
	.function("getMaxSlope", &btKinematicCharacterController::getMaxSlope)
	.function("setMaxPenetrationDepth", &btKinematicCharacterController::setMaxPenetrationDepth)
	.function("getMaxPenetrationDepth", &btKinematicCharacterController::getMaxPenetrationDepth)
	.function("getGhostObject", &btKinematicCharacterController::getGhostObject)
	.function("setUseGhostSweepTest", &btKinematicCharacterController::setUseGhostSweepTest)
	.constructor<r.q(const).btMatrix3x3,r.q(const).btMatrix3x3,r.q(const).btVector3,r.q(const).btVector3,r.q(const).btVector3,r.q(const).btVector3,q(const).btScalar,r.q(const).btVector3,q(const).btScalar>()
	.constructor<r.q(const).btVector3,r.q(const).btMatrix3x3,r.q(const).btMatrix3x3,r.q(const).btVector3,r.q(const).btVector3>()
	.constructor<r.q(const).btVector3,r.q(const).btVector3,r.q(const).btVector3,r.q(const).btVector3>()
	.constructor<r.q(const).btMatrix3x3,r.q(const).btVector3,r.q(const).btVector3,r.q(const).btVector3,r.q(const).btVector3,q(const).btScalar>()
	.function("getDiagonal", &btJacobianEntry::getDiagonal)
	.function("getNonDiagonal_r.q(const).btJacobianEntry_q(const).btScalar", select_overload<btScalar(r.q(const).btJacobianEntry, q(const).btScalar)const>(&btJacobianEntry::getNonDiagonal))
	.function("getNonDiagonal_r.q(const).btJacobianEntry_q(const).btScalar_q(const).btScalar", select_overload<btScalar(r.q(const).btJacobianEntry, q(const).btScalar, q(const).btScalar)const>(&btJacobianEntry::getNonDiagonal))
	.function("getRelativeVelocity", &btJacobianEntry::getRelativeVelocity)
	.function("setWorldTransform", &btSolverBody::setWorldTransform)
	.function("getWorldTransform", &btSolverBody::getWorldTransform)
	.function("getVelocityInLocalPointNoDelta", &btSolverBody::getVelocityInLocalPointNoDelta)
	.function("getVelocityInLocalPointObsolete", &btSolverBody::getVelocityInLocalPointObsolete)
	.function("getAngularVelocity", &btSolverBody::getAngularVelocity)
	.function("applyImpulse", &btSolverBody::applyImpulse)
	.function("internalApplyPushImpulse", &btSolverBody::internalApplyPushImpulse)
	.function("getDeltaLinearVelocity", &btSolverBody::getDeltaLinearVelocity)
	.function("getDeltaAngularVelocity", &btSolverBody::getDeltaAngularVelocity)
	.function("getPushVelocity", &btSolverBody::getPushVelocity)
	.function("getTurnVelocity", &btSolverBody::getTurnVelocity)
	.function("internalGetDeltaLinearVelocity", &btSolverBody::internalGetDeltaLinearVelocity)
	.function("internalGetDeltaAngularVelocity", &btSolverBody::internalGetDeltaAngularVelocity)
	.function("internalGetAngularFactor", &btSolverBody::internalGetAngularFactor)
	.function("internalGetInvMass", &btSolverBody::internalGetInvMass)
	.function("internalSetInvMass", &btSolverBody::internalSetInvMass)
	.function("internalGetPushVelocity", &btSolverBody::internalGetPushVelocity)
	.function("internalGetTurnVelocity", &btSolverBody::internalGetTurnVelocity)
	.function("internalGetVelocityInLocalPointObsolete", &btSolverBody::internalGetVelocityInLocalPointObsolete)
	.function("internalGetAngularVelocity", &btSolverBody::internalGetAngularVelocity)
	.function("internalApplyImpulse", &btSolverBody::internalApplyImpulse)
	.function("writebackVelocity", &btSolverBody::writebackVelocity)
	.function("writebackVelocityAndTransform", &btSolverBody::writebackVelocityAndTransform)
	enum_<btSolverConstraint::btSolverConstraintType>("btSolverConstraint::btSolverConstraintType")
		;
	enum_<btTypedConstraintType>("btTypedConstraintType")
		;
	enum_<btConstraintParams>("btConstraintParams")
		;
	.function("operator =", &btTypedConstraint::operator =)
	.function("getMotorFactor", &btTypedConstraint::getMotorFactor)
	.constructor<btTypedConstraintType,r.btRigidBody>()
	.constructor<btTypedConstraintType,r.btRigidBody,r.btRigidBody>()
	.class_function("getFixedBody", &btTypedConstraint::getFixedBody)
	.function("getOverrideNumSolverIterations", &btTypedConstraint::getOverrideNumSolverIterations)
	.function("setOverrideNumSolverIterations", &btTypedConstraint::setOverrideNumSolverIterations)
	.function("buildJacobian", &btTypedConstraint::buildJacobian)
	.function("setupSolverConstraint", &btTypedConstraint::setupSolverConstraint)
	.function("getInfo1", &btTypedConstraint::getInfo1)
	.function("getInfo2", &btTypedConstraint::getInfo2)
	.function("internalSetAppliedImpulse", &btTypedConstraint::internalSetAppliedImpulse)
	.function("internalGetAppliedImpulse", &btTypedConstraint::internalGetAppliedImpulse)
	.function("getBreakingImpulseThreshold", &btTypedConstraint::getBreakingImpulseThreshold)
	.function("setBreakingImpulseThreshold", &btTypedConstraint::setBreakingImpulseThreshold)
	.function("isEnabled", &btTypedConstraint::isEnabled)
	.function("setEnabled", &btTypedConstraint::setEnabled)
	.function("solveConstraintObsolete", &btTypedConstraint::solveConstraintObsolete)
	.function("getRigidBodyA", select_overload<q(const).btRigidBody()const>(&btTypedConstraint::getRigidBodyA))
	.function("getRigidBodyB", select_overload<q(const).btRigidBody()const>(&btTypedConstraint::getRigidBodyB))
	.function("getRigidBodyA", select_overload<btRigidBody()>(&btTypedConstraint::getRigidBodyA))
	.function("getRigidBodyB", select_overload<btRigidBody()>(&btTypedConstraint::getRigidBodyB))
	.function("getUserConstraintType", &btTypedConstraint::getUserConstraintType)
	.function("setUserConstraintType", &btTypedConstraint::setUserConstraintType)
	.function("setUserConstraintId", &btTypedConstraint::setUserConstraintId)
	.function("getUserConstraintId", &btTypedConstraint::getUserConstraintId)
	.function("setUserConstraintPtr", &btTypedConstraint::setUserConstraintPtr)
	.function("getUserConstraintPtr", &btTypedConstraint::getUserConstraintPtr)
	.function("setJointFeedback", &btTypedConstraint::setJointFeedback)
	.function("getJointFeedback", select_overload<q(const).btJointFeedback()const>(&btTypedConstraint::getJointFeedback))
	.function("getJointFeedback", select_overload<btJointFeedback()>(&btTypedConstraint::getJointFeedback))
	.function("getUid", &btTypedConstraint::getUid)
	.function("needsFeedback", &btTypedConstraint::needsFeedback)
	.function("enableFeedback", &btTypedConstraint::enableFeedback)
	.function("getAppliedImpulse", &btTypedConstraint::getAppliedImpulse)
	.function("getConstraintType", &btTypedConstraint::getConstraintType)
	.function("setDbgDrawSize", &btTypedConstraint::setDbgDrawSize)
	.function("getDbgDrawSize", &btTypedConstraint::getDbgDrawSize)
	.function("setParam_int_btScalar_int", select_overload<void(int, btScalar, int)>(&btTypedConstraint::setParam))
	.function("setParam_int_btScalar", select_overload<void(int, btScalar)>(&btTypedConstraint::setParam))
	.function("getParam_int_int", select_overload<btScalar(int, int)const>(&btTypedConstraint::getParam))
	.function("getParam_int", select_overload<btScalar(int)const>(&btTypedConstraint::getParam))
	.function("calculateSerializeBufferSize", &btTypedConstraint::calculateSerializeBufferSize)
	.function("serialize", &btTypedConstraint::serialize)
	.function("set_btScalar_btScalar_btScalar_btScalar_btScalar", select_overload<void(btScalar, btScalar, btScalar, btScalar, btScalar)>(&btAngularLimit::set))
	.function("set_btScalar_btScalar_btScalar_btScalar", select_overload<void(btScalar, btScalar, btScalar, btScalar)>(&btAngularLimit::set))
	.function("set_btScalar_btScalar_btScalar", select_overload<void(btScalar, btScalar, btScalar)>(&btAngularLimit::set))
	.function("set_btScalar_btScalar", select_overload<void(btScalar, btScalar)>(&btAngularLimit::set))
	.function("test", &btAngularLimit::test)
	.function("getSoftness", &btAngularLimit::getSoftness)
	.function("getBiasFactor", &btAngularLimit::getBiasFactor)
	.function("getRelaxationFactor", &btAngularLimit::getRelaxationFactor)
	.function("getCorrection", &btAngularLimit::getCorrection)
	.function("getSign", &btAngularLimit::getSign)
	.function("getHalfRange", &btAngularLimit::getHalfRange)
	.function("isLimit", &btAngularLimit::isLimit)
	.function("fit", &btAngularLimit::fit)
	.function("getError", &btAngularLimit::getError)
	.function("getLow", &btAngularLimit::getLow)
	.function("getHigh", &btAngularLimit::getHigh)
	enum_<btConeTwistFlags>("btConeTwistFlags")
		;
	.function("init", &btConeTwistConstraint::init)
	.function("computeConeLimitInfo", &btConeTwistConstraint::computeConeLimitInfo)
	.function("computeTwistLimitInfo", &btConeTwistConstraint::computeTwistLimitInfo)
	.function("adjustSwingAxisToUseEllipseNormal", &btConeTwistConstraint::adjustSwingAxisToUseEllipseNormal)
	.constructor<r.btRigidBody,r.btRigidBody,r.q(const).btTransform,r.q(const).btTransform>()
	.constructor<r.btRigidBody,r.q(const).btTransform>()
	.function("getInfo1NonVirtual", &btConeTwistConstraint::getInfo1NonVirtual)
	.function("getInfo2NonVirtual", &btConeTwistConstraint::getInfo2NonVirtual)
	.function("updateRHS", &btConeTwistConstraint::updateRHS)
	.function("getRigidBodyA", &btConeTwistConstraint::getRigidBodyA)
	.function("getRigidBodyB", &btConeTwistConstraint::getRigidBodyB)
	.function("setAngularOnly", &btConeTwistConstraint::setAngularOnly)
	.function("getAngularOnly", &btConeTwistConstraint::getAngularOnly)
	.function("setLimit_int_btScalar", select_overload<void(int, btScalar)>(&btConeTwistConstraint::setLimit))
	.function("getLimit", &btConeTwistConstraint::getLimit)
	.function("setLimit_btScalar_btScalar_btScalar_btScalar_btScalar_btScalar", select_overload<void(btScalar, btScalar, btScalar, btScalar, btScalar, btScalar)>(&btConeTwistConstraint::setLimit))
	.function("setLimit_btScalar_btScalar_btScalar_btScalar_btScalar", select_overload<void(btScalar, btScalar, btScalar, btScalar, btScalar)>(&btConeTwistConstraint::setLimit))
	.function("setLimit_btScalar_btScalar_btScalar_btScalar", select_overload<void(btScalar, btScalar, btScalar, btScalar)>(&btConeTwistConstraint::setLimit))
	.function("setLimit_btScalar_btScalar_btScalar", select_overload<void(btScalar, btScalar, btScalar)>(&btConeTwistConstraint::setLimit))
	.function("getAFrame", &btConeTwistConstraint::getAFrame)
	.function("getBFrame", &btConeTwistConstraint::getBFrame)
	.function("getSolveTwistLimit", &btConeTwistConstraint::getSolveTwistLimit)
	.function("getSolveSwingLimit", &btConeTwistConstraint::getSolveSwingLimit)
	.function("getTwistLimitSign", &btConeTwistConstraint::getTwistLimitSign)
	.function("calcAngleInfo", &btConeTwistConstraint::calcAngleInfo)
	.function("calcAngleInfo2", &btConeTwistConstraint::calcAngleInfo2)
	.function("getSwingSpan1", &btConeTwistConstraint::getSwingSpan1)
	.function("getSwingSpan2", &btConeTwistConstraint::getSwingSpan2)
	.function("getTwistSpan", &btConeTwistConstraint::getTwistSpan)
	.function("getLimitSoftness", &btConeTwistConstraint::getLimitSoftness)
	.function("getBiasFactor", &btConeTwistConstraint::getBiasFactor)
	.function("getRelaxationFactor", &btConeTwistConstraint::getRelaxationFactor)
	.function("getTwistAngle", &btConeTwistConstraint::getTwistAngle)
	.function("isPastSwingLimit", &btConeTwistConstraint::isPastSwingLimit)
	.function("getDamping", &btConeTwistConstraint::getDamping)
	.function("setDamping", &btConeTwistConstraint::setDamping)
	.function("enableMotor", &btConeTwistConstraint::enableMotor)
	.function("isMotorEnabled", &btConeTwistConstraint::isMotorEnabled)
	.function("getMaxMotorImpulse", &btConeTwistConstraint::getMaxMotorImpulse)
	.function("isMaxMotorImpulseNormalized", &btConeTwistConstraint::isMaxMotorImpulseNormalized)
	.function("setMaxMotorImpulse", &btConeTwistConstraint::setMaxMotorImpulse)
	.function("setMaxMotorImpulseNormalized", &btConeTwistConstraint::setMaxMotorImpulseNormalized)
	.function("getFixThresh", &btConeTwistConstraint::getFixThresh)
	.function("setFixThresh", &btConeTwistConstraint::setFixThresh)
	.function("setMotorTarget", &btConeTwistConstraint::setMotorTarget)
	.function("getMotorTarget", &btConeTwistConstraint::getMotorTarget)
	.function("setMotorTargetInConstraintSpace", &btConeTwistConstraint::setMotorTargetInConstraintSpace)
	.function("GetPointForAngle", &btConeTwistConstraint::GetPointForAngle)
	.function("setParam_int_btScalar_int", select_overload<void(int, btScalar, int)>(&btConeTwistConstraint::setParam))
	.function("setParam_int_btScalar", select_overload<void(int, btScalar)>(&btConeTwistConstraint::setParam))
	.function("setFrames", &btConeTwistConstraint::setFrames)
	.function("getFrameOffsetA", &btConeTwistConstraint::getFrameOffsetA)
	.function("getFrameOffsetB", &btConeTwistConstraint::getFrameOffsetB)
	.function("getParam_int_int", select_overload<btScalar(int, int)const>(&btConeTwistConstraint::getParam))
	.function("getParam_int", select_overload<btScalar(int)const>(&btConeTwistConstraint::getParam))
	.function("getFlags", &btConeTwistConstraint::getFlags)
	enum_<btConstraintSolverType>("btConstraintSolverType")
		;
	.function("prepareSolve", &btConstraintSolver::prepareSolve)
	.function("solveGroup", &btConstraintSolver::solveGroup)
	.function("allSolved", &btConstraintSolver::allSolved)
	.function("reset", &btConstraintSolver::reset)
	.function("getSolverType", &btConstraintSolver::getSolverType)
	.constructor<p.btPersistentManifold,r.btRigidBody,r.btRigidBody>()
	.function("setContactManifold", &btContactConstraint::setContactManifold)
	.function("getContactManifold", select_overload<btPersistentManifold()>(&btContactConstraint::getContactManifold))
	.function("getContactManifold", select_overload<q(const).btPersistentManifold()const>(&btContactConstraint::getContactManifold))
	enum_<btSolverMode>("btSolverMode")
		;
	enum_<RotateOrder>("RotateOrder")
		;
	.constructor<r.q(const).btRotationalLimitMotor2>()
	.function("isLimited", &btRotationalLimitMotor2::isLimited)
	.function("testLimitValue", &btRotationalLimitMotor2::testLimitValue)
	.constructor<r.q(const).btTranslationalLimitMotor2>()
	.function("isLimited", &btTranslationalLimitMotor2::isLimited)
	.function("testLimitValue", &btTranslationalLimitMotor2::testLimitValue)
	enum_<bt6DofFlags2>("bt6DofFlags2")
		;
	.function("operator =", &btGeneric6DofSpring2Constraint::operator =)
	.function("setAngularLimits", &btGeneric6DofSpring2Constraint::setAngularLimits)
	.function("setLinearLimits", &btGeneric6DofSpring2Constraint::setLinearLimits)
	.function("calculateLinearInfo", &btGeneric6DofSpring2Constraint::calculateLinearInfo)
	.function("calculateAngleInfo", &btGeneric6DofSpring2Constraint::calculateAngleInfo)
	.function("testAngularLimitMotor", &btGeneric6DofSpring2Constraint::testAngularLimitMotor)
	.function("calculateJacobi", &btGeneric6DofSpring2Constraint::calculateJacobi)
	.function("get_limit_motor_info2", &btGeneric6DofSpring2Constraint::get_limit_motor_info2)
	.function("get_limit_motor_info2", &btGeneric6DofSpring2Constraint::get_limit_motor_info2)
	.constructor<r.btRigidBody,r.btRigidBody,r.q(const).btTransform,r.q(const).btTransform,RotateOrder>()
	.constructor<r.btRigidBody,r.btRigidBody,r.q(const).btTransform,r.q(const).btTransform>()
	.constructor<r.btRigidBody,r.q(const).btTransform,RotateOrder>()
	.constructor<r.btRigidBody,r.q(const).btTransform>()
	.function("getRotationalLimitMotor", &btGeneric6DofSpring2Constraint::getRotationalLimitMotor)
	.function("getTranslationalLimitMotor", &btGeneric6DofSpring2Constraint::getTranslationalLimitMotor)
	.function("calculateTransforms_r.q(const).btTransform_r.q(const).btTransform", select_overload<void(r.q(const).btTransform, r.q(const).btTransform)>(&btGeneric6DofSpring2Constraint::calculateTransforms))
	.function("calculateTransforms", select_overload<void()>(&btGeneric6DofSpring2Constraint::calculateTransforms))
	.function("getCalculatedTransformA", &btGeneric6DofSpring2Constraint::getCalculatedTransformA)
	.function("getCalculatedTransformB", &btGeneric6DofSpring2Constraint::getCalculatedTransformB)
	.function("getFrameOffsetA", select_overload<q(const).btTransform()const>(&btGeneric6DofSpring2Constraint::getFrameOffsetA))
	.function("getFrameOffsetB", select_overload<q(const).btTransform()const>(&btGeneric6DofSpring2Constraint::getFrameOffsetB))
	.function("getFrameOffsetA", select_overload<btTransform()>(&btGeneric6DofSpring2Constraint::getFrameOffsetA))
	.function("getFrameOffsetB", select_overload<btTransform()>(&btGeneric6DofSpring2Constraint::getFrameOffsetB))
	.function("getAxis", &btGeneric6DofSpring2Constraint::getAxis)
	.function("getAngle", &btGeneric6DofSpring2Constraint::getAngle)
	.function("getRelativePivotPosition", &btGeneric6DofSpring2Constraint::getRelativePivotPosition)
	.function("setFrames", &btGeneric6DofSpring2Constraint::setFrames)
	.function("setLinearLowerLimit", &btGeneric6DofSpring2Constraint::setLinearLowerLimit)
	.function("getLinearLowerLimit", &btGeneric6DofSpring2Constraint::getLinearLowerLimit)
	.function("setLinearUpperLimit", &btGeneric6DofSpring2Constraint::setLinearUpperLimit)
	.function("getLinearUpperLimit", &btGeneric6DofSpring2Constraint::getLinearUpperLimit)
	.function("setAngularLowerLimit", &btGeneric6DofSpring2Constraint::setAngularLowerLimit)
	.function("setAngularLowerLimitReversed", &btGeneric6DofSpring2Constraint::setAngularLowerLimitReversed)
	.function("getAngularLowerLimit", &btGeneric6DofSpring2Constraint::getAngularLowerLimit)
	.function("getAngularLowerLimitReversed", &btGeneric6DofSpring2Constraint::getAngularLowerLimitReversed)
	.function("setAngularUpperLimit", &btGeneric6DofSpring2Constraint::setAngularUpperLimit)
	.function("setAngularUpperLimitReversed", &btGeneric6DofSpring2Constraint::setAngularUpperLimitReversed)
	.function("getAngularUpperLimit", &btGeneric6DofSpring2Constraint::getAngularUpperLimit)
	.function("getAngularUpperLimitReversed", &btGeneric6DofSpring2Constraint::getAngularUpperLimitReversed)
	.function("setLimit", &btGeneric6DofSpring2Constraint::setLimit)
	.function("setLimitReversed", &btGeneric6DofSpring2Constraint::setLimitReversed)
	.function("isLimited", &btGeneric6DofSpring2Constraint::isLimited)
	.function("setRotationOrder", &btGeneric6DofSpring2Constraint::setRotationOrder)
	.function("getRotationOrder", &btGeneric6DofSpring2Constraint::getRotationOrder)
	.function("setAxis", &btGeneric6DofSpring2Constraint::setAxis)
	.function("setBounce", &btGeneric6DofSpring2Constraint::setBounce)
	.function("enableMotor", &btGeneric6DofSpring2Constraint::enableMotor)
	.function("setServo", &btGeneric6DofSpring2Constraint::setServo)
	.function("setTargetVelocity", &btGeneric6DofSpring2Constraint::setTargetVelocity)
	.function("setServoTarget", &btGeneric6DofSpring2Constraint::setServoTarget)
	.function("setMaxMotorForce", &btGeneric6DofSpring2Constraint::setMaxMotorForce)
	.function("enableSpring", &btGeneric6DofSpring2Constraint::enableSpring)
	.function("setStiffness_int_btScalar_bool", select_overload<void(int, btScalar, bool)>(&btGeneric6DofSpring2Constraint::setStiffness))
	.function("setStiffness_int_btScalar", select_overload<void(int, btScalar)>(&btGeneric6DofSpring2Constraint::setStiffness))
	.function("setDamping_int_btScalar_bool", select_overload<void(int, btScalar, bool)>(&btGeneric6DofSpring2Constraint::setDamping))
	.function("setDamping_int_btScalar", select_overload<void(int, btScalar)>(&btGeneric6DofSpring2Constraint::setDamping))
	.function("setEquilibriumPoint", select_overload<void()>(&btGeneric6DofSpring2Constraint::setEquilibriumPoint))
	.function("setEquilibriumPoint_int", select_overload<void(int)>(&btGeneric6DofSpring2Constraint::setEquilibriumPoint))
	.function("setEquilibriumPoint_int_btScalar", select_overload<void(int, btScalar)>(&btGeneric6DofSpring2Constraint::setEquilibriumPoint))
	.function("setParam_int_btScalar_int", select_overload<void(int, btScalar, int)>(&btGeneric6DofSpring2Constraint::setParam))
	.function("setParam_int_btScalar", select_overload<void(int, btScalar)>(&btGeneric6DofSpring2Constraint::setParam))
	.function("getParam_int_int", select_overload<btScalar(int, int)const>(&btGeneric6DofSpring2Constraint::getParam))
	.function("getParam_int", select_overload<btScalar(int)const>(&btGeneric6DofSpring2Constraint::getParam))
	.class_function("btGetMatrixElem", &btGeneric6DofSpring2Constraint::btGetMatrixElem)
	.class_function("matrixToEulerXYZ", &btGeneric6DofSpring2Constraint::matrixToEulerXYZ)
	.class_function("matrixToEulerXZY", &btGeneric6DofSpring2Constraint::matrixToEulerXZY)
	.class_function("matrixToEulerYXZ", &btGeneric6DofSpring2Constraint::matrixToEulerYXZ)
	.class_function("matrixToEulerYZX", &btGeneric6DofSpring2Constraint::matrixToEulerYZX)
	.class_function("matrixToEulerZXY", &btGeneric6DofSpring2Constraint::matrixToEulerZXY)
	.class_function("matrixToEulerZYX", &btGeneric6DofSpring2Constraint::matrixToEulerZYX)
	.constructor<r.btRigidBody,r.btRigidBody,r.q(const).btTransform,r.q(const).btTransform>()
	.constructor<r.btRigidBody,r.btRigidBody,r.q(const).btVector3,r.q(const).btVector3,btScalar>()
	.constructor<r.btRigidBody,r.btRigidBody,r.q(const).btVector3,r.q(const).btVector3>()
	.function("setAxisA", &btGearConstraint::setAxisA)
	.function("setAxisB", &btGearConstraint::setAxisB)
	.function("setRatio", &btGearConstraint::setRatio)
	.function("getAxisA", &btGearConstraint::getAxisA)
	.function("getAxisB", &btGearConstraint::getAxisB)
	.function("getRatio", &btGearConstraint::getRatio)
	.function("setParam_int_btScalar_int", select_overload<void(int, btScalar, int)>(&btGearConstraint::setParam))
	.function("setParam_int_btScalar", select_overload<void(int, btScalar)>(&btGearConstraint::setParam))
	.function("getParam_int_int", select_overload<btScalar(int, int)const>(&btGearConstraint::getParam))
	.function("getParam_int", select_overload<btScalar(int)const>(&btGearConstraint::getParam))
	.constructor<r.q(const).btRotationalLimitMotor>()
	.function("isLimited", &btRotationalLimitMotor::isLimited)
	.function("needApplyTorques", &btRotationalLimitMotor::needApplyTorques)
	.function("testLimitValue", &btRotationalLimitMotor::testLimitValue)
	.function("solveAngularLimits", &btRotationalLimitMotor::solveAngularLimits)
	.constructor<r.q(const).btTranslationalLimitMotor>()
	.function("isLimited", &btTranslationalLimitMotor::isLimited)
	.function("needApplyForce", &btTranslationalLimitMotor::needApplyForce)
	.function("testLimitValue", &btTranslationalLimitMotor::testLimitValue)
	.function("solveLinearAxis", &btTranslationalLimitMotor::solveLinearAxis)
	enum_<bt6DofFlags>("bt6DofFlags")
		;
	.function("operator =", &btGeneric6DofConstraint::operator =)
	.function("setAngularLimits", &btGeneric6DofConstraint::setAngularLimits)
	.function("setLinearLimits", &btGeneric6DofConstraint::setLinearLimits)
	.function("buildLinearJacobian", &btGeneric6DofConstraint::buildLinearJacobian)
	.function("buildAngularJacobian", &btGeneric6DofConstraint::buildAngularJacobian)
	.function("calculateLinearInfo", &btGeneric6DofConstraint::calculateLinearInfo)
	.function("calculateAngleInfo", &btGeneric6DofConstraint::calculateAngleInfo)
	.constructor<r.btRigidBody,r.btRigidBody,r.q(const).btTransform,r.q(const).btTransform,bool>()
	.constructor<r.btRigidBody,r.q(const).btTransform,bool>()
	.function("calculateTransforms_r.q(const).btTransform_r.q(const).btTransform", select_overload<void(r.q(const).btTransform, r.q(const).btTransform)>(&btGeneric6DofConstraint::calculateTransforms))
	.function("calculateTransforms", select_overload<void()>(&btGeneric6DofConstraint::calculateTransforms))
	.function("getCalculatedTransformA", &btGeneric6DofConstraint::getCalculatedTransformA)
	.function("getCalculatedTransformB", &btGeneric6DofConstraint::getCalculatedTransformB)
	.function("getFrameOffsetA", select_overload<q(const).btTransform()const>(&btGeneric6DofConstraint::getFrameOffsetA))
	.function("getFrameOffsetB", select_overload<q(const).btTransform()const>(&btGeneric6DofConstraint::getFrameOffsetB))
	.function("getFrameOffsetA", select_overload<btTransform()>(&btGeneric6DofConstraint::getFrameOffsetA))
	.function("getFrameOffsetB", select_overload<btTransform()>(&btGeneric6DofConstraint::getFrameOffsetB))
	.function("getInfo1NonVirtual", &btGeneric6DofConstraint::getInfo1NonVirtual)
	.function("getInfo2NonVirtual", &btGeneric6DofConstraint::getInfo2NonVirtual)
	.function("updateRHS", &btGeneric6DofConstraint::updateRHS)
	.function("getAxis", &btGeneric6DofConstraint::getAxis)
	.function("getAngle", &btGeneric6DofConstraint::getAngle)
	.function("getRelativePivotPosition", &btGeneric6DofConstraint::getRelativePivotPosition)
	.function("setFrames", &btGeneric6DofConstraint::setFrames)
	.function("testAngularLimitMotor", &btGeneric6DofConstraint::testAngularLimitMotor)
	.function("setLinearLowerLimit", &btGeneric6DofConstraint::setLinearLowerLimit)
	.function("getLinearLowerLimit", &btGeneric6DofConstraint::getLinearLowerLimit)
	.function("setLinearUpperLimit", &btGeneric6DofConstraint::setLinearUpperLimit)
	.function("getLinearUpperLimit", &btGeneric6DofConstraint::getLinearUpperLimit)
	.function("setAngularLowerLimit", &btGeneric6DofConstraint::setAngularLowerLimit)
	.function("getAngularLowerLimit", &btGeneric6DofConstraint::getAngularLowerLimit)
	.function("setAngularUpperLimit", &btGeneric6DofConstraint::setAngularUpperLimit)
	.function("getAngularUpperLimit", &btGeneric6DofConstraint::getAngularUpperLimit)
	.function("getRotationalLimitMotor", &btGeneric6DofConstraint::getRotationalLimitMotor)
	.function("getTranslationalLimitMotor", &btGeneric6DofConstraint::getTranslationalLimitMotor)
	.function("setLimit", &btGeneric6DofConstraint::setLimit)
	.function("isLimited", &btGeneric6DofConstraint::isLimited)
	.function("calcAnchorPos", &btGeneric6DofConstraint::calcAnchorPos)
	.function("get_limit_motor_info2_p.btRotationalLimitMotor_r.q(const).btTransform_r.q(const).btTransform_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3_p.btTypedConstraint::btConstraintInfo2_int_r.btVector3_int_int", select_overload<int(p.btRotationalLimitMotor, r.q(const).btTransform, r.q(const).btTransform, r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3, p.btTypedConstraint::btConstraintInfo2, int, r.btVector3, int, int)>(&btGeneric6DofConstraint::get_limit_motor_info2))
	.function("get_limit_motor_info2_p.btRotationalLimitMotor_r.q(const).btTransform_r.q(const).btTransform_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3_p.btTypedConstraint::btConstraintInfo2_int_r.btVector3_int", select_overload<int(p.btRotationalLimitMotor, r.q(const).btTransform, r.q(const).btTransform, r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3, p.btTypedConstraint::btConstraintInfo2, int, r.btVector3, int)>(&btGeneric6DofConstraint::get_limit_motor_info2))
	.function("getUseFrameOffset", &btGeneric6DofConstraint::getUseFrameOffset)
	.function("setUseFrameOffset", &btGeneric6DofConstraint::setUseFrameOffset)
	.function("getUseLinearReferenceFrameA", &btGeneric6DofConstraint::getUseLinearReferenceFrameA)
	.function("setUseLinearReferenceFrameA", &btGeneric6DofConstraint::setUseLinearReferenceFrameA)
	.function("setParam_int_btScalar_int", select_overload<void(int, btScalar, int)>(&btGeneric6DofConstraint::setParam))
	.function("setParam_int_btScalar", select_overload<void(int, btScalar)>(&btGeneric6DofConstraint::setParam))
	.function("getParam_int_int", select_overload<btScalar(int, int)const>(&btGeneric6DofConstraint::getParam))
	.function("getParam_int", select_overload<btScalar(int)const>(&btGeneric6DofConstraint::getParam))
	.function("setAxis", &btGeneric6DofConstraint::setAxis)
	.function("getFlags", &btGeneric6DofConstraint::getFlags)
	.function("init", &btGeneric6DofSpringConstraint::init)
	.function("internalUpdateSprings", &btGeneric6DofSpringConstraint::internalUpdateSprings)
	.constructor<r.btRigidBody,r.btRigidBody,r.q(const).btTransform,r.q(const).btTransform,bool>()
	.constructor<r.btRigidBody,r.q(const).btTransform,bool>()
	.function("enableSpring", &btGeneric6DofSpringConstraint::enableSpring)
	.function("setStiffness", &btGeneric6DofSpringConstraint::setStiffness)
	.function("setDamping", &btGeneric6DofSpringConstraint::setDamping)
	.function("setEquilibriumPoint", select_overload<void()>(&btGeneric6DofSpringConstraint::setEquilibriumPoint))
	.function("setEquilibriumPoint_int", select_overload<void(int)>(&btGeneric6DofSpringConstraint::setEquilibriumPoint))
	.function("setEquilibriumPoint_int_btScalar", select_overload<void(int, btScalar)>(&btGeneric6DofSpringConstraint::setEquilibriumPoint))
	.function("isSpringEnabled", &btGeneric6DofSpringConstraint::isSpringEnabled)
	.function("getStiffness", &btGeneric6DofSpringConstraint::getStiffness)
	.function("getDamping", &btGeneric6DofSpringConstraint::getDamping)
	.function("getEquilibriumPoint", &btGeneric6DofSpringConstraint::getEquilibriumPoint)
	.function("setAxis", &btGeneric6DofSpringConstraint::setAxis)
	.constructor<r.btRigidBody,r.btRigidBody,r.btVector3,r.btVector3,r.btVector3>()
	.function("getAnchor", &btHinge2Constraint::getAnchor)
	.function("getAnchor2", &btHinge2Constraint::getAnchor2)
	.function("getAxis1", &btHinge2Constraint::getAxis1)
	.function("getAxis2", &btHinge2Constraint::getAxis2)
	.function("getAngle1", &btHinge2Constraint::getAngle1)
	.function("getAngle2", &btHinge2Constraint::getAngle2)
	.function("setUpperLimit", &btHinge2Constraint::setUpperLimit)
	.function("setLowerLimit", &btHinge2Constraint::setLowerLimit)
	enum_<btHingeFlags>("btHingeFlags")
		;
	.constructor<r.btRigidBody,r.btRigidBody,r.q(const).btVector3,r.q(const).btVector3,r.q(const).btVector3,r.q(const).btVector3,bool>()
	.constructor<r.btRigidBody,r.btRigidBody,r.q(const).btVector3,r.q(const).btVector3,r.q(const).btVector3,r.q(const).btVector3>()
	.constructor<r.btRigidBody,r.q(const).btVector3,r.q(const).btVector3,bool>()
	.constructor<r.btRigidBody,r.q(const).btVector3,r.q(const).btVector3>()
	.constructor<r.btRigidBody,r.btRigidBody,r.q(const).btTransform,r.q(const).btTransform,bool>()
	.constructor<r.btRigidBody,r.btRigidBody,r.q(const).btTransform,r.q(const).btTransform>()
	.constructor<r.btRigidBody,r.q(const).btTransform,bool>()
	.constructor<r.btRigidBody,r.q(const).btTransform>()
	.function("getInfo1NonVirtual", &btHingeConstraint::getInfo1NonVirtual)
	.function("getInfo2NonVirtual", &btHingeConstraint::getInfo2NonVirtual)
	.function("getInfo2Internal", &btHingeConstraint::getInfo2Internal)
	.function("getInfo2InternalUsingFrameOffset", &btHingeConstraint::getInfo2InternalUsingFrameOffset)
	.function("updateRHS", &btHingeConstraint::updateRHS)
	.function("getRigidBodyA", select_overload<q(const).btRigidBody()const>(&btHingeConstraint::getRigidBodyA))
	.function("getRigidBodyB", select_overload<q(const).btRigidBody()const>(&btHingeConstraint::getRigidBodyB))
	.function("getRigidBodyA", select_overload<btRigidBody()>(&btHingeConstraint::getRigidBodyA))
	.function("getRigidBodyB", select_overload<btRigidBody()>(&btHingeConstraint::getRigidBodyB))
	.function("getFrameOffsetA", &btHingeConstraint::getFrameOffsetA)
	.function("getFrameOffsetB", &btHingeConstraint::getFrameOffsetB)
	.function("setFrames", &btHingeConstraint::setFrames)
	.function("setAngularOnly", &btHingeConstraint::setAngularOnly)
	.function("enableAngularMotor", &btHingeConstraint::enableAngularMotor)
	.function("enableMotor", &btHingeConstraint::enableMotor)
	.function("setMaxMotorImpulse", &btHingeConstraint::setMaxMotorImpulse)
	.function("setMotorTargetVelocity", &btHingeConstraint::setMotorTargetVelocity)
	.function("setMotorTarget_r.q(const).btQuaternion_btScalar", select_overload<void(r.q(const).btQuaternion, btScalar)>(&btHingeConstraint::setMotorTarget))
	.function("setMotorTarget_btScalar_btScalar", select_overload<void(btScalar, btScalar)>(&btHingeConstraint::setMotorTarget))
	.function("setLimit_btScalar_btScalar_btScalar_btScalar_btScalar", select_overload<void(btScalar, btScalar, btScalar, btScalar, btScalar)>(&btHingeConstraint::setLimit))
	.function("setLimit_btScalar_btScalar_btScalar_btScalar", select_overload<void(btScalar, btScalar, btScalar, btScalar)>(&btHingeConstraint::setLimit))
	.function("setLimit_btScalar_btScalar_btScalar", select_overload<void(btScalar, btScalar, btScalar)>(&btHingeConstraint::setLimit))
	.function("setLimit_btScalar_btScalar", select_overload<void(btScalar, btScalar)>(&btHingeConstraint::setLimit))
	.function("getLimitSoftness", &btHingeConstraint::getLimitSoftness)
	.function("getLimitBiasFactor", &btHingeConstraint::getLimitBiasFactor)
	.function("getLimitRelaxationFactor", &btHingeConstraint::getLimitRelaxationFactor)
	.function("setAxis", &btHingeConstraint::setAxis)
	.function("hasLimit", &btHingeConstraint::hasLimit)
	.function("getLowerLimit", &btHingeConstraint::getLowerLimit)
	.function("getUpperLimit", &btHingeConstraint::getUpperLimit)
	.function("getHingeAngle", select_overload<btScalar()>(&btHingeConstraint::getHingeAngle))
	.function("getHingeAngle_r.q(const).btTransform_r.q(const).btTransform", select_overload<btScalar(r.q(const).btTransform, r.q(const).btTransform)>(&btHingeConstraint::getHingeAngle))
	.function("testLimit", &btHingeConstraint::testLimit)
	.function("getAFrame", select_overload<q(const).btTransform()const>(&btHingeConstraint::getAFrame))
	.function("getBFrame", select_overload<q(const).btTransform()const>(&btHingeConstraint::getBFrame))
	.function("getAFrame", select_overload<btTransform()>(&btHingeConstraint::getAFrame))
	.function("getBFrame", select_overload<btTransform()>(&btHingeConstraint::getBFrame))
	.function("getSolveLimit", &btHingeConstraint::getSolveLimit)
	.function("getLimitSign", &btHingeConstraint::getLimitSign)
	.function("getAngularOnly", &btHingeConstraint::getAngularOnly)
	.function("getEnableAngularMotor", &btHingeConstraint::getEnableAngularMotor)
	.function("getMotorTargetVelosity", &btHingeConstraint::getMotorTargetVelosity)
	.function("getMaxMotorImpulse", &btHingeConstraint::getMaxMotorImpulse)
	.function("getUseFrameOffset", &btHingeConstraint::getUseFrameOffset)
	.function("setUseFrameOffset", &btHingeConstraint::setUseFrameOffset)
	.function("getUseReferenceFrameA", &btHingeConstraint::getUseReferenceFrameA)
	.function("setUseReferenceFrameA", &btHingeConstraint::setUseReferenceFrameA)
	.function("setParam_int_btScalar_int", select_overload<void(int, btScalar, int)>(&btHingeConstraint::setParam))
	.function("setParam_int_btScalar", select_overload<void(int, btScalar)>(&btHingeConstraint::setParam))
	.function("getParam_int_int", select_overload<btScalar(int, int)const>(&btHingeConstraint::getParam))
	.function("getParam_int", select_overload<btScalar(int)const>(&btHingeConstraint::getParam))
	.function("getFlags", &btHingeConstraint::getFlags)
	.constructor<r.btRigidBody,r.btRigidBody,r.q(const).btVector3,r.q(const).btVector3,r.q(const).btVector3,r.q(const).btVector3,bool>()
	.constructor<r.btRigidBody,r.btRigidBody,r.q(const).btVector3,r.q(const).btVector3,r.q(const).btVector3,r.q(const).btVector3>()
	.constructor<r.btRigidBody,r.q(const).btVector3,r.q(const).btVector3,bool>()
	.constructor<r.btRigidBody,r.q(const).btVector3,r.q(const).btVector3>()
	.constructor<r.btRigidBody,r.btRigidBody,r.q(const).btTransform,r.q(const).btTransform,bool>()
	.constructor<r.btRigidBody,r.btRigidBody,r.q(const).btTransform,r.q(const).btTransform>()
	.constructor<r.btRigidBody,r.q(const).btTransform,bool>()
	.constructor<r.btRigidBody,r.q(const).btTransform>()
	.function("getAccumulatedHingeAngle", &btHingeAccumulatedAngleConstraint::getAccumulatedHingeAngle)
	.function("setAccumulatedHingeAngle", &btHingeAccumulatedAngleConstraint::setAccumulatedHingeAngle)
	enum_<btPoint2PointFlags>("btPoint2PointFlags")
		;
	.constructor<r.btRigidBody,r.btRigidBody,r.q(const).btVector3,r.q(const).btVector3>()
	.constructor<r.btRigidBody,r.q(const).btVector3>()
	.function("getInfo1NonVirtual", &btPoint2PointConstraint::getInfo1NonVirtual)
	.function("getInfo2NonVirtual", &btPoint2PointConstraint::getInfo2NonVirtual)
	.function("updateRHS", &btPoint2PointConstraint::updateRHS)
	.function("setPivotA", &btPoint2PointConstraint::setPivotA)
	.function("setPivotB", &btPoint2PointConstraint::setPivotB)
	.function("getPivotInA", &btPoint2PointConstraint::getPivotInA)
	.function("getPivotInB", &btPoint2PointConstraint::getPivotInB)
	.function("setParam_int_btScalar_int", select_overload<void(int, btScalar, int)>(&btPoint2PointConstraint::setParam))
	.function("setParam_int_btScalar", select_overload<void(int, btScalar)>(&btPoint2PointConstraint::setParam))
	.function("getParam_int_int", select_overload<btScalar(int, int)const>(&btPoint2PointConstraint::getParam))
	.function("getParam_int", select_overload<btScalar(int)const>(&btPoint2PointConstraint::getParam))
	.function("getFlags", &btPoint2PointConstraint::getFlags)
	enum_<btSliderFlags>("btSliderFlags")
		;
	.function("initParams", &btSliderConstraint::initParams)
	.constructor<r.btRigidBody,r.btRigidBody,r.q(const).btTransform,r.q(const).btTransform,bool>()
	.constructor<r.btRigidBody,r.q(const).btTransform,bool>()
	.function("getInfo1NonVirtual", &btSliderConstraint::getInfo1NonVirtual)
	.function("getInfo2NonVirtual", &btSliderConstraint::getInfo2NonVirtual)
	.function("getRigidBodyA", &btSliderConstraint::getRigidBodyA)
	.function("getRigidBodyB", &btSliderConstraint::getRigidBodyB)
	.function("getCalculatedTransformA", &btSliderConstraint::getCalculatedTransformA)
	.function("getCalculatedTransformB", &btSliderConstraint::getCalculatedTransformB)
	.function("getFrameOffsetA", select_overload<q(const).btTransform()const>(&btSliderConstraint::getFrameOffsetA))
	.function("getFrameOffsetB", select_overload<q(const).btTransform()const>(&btSliderConstraint::getFrameOffsetB))
	.function("getFrameOffsetA", select_overload<btTransform()>(&btSliderConstraint::getFrameOffsetA))
	.function("getFrameOffsetB", select_overload<btTransform()>(&btSliderConstraint::getFrameOffsetB))
	.function("getLowerLinLimit", &btSliderConstraint::getLowerLinLimit)
	.function("setLowerLinLimit", &btSliderConstraint::setLowerLinLimit)
	.function("getUpperLinLimit", &btSliderConstraint::getUpperLinLimit)
	.function("setUpperLinLimit", &btSliderConstraint::setUpperLinLimit)
	.function("getLowerAngLimit", &btSliderConstraint::getLowerAngLimit)
	.function("setLowerAngLimit", &btSliderConstraint::setLowerAngLimit)
	.function("getUpperAngLimit", &btSliderConstraint::getUpperAngLimit)
	.function("setUpperAngLimit", &btSliderConstraint::setUpperAngLimit)
	.function("getUseLinearReferenceFrameA", &btSliderConstraint::getUseLinearReferenceFrameA)
	.function("getSoftnessDirLin", &btSliderConstraint::getSoftnessDirLin)
	.function("getRestitutionDirLin", &btSliderConstraint::getRestitutionDirLin)
	.function("getDampingDirLin", &btSliderConstraint::getDampingDirLin)
	.function("getSoftnessDirAng", &btSliderConstraint::getSoftnessDirAng)
	.function("getRestitutionDirAng", &btSliderConstraint::getRestitutionDirAng)
	.function("getDampingDirAng", &btSliderConstraint::getDampingDirAng)
	.function("getSoftnessLimLin", &btSliderConstraint::getSoftnessLimLin)
	.function("getRestitutionLimLin", &btSliderConstraint::getRestitutionLimLin)
	.function("getDampingLimLin", &btSliderConstraint::getDampingLimLin)
	.function("getSoftnessLimAng", &btSliderConstraint::getSoftnessLimAng)
	.function("getRestitutionLimAng", &btSliderConstraint::getRestitutionLimAng)
	.function("getDampingLimAng", &btSliderConstraint::getDampingLimAng)
	.function("getSoftnessOrthoLin", &btSliderConstraint::getSoftnessOrthoLin)
	.function("getRestitutionOrthoLin", &btSliderConstraint::getRestitutionOrthoLin)
	.function("getDampingOrthoLin", &btSliderConstraint::getDampingOrthoLin)
	.function("getSoftnessOrthoAng", &btSliderConstraint::getSoftnessOrthoAng)
	.function("getRestitutionOrthoAng", &btSliderConstraint::getRestitutionOrthoAng)
	.function("getDampingOrthoAng", &btSliderConstraint::getDampingOrthoAng)
	.function("setSoftnessDirLin", &btSliderConstraint::setSoftnessDirLin)
	.function("setRestitutionDirLin", &btSliderConstraint::setRestitutionDirLin)
	.function("setDampingDirLin", &btSliderConstraint::setDampingDirLin)
	.function("setSoftnessDirAng", &btSliderConstraint::setSoftnessDirAng)
	.function("setRestitutionDirAng", &btSliderConstraint::setRestitutionDirAng)
	.function("setDampingDirAng", &btSliderConstraint::setDampingDirAng)
	.function("setSoftnessLimLin", &btSliderConstraint::setSoftnessLimLin)
	.function("setRestitutionLimLin", &btSliderConstraint::setRestitutionLimLin)
	.function("setDampingLimLin", &btSliderConstraint::setDampingLimLin)
	.function("setSoftnessLimAng", &btSliderConstraint::setSoftnessLimAng)
	.function("setRestitutionLimAng", &btSliderConstraint::setRestitutionLimAng)
	.function("setDampingLimAng", &btSliderConstraint::setDampingLimAng)
	.function("setSoftnessOrthoLin", &btSliderConstraint::setSoftnessOrthoLin)
	.function("setRestitutionOrthoLin", &btSliderConstraint::setRestitutionOrthoLin)
	.function("setDampingOrthoLin", &btSliderConstraint::setDampingOrthoLin)
	.function("setSoftnessOrthoAng", &btSliderConstraint::setSoftnessOrthoAng)
	.function("setRestitutionOrthoAng", &btSliderConstraint::setRestitutionOrthoAng)
	.function("setDampingOrthoAng", &btSliderConstraint::setDampingOrthoAng)
	.function("setPoweredLinMotor", &btSliderConstraint::setPoweredLinMotor)
	.function("getPoweredLinMotor", &btSliderConstraint::getPoweredLinMotor)
	.function("setTargetLinMotorVelocity", &btSliderConstraint::setTargetLinMotorVelocity)
	.function("getTargetLinMotorVelocity", &btSliderConstraint::getTargetLinMotorVelocity)
	.function("setMaxLinMotorForce", &btSliderConstraint::setMaxLinMotorForce)
	.function("getMaxLinMotorForce", &btSliderConstraint::getMaxLinMotorForce)
	.function("setPoweredAngMotor", &btSliderConstraint::setPoweredAngMotor)
	.function("getPoweredAngMotor", &btSliderConstraint::getPoweredAngMotor)
	.function("setTargetAngMotorVelocity", &btSliderConstraint::setTargetAngMotorVelocity)
	.function("getTargetAngMotorVelocity", &btSliderConstraint::getTargetAngMotorVelocity)
	.function("setMaxAngMotorForce", &btSliderConstraint::setMaxAngMotorForce)
	.function("getMaxAngMotorForce", &btSliderConstraint::getMaxAngMotorForce)
	.function("getLinearPos", &btSliderConstraint::getLinearPos)
	.function("getAngularPos", &btSliderConstraint::getAngularPos)
	.function("getSolveLinLimit", &btSliderConstraint::getSolveLinLimit)
	.function("getLinDepth", &btSliderConstraint::getLinDepth)
	.function("getSolveAngLimit", &btSliderConstraint::getSolveAngLimit)
	.function("getAngDepth", &btSliderConstraint::getAngDepth)
	.function("calculateTransforms", &btSliderConstraint::calculateTransforms)
	.function("testLinLimits", &btSliderConstraint::testLinLimits)
	.function("testAngLimits", &btSliderConstraint::testAngLimits)
	.function("getAncorInA", &btSliderConstraint::getAncorInA)
	.function("getAncorInB", &btSliderConstraint::getAncorInB)
	.function("getUseFrameOffset", &btSliderConstraint::getUseFrameOffset)
	.function("setUseFrameOffset", &btSliderConstraint::setUseFrameOffset)
	.function("setFrames", &btSliderConstraint::setFrames)
	.function("setParam_int_btScalar_int", select_overload<void(int, btScalar, int)>(&btSliderConstraint::setParam))
	.function("setParam_int_btScalar", select_overload<void(int, btScalar)>(&btSliderConstraint::setParam))
	.function("getParam_int_int", select_overload<btScalar(int, int)const>(&btSliderConstraint::getParam))
	.function("getParam_int", select_overload<btScalar(int)const>(&btSliderConstraint::getParam))
	.function("getFlags", &btSliderConstraint::getFlags)
	.constructor<btScalar,btScalar>()
	.function("resolveUnilateralPairConstraint", &btSolve2LinearConstraint::resolveUnilateralPairConstraint)
	.function("resolveBilateralPairConstraint", &btSolve2LinearConstraint::resolveBilateralPairConstraint)
	.constructor<r.btRigidBody,r.btRigidBody,r.q(const).btVector3,r.q(const).btVector3,r.q(const).btVector3>()
	.function("getAnchor", &btUniversalConstraint::getAnchor)
	.function("getAnchor2", &btUniversalConstraint::getAnchor2)
	.function("getAxis1", &btUniversalConstraint::getAxis1)
	.function("getAxis2", &btUniversalConstraint::getAxis2)
	.function("getAngle1", &btUniversalConstraint::getAngle1)
	.function("getAngle2", &btUniversalConstraint::getAngle2)
	.function("setUpperLimit", &btUniversalConstraint::setUpperLimit)
	.function("setLowerLimit", &btUniversalConstraint::setLowerLimit)
	.function("setAxis", &btUniversalConstraint::setAxis)
	enum_<btDynamicsWorldType>("btDynamicsWorldType")
		;
	.constructor<p.btDispatcher,p.btBroadphaseInterface,p.btCollisionConfiguration>()
	.function("stepSimulation_btScalar_int_btScalar", select_overload<int(btScalar, int, btScalar)>(&btDynamicsWorld::stepSimulation))
	.function("stepSimulation_btScalar_int", select_overload<int(btScalar, int)>(&btDynamicsWorld::stepSimulation))
	.function("stepSimulation_btScalar", select_overload<int(btScalar)>(&btDynamicsWorld::stepSimulation))
	.function("addConstraint_p.btTypedConstraint_bool", select_overload<void(p.btTypedConstraint, bool)>(&btDynamicsWorld::addConstraint))
	.function("addConstraint_p.btTypedConstraint", select_overload<void(p.btTypedConstraint)>(&btDynamicsWorld::addConstraint))
	.function("removeConstraint", &btDynamicsWorld::removeConstraint)
	.function("addAction", &btDynamicsWorld::addAction)
	.function("removeAction", &btDynamicsWorld::removeAction)
	.function("setGravity", &btDynamicsWorld::setGravity)
	.function("getGravity", &btDynamicsWorld::getGravity)
	.function("synchronizeMotionStates", &btDynamicsWorld::synchronizeMotionStates)
	.function("addRigidBody_p.btRigidBody", select_overload<void(p.btRigidBody)>(&btDynamicsWorld::addRigidBody))
	.function("addRigidBody_p.btRigidBody_int_int", select_overload<void(p.btRigidBody, int, int)>(&btDynamicsWorld::addRigidBody))
	.function("removeRigidBody", &btDynamicsWorld::removeRigidBody)
	.function("setConstraintSolver", &btDynamicsWorld::setConstraintSolver)
	.function("getConstraintSolver", &btDynamicsWorld::getConstraintSolver)
	.function("getNumConstraints", &btDynamicsWorld::getNumConstraints)
	.function("getConstraint_int", select_overload<btTypedConstraint(int)>(&btDynamicsWorld::getConstraint))
	.function("getConstraint_int", select_overload<q(const).btTypedConstraint(int)const>(&btDynamicsWorld::getConstraint))
	.function("getWorldType", &btDynamicsWorld::getWorldType)
	.function("clearForces", &btDynamicsWorld::clearForces)
	.function("setInternalTickCallback_btInternalTickCallback_p.void_bool", select_overload<void(btInternalTickCallback, p.void, bool)>(&btDynamicsWorld::setInternalTickCallback))
	.function("setInternalTickCallback_btInternalTickCallback_p.void", select_overload<void(btInternalTickCallback, p.void)>(&btDynamicsWorld::setInternalTickCallback))
	.function("setInternalTickCallback_btInternalTickCallback", select_overload<void(btInternalTickCallback)>(&btDynamicsWorld::setInternalTickCallback))
	.function("setWorldUserInfo", &btDynamicsWorld::setWorldUserInfo)
	.function("getWorldUserInfo", &btDynamicsWorld::getWorldUserInfo)
	.function("getSolverInfo", &btDynamicsWorld::getSolverInfo)
	.function("addVehicle", &btDynamicsWorld::addVehicle)
	.function("removeVehicle", &btDynamicsWorld::removeVehicle)
	.function("addCharacter", &btDynamicsWorld::addCharacter)
	.function("removeCharacter", &btDynamicsWorld::removeCharacter)
	.function("lock", &btSpinMutex::lock)
	.function("unlock", &btSpinMutex::unlock)
	.function("tryLock", &btSpinMutex::tryLock)
	.function("predictUnconstraintMotion", &btDiscreteDynamicsWorld::predictUnconstraintMotion)
	.function("integrateTransformsInternal", &btDiscreteDynamicsWorld::integrateTransformsInternal)
	.function("integrateTransforms", &btDiscreteDynamicsWorld::integrateTransforms)
	.function("calculateSimulationIslands", &btDiscreteDynamicsWorld::calculateSimulationIslands)
	.function("solveConstraints", &btDiscreteDynamicsWorld::solveConstraints)
	.function("updateActivationState", &btDiscreteDynamicsWorld::updateActivationState)
	.function("updateActions", &btDiscreteDynamicsWorld::updateActions)
	.function("startProfiling", &btDiscreteDynamicsWorld::startProfiling)
	.function("internalSingleStepSimulation", &btDiscreteDynamicsWorld::internalSingleStepSimulation)
	.function("releasePredictiveContacts", &btDiscreteDynamicsWorld::releasePredictiveContacts)
	.function("createPredictiveContactsInternal", &btDiscreteDynamicsWorld::createPredictiveContactsInternal)
	.function("createPredictiveContacts", &btDiscreteDynamicsWorld::createPredictiveContacts)
	.function("saveKinematicState", &btDiscreteDynamicsWorld::saveKinematicState)
	.function("serializeRigidBodies", &btDiscreteDynamicsWorld::serializeRigidBodies)
	.function("serializeDynamicsWorldInfo", &btDiscreteDynamicsWorld::serializeDynamicsWorldInfo)
	.constructor<p.btDispatcher,p.btBroadphaseInterface,p.btConstraintSolver,p.btCollisionConfiguration>()
	.function("stepSimulation_btScalar_int_btScalar", select_overload<int(btScalar, int, btScalar)>(&btDiscreteDynamicsWorld::stepSimulation))
	.function("stepSimulation_btScalar_int", select_overload<int(btScalar, int)>(&btDiscreteDynamicsWorld::stepSimulation))
	.function("stepSimulation_btScalar", select_overload<int(btScalar)>(&btDiscreteDynamicsWorld::stepSimulation))
	.function("synchronizeSingleMotionState", &btDiscreteDynamicsWorld::synchronizeSingleMotionState)
	.function("addConstraint_p.btTypedConstraint_bool", select_overload<void(p.btTypedConstraint, bool)>(&btDiscreteDynamicsWorld::addConstraint))
	.function("addConstraint_p.btTypedConstraint", select_overload<void(p.btTypedConstraint)>(&btDiscreteDynamicsWorld::addConstraint))
	.function("getSimulationIslandManager", select_overload<btSimulationIslandManager()>(&btDiscreteDynamicsWorld::getSimulationIslandManager))
	.function("getSimulationIslandManager", select_overload<q(const).btSimulationIslandManager()const>(&btDiscreteDynamicsWorld::getSimulationIslandManager))
	.function("getCollisionWorld", &btDiscreteDynamicsWorld::getCollisionWorld)
	.function("addCollisionObject_p.btCollisionObject_int_int", select_overload<void(p.btCollisionObject, int, int)>(&btDiscreteDynamicsWorld::addCollisionObject))
	.function("addCollisionObject_p.btCollisionObject_int", select_overload<void(p.btCollisionObject, int)>(&btDiscreteDynamicsWorld::addCollisionObject))
	.function("addCollisionObject_p.btCollisionObject", select_overload<void(p.btCollisionObject)>(&btDiscreteDynamicsWorld::addCollisionObject))
	.function("addRigidBody_p.btRigidBody", select_overload<void(p.btRigidBody)>(&btDiscreteDynamicsWorld::addRigidBody))
	.function("addRigidBody_p.btRigidBody_int_int", select_overload<void(p.btRigidBody, int, int)>(&btDiscreteDynamicsWorld::addRigidBody))
	.function("debugDrawConstraint", &btDiscreteDynamicsWorld::debugDrawConstraint)
	.function("getConstraint_int", select_overload<btTypedConstraint(int)>(&btDiscreteDynamicsWorld::getConstraint))
	.function("getConstraint_int", select_overload<q(const).btTypedConstraint(int)const>(&btDiscreteDynamicsWorld::getConstraint))
	.function("applyGravity", &btDiscreteDynamicsWorld::applyGravity)
	.function("setNumTasks", &btDiscreteDynamicsWorld::setNumTasks)
	.function("updateVehicles", &btDiscreteDynamicsWorld::updateVehicles)
	.function("setSynchronizeAllMotionStates", &btDiscreteDynamicsWorld::setSynchronizeAllMotionStates)
	.function("getSynchronizeAllMotionStates", &btDiscreteDynamicsWorld::getSynchronizeAllMotionStates)
	.function("setApplySpeculativeContactRestitution", &btDiscreteDynamicsWorld::setApplySpeculativeContactRestitution)
	.function("getApplySpeculativeContactRestitution", &btDiscreteDynamicsWorld::getApplySpeculativeContactRestitution)
	.function("setLatencyMotionStateInterpolation", &btDiscreteDynamicsWorld::setLatencyMotionStateInterpolation)
	.function("getLatencyMotionStateInterpolation", &btDiscreteDynamicsWorld::getLatencyMotionStateInterpolation)
	enum_<btMultiBodyLinkFlags>("btMultiBodyLinkFlags")
		;
	.constructor<r.q(const).btVector3,r.q(const).btVector3>()
	.constructor<r.q(const).btScalar,r.q(const).btScalar,r.q(const).btScalar,r.q(const).btScalar,r.q(const).btScalar,r.q(const).btScalar>()
	.function("setVector", &btSpatialForceVector::setVector)
	.function("setValue", &btSpatialForceVector::setValue)
	.function("addVector", &btSpatialForceVector::addVector)
	.function("addValue", &btSpatialForceVector::addValue)
	.function("getLinear", &btSpatialForceVector::getLinear)
	.function("getAngular", &btSpatialForceVector::getAngular)
	.function("setLinear", &btSpatialForceVector::setLinear)
	.function("setAngular", &btSpatialForceVector::setAngular)
	.function("addAngular", &btSpatialForceVector::addAngular)
	.function("addLinear", &btSpatialForceVector::addLinear)
	.function("setZero", &btSpatialForceVector::setZero)
	.function("operator +=", &btSpatialForceVector::operator +=)
	.function("operator -=", &btSpatialForceVector::operator -=)
	.function("operator -_r.q(const).btSpatialForceVector", select_overload<btSpatialForceVector(r.q(const).btSpatialForceVector)const>(&btSpatialForceVector::operator -))
	.function("operator +", &btSpatialForceVector::operator +)
	.function("operator -", select_overload<btSpatialForceVector()const>(&btSpatialForceVector::operator -))
	.function("operator *", &btSpatialForceVector::operator *)
	.constructor<r.q(const).btVector3,r.q(const).btVector3>()
	.function("setVector", &btSpatialMotionVector::setVector)
	.function("setValue", &btSpatialMotionVector::setValue)
	.function("addVector", &btSpatialMotionVector::addVector)
	.function("addValue", &btSpatialMotionVector::addValue)
	.function("getAngular", &btSpatialMotionVector::getAngular)
	.function("getLinear", &btSpatialMotionVector::getLinear)
	.function("setAngular", &btSpatialMotionVector::setAngular)
	.function("setLinear", &btSpatialMotionVector::setLinear)
	.function("addAngular", &btSpatialMotionVector::addAngular)
	.function("addLinear", &btSpatialMotionVector::addLinear)
	.function("setZero", &btSpatialMotionVector::setZero)
	.function("operator +=", &btSpatialMotionVector::operator +=)
	.function("operator -=", &btSpatialMotionVector::operator -=)
	.function("operator *=", &btSpatialMotionVector::operator *=)
	.function("operator -_r.q(const).btSpatialMotionVector", select_overload<btSpatialMotionVector(r.q(const).btSpatialMotionVector)const>(&btSpatialMotionVector::operator -))
	.function("operator +", &btSpatialMotionVector::operator +)
	.function("operator -", select_overload<btSpatialMotionVector()const>(&btSpatialMotionVector::operator -))
	.function("operator *", &btSpatialMotionVector::operator *)
	.constructor<r.q(const).btMatrix3x3,r.q(const).btMatrix3x3,r.q(const).btMatrix3x3>()
	.function("setMatrix", &btSymmetricSpatialDyad::setMatrix)
	.function("addMatrix", &btSymmetricSpatialDyad::addMatrix)
	.function("setIdentity", &btSymmetricSpatialDyad::setIdentity)
	.function("operator -=", &btSymmetricSpatialDyad::operator -=)
	.function("operator *", &btSymmetricSpatialDyad::operator *)
	enum_<btSpatialTransformationMatrix::eOutputOperation>("btSpatialTransformationMatrix::eOutputOperation")
		;
	.function("transformInverse_r.q(const).btSymmetricSpatialDyad_r.btSymmetricSpatialDyad_btSpatialTransformationMatrix::eOutputOperation", select_overload<void(r.q(const).btSymmetricSpatialDyad, r.btSymmetricSpatialDyad, btSpatialTransformationMatrix::eOutputOperation)>(&btSpatialTransformationMatrix::transformInverse))
	.function("transformInverse_r.q(const).btSymmetricSpatialDyad_r.btSymmetricSpatialDyad", select_overload<void(r.q(const).btSymmetricSpatialDyad, r.btSymmetricSpatialDyad)>(&btSpatialTransformationMatrix::transformInverse))
	enum_<btMultibodyLink::eFeatherstoneJointType>("btMultibodyLink::eFeatherstoneJointType")
		;
	.function("setAxisTop_int_r.q(const).btVector3", select_overload<void(int, r.q(const).btVector3)>(&btMultibodyLink::setAxisTop))
	.function("setAxisBottom_int_r.q(const).btVector3", select_overload<void(int, r.q(const).btVector3)>(&btMultibodyLink::setAxisBottom))
	.function("setAxisTop_int_r.q(const).btScalar_r.q(const).btScalar_r.q(const).btScalar", select_overload<void(int, r.q(const).btScalar, r.q(const).btScalar, r.q(const).btScalar)>(&btMultibodyLink::setAxisTop))
	.function("setAxisBottom_int_r.q(const).btScalar_r.q(const).btScalar_r.q(const).btScalar", select_overload<void(int, r.q(const).btScalar, r.q(const).btScalar, r.q(const).btScalar)>(&btMultibodyLink::setAxisBottom))
	.function("getAxisTop", &btMultibodyLink::getAxisTop)
	.function("getAxisBottom", &btMultibodyLink::getAxisBottom)
	.function("updateCacheMultiDof_p.btScalar", select_overload<void(p.btScalar)>(&btMultibodyLink::updateCacheMultiDof))
	.function("updateCacheMultiDof", select_overload<void()>(&btMultibodyLink::updateCacheMultiDof))
	.constructor<int,btScalar,r.q(const).btVector3,bool,bool,bool>()
	.constructor<int,btScalar,r.q(const).btVector3,bool,bool>()
	.function("setupFixed_int_btScalar_r.q(const).btVector3_int_r.q(const).btQuaternion_r.q(const).btVector3_r.q(const).btVector3_bool", select_overload<void(int, btScalar, r.q(const).btVector3, int, r.q(const).btQuaternion, r.q(const).btVector3, r.q(const).btVector3, bool)>(&btMultiBody::setupFixed))
	.function("setupFixed_int_btScalar_r.q(const).btVector3_int_r.q(const).btQuaternion_r.q(const).btVector3_r.q(const).btVector3", select_overload<void(int, btScalar, r.q(const).btVector3, int, r.q(const).btQuaternion, r.q(const).btVector3, r.q(const).btVector3)>(&btMultiBody::setupFixed))
	.function("setupPrismatic", &btMultiBody::setupPrismatic)
	.function("setupRevolute_int_btScalar_r.q(const).btVector3_int_r.q(const).btQuaternion_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3_bool", select_overload<void(int, btScalar, r.q(const).btVector3, int, r.q(const).btQuaternion, r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3, bool)>(&btMultiBody::setupRevolute))
	.function("setupRevolute_int_btScalar_r.q(const).btVector3_int_r.q(const).btQuaternion_r.q(const).btVector3_r.q(const).btVector3_r.q(const).btVector3", select_overload<void(int, btScalar, r.q(const).btVector3, int, r.q(const).btQuaternion, r.q(const).btVector3, r.q(const).btVector3, r.q(const).btVector3)>(&btMultiBody::setupRevolute))
	.function("setupSpherical_int_btScalar_r.q(const).btVector3_int_r.q(const).btQuaternion_r.q(const).btVector3_r.q(const).btVector3_bool", select_overload<void(int, btScalar, r.q(const).btVector3, int, r.q(const).btQuaternion, r.q(const).btVector3, r.q(const).btVector3, bool)>(&btMultiBody::setupSpherical))
	.function("setupSpherical_int_btScalar_r.q(const).btVector3_int_r.q(const).btQuaternion_r.q(const).btVector3_r.q(const).btVector3", select_overload<void(int, btScalar, r.q(const).btVector3, int, r.q(const).btQuaternion, r.q(const).btVector3, r.q(const).btVector3)>(&btMultiBody::setupSpherical))
	.function("setupPlanar_int_btScalar_r.q(const).btVector3_int_r.q(const).btQuaternion_r.q(const).btVector3_r.q(const).btVector3_bool", select_overload<void(int, btScalar, r.q(const).btVector3, int, r.q(const).btQuaternion, r.q(const).btVector3, r.q(const).btVector3, bool)>(&btMultiBody::setupPlanar))
	.function("setupPlanar_int_btScalar_r.q(const).btVector3_int_r.q(const).btQuaternion_r.q(const).btVector3_r.q(const).btVector3", select_overload<void(int, btScalar, r.q(const).btVector3, int, r.q(const).btQuaternion, r.q(const).btVector3, r.q(const).btVector3)>(&btMultiBody::setupPlanar))
	.function("getLink_int", select_overload<q(const).btMultibodyLink(int)const>(&btMultiBody::getLink))
	.function("getLink_int", select_overload<btMultibodyLink(int)>(&btMultiBody::getLink))
	.function("setBaseCollider", &btMultiBody::setBaseCollider)
	.function("getBaseCollider", select_overload<q(const).btMultiBodyLinkCollider()const>(&btMultiBody::getBaseCollider))
	.function("getBaseCollider", select_overload<btMultiBodyLinkCollider()>(&btMultiBody::getBaseCollider))
	.function("getParent", &btMultiBody::getParent)
	.function("getNumLinks", &btMultiBody::getNumLinks)
	.function("getNumDofs", &btMultiBody::getNumDofs)
	.function("getNumPosVars", &btMultiBody::getNumPosVars)
	.function("getBaseMass", &btMultiBody::getBaseMass)
	.function("getBaseInertia", &btMultiBody::getBaseInertia)
	.function("getLinkMass", &btMultiBody::getLinkMass)
	.function("getLinkInertia", &btMultiBody::getLinkInertia)
	.function("setBaseMass", &btMultiBody::setBaseMass)
	.function("setBaseInertia", &btMultiBody::setBaseInertia)
	.function("getBasePos", &btMultiBody::getBasePos)
	.function("getBaseVel", &btMultiBody::getBaseVel)
	.function("getWorldToBaseRot", &btMultiBody::getWorldToBaseRot)
	.function("getBaseOmega", &btMultiBody::getBaseOmega)
	.function("setBasePos", &btMultiBody::setBasePos)
	.function("setBaseWorldTransform", &btMultiBody::setBaseWorldTransform)
	.function("getBaseWorldTransform", &btMultiBody::getBaseWorldTransform)
	.function("setBaseVel", &btMultiBody::setBaseVel)
	.function("setWorldToBaseRot", &btMultiBody::setWorldToBaseRot)
	.function("setBaseOmega", &btMultiBody::setBaseOmega)
	.function("getJointPos", &btMultiBody::getJointPos)
	.function("getJointVel", &btMultiBody::getJointVel)
	.function("getJointVelMultiDof_int", select_overload<btScalar(int)>(&btMultiBody::getJointVelMultiDof))
	.function("getJointPosMultiDof_int", select_overload<btScalar(int)>(&btMultiBody::getJointPosMultiDof))
	.function("getJointVelMultiDof_int", select_overload<q(const).btScalar(int)const>(&btMultiBody::getJointVelMultiDof))
	.function("getJointPosMultiDof_int", select_overload<q(const).btScalar(int)const>(&btMultiBody::getJointPosMultiDof))
	.function("setJointPos", &btMultiBody::setJointPos)
	.function("setJointVel", &btMultiBody::setJointVel)
	.function("setJointPosMultiDof", &btMultiBody::setJointPosMultiDof)
	.function("setJointVelMultiDof", &btMultiBody::setJointVelMultiDof)
	.function("getVelocityVector", &btMultiBody::getVelocityVector)
	.function("getRVector", &btMultiBody::getRVector)
	.function("getParentToLocalRot", &btMultiBody::getParentToLocalRot)
	.function("localPosToWorld", &btMultiBody::localPosToWorld)
	.function("localDirToWorld", &btMultiBody::localDirToWorld)
	.function("worldPosToLocal", &btMultiBody::worldPosToLocal)
	.function("worldDirToLocal", &btMultiBody::worldDirToLocal)
	.function("localFrameToWorld", &btMultiBody::localFrameToWorld)
	.function("getKineticEnergy", &btMultiBody::getKineticEnergy)
	.function("getAngularMomentum", &btMultiBody::getAngularMomentum)
	.function("clearForcesAndTorques", &btMultiBody::clearForcesAndTorques)
	.function("clearConstraintForces", &btMultiBody::clearConstraintForces)
	.function("clearVelocities", &btMultiBody::clearVelocities)
	.function("addBaseForce", &btMultiBody::addBaseForce)
	.function("addBaseTorque", &btMultiBody::addBaseTorque)
	.function("addLinkForce", &btMultiBody::addLinkForce)
	.function("addLinkTorque", &btMultiBody::addLinkTorque)
	.function("addBaseConstraintForce", &btMultiBody::addBaseConstraintForce)
	.function("addBaseConstraintTorque", &btMultiBody::addBaseConstraintTorque)
	.function("addLinkConstraintForce", &btMultiBody::addLinkConstraintForce)
	.function("addLinkConstraintTorque", &btMultiBody::addLinkConstraintTorque)
	.function("addJointTorque", &btMultiBody::addJointTorque)
	.function("addJointTorqueMultiDof_int_int_btScalar", select_overload<void(int, int, btScalar)>(&btMultiBody::addJointTorqueMultiDof))
	.function("addJointTorqueMultiDof_int_p.q(const).btScalar", select_overload<void(int, p.q(const).btScalar)>(&btMultiBody::addJointTorqueMultiDof))
	.function("getBaseForce", &btMultiBody::getBaseForce)
	.function("getBaseTorque", &btMultiBody::getBaseTorque)
	.function("getLinkForce", &btMultiBody::getLinkForce)
	.function("getLinkTorque", &btMultiBody::getLinkTorque)
	.function("getJointTorque", &btMultiBody::getJointTorque)
	.function("getJointTorqueMultiDof", &btMultiBody::getJointTorqueMultiDof)
	.function("computeAccelerationsArticulatedBodyAlgorithmMultiDof_btScalar_r.btAlignedObjectArray<(btScalar)>_r.btAlignedObjectArray<(btVector3)>_r.btAlignedObjectArray<(btMatrix3x3)>_bool", select_overload<void(btScalar, r.btAlignedObjectArray<(btScalar)>, r.btAlignedObjectArray<(btVector3)>, r.btAlignedObjectArray<(btMatrix3x3)>, bool)>(&btMultiBody::computeAccelerationsArticulatedBodyAlgorithmMultiDof))
	.function("computeAccelerationsArticulatedBodyAlgorithmMultiDof_btScalar_r.btAlignedObjectArray<(btScalar)>_r.btAlignedObjectArray<(btVector3)>_r.btAlignedObjectArray<(btMatrix3x3)>", select_overload<void(btScalar, r.btAlignedObjectArray<(btScalar)>, r.btAlignedObjectArray<(btVector3)>, r.btAlignedObjectArray<(btMatrix3x3)>)>(&btMultiBody::computeAccelerationsArticulatedBodyAlgorithmMultiDof))
	.function("stepVelocitiesMultiDof_btScalar_r.btAlignedObjectArray<(btScalar)>_r.btAlignedObjectArray<(btVector3)>_r.btAlignedObjectArray<(btMatrix3x3)>_bool", select_overload<void(btScalar, r.btAlignedObjectArray<(btScalar)>, r.btAlignedObjectArray<(btVector3)>, r.btAlignedObjectArray<(btMatrix3x3)>, bool)>(&btMultiBody::stepVelocitiesMultiDof))
	.function("stepVelocitiesMultiDof_btScalar_r.btAlignedObjectArray<(btScalar)>_r.btAlignedObjectArray<(btVector3)>_r.btAlignedObjectArray<(btMatrix3x3)>", select_overload<void(btScalar, r.btAlignedObjectArray<(btScalar)>, r.btAlignedObjectArray<(btVector3)>, r.btAlignedObjectArray<(btMatrix3x3)>)>(&btMultiBody::stepVelocitiesMultiDof))
	.function("calcAccelerationDeltasMultiDof", &btMultiBody::calcAccelerationDeltasMultiDof)
	.function("applyDeltaVeeMultiDof2", &btMultiBody::applyDeltaVeeMultiDof2)
	.function("processDeltaVeeMultiDof2", &btMultiBody::processDeltaVeeMultiDof2)
	.function("applyDeltaVeeMultiDof", &btMultiBody::applyDeltaVeeMultiDof)
	.function("stepPositionsMultiDof_btScalar_p.btScalar_p.btScalar", select_overload<void(btScalar, p.btScalar, p.btScalar)>(&btMultiBody::stepPositionsMultiDof))
	.function("stepPositionsMultiDof_btScalar_p.btScalar", select_overload<void(btScalar, p.btScalar)>(&btMultiBody::stepPositionsMultiDof))
	.function("stepPositionsMultiDof_btScalar", select_overload<void(btScalar)>(&btMultiBody::stepPositionsMultiDof))
	.function("fillContactJacobianMultiDof", &btMultiBody::fillContactJacobianMultiDof)
	.function("fillConstraintJacobianMultiDof", &btMultiBody::fillConstraintJacobianMultiDof)
	.function("setCanSleep", &btMultiBody::setCanSleep)
	.function("getCanSleep", &btMultiBody::getCanSleep)
	.function("isAwake", &btMultiBody::isAwake)
	.function("wakeUp", &btMultiBody::wakeUp)
	.function("goToSleep", &btMultiBody::goToSleep)
	.function("checkMotionAndSleepIfRequired", &btMultiBody::checkMotionAndSleepIfRequired)
	.function("hasFixedBase", &btMultiBody::hasFixedBase)
	.function("getCompanionId", &btMultiBody::getCompanionId)
	.function("setCompanionId", &btMultiBody::setCompanionId)
	.function("setNumLinks", &btMultiBody::setNumLinks)
	.function("getLinearDamping", &btMultiBody::getLinearDamping)
	.function("setLinearDamping", &btMultiBody::setLinearDamping)
	.function("getAngularDamping", &btMultiBody::getAngularDamping)
	.function("setAngularDamping", &btMultiBody::setAngularDamping)
	.function("getUseGyroTerm", &btMultiBody::getUseGyroTerm)
	.function("setUseGyroTerm", &btMultiBody::setUseGyroTerm)
	.function("getMaxCoordinateVelocity", &btMultiBody::getMaxCoordinateVelocity)
	.function("setMaxCoordinateVelocity", &btMultiBody::setMaxCoordinateVelocity)
	.function("getMaxAppliedImpulse", &btMultiBody::getMaxAppliedImpulse)
	.function("setMaxAppliedImpulse", &btMultiBody::setMaxAppliedImpulse)
	.function("setHasSelfCollision", &btMultiBody::setHasSelfCollision)
	.function("hasSelfCollision", &btMultiBody::hasSelfCollision)
	.function("finalizeMultiDof", &btMultiBody::finalizeMultiDof)
	.function("useRK4Integration", &btMultiBody::useRK4Integration)
	.function("isUsingRK4Integration", &btMultiBody::isUsingRK4Integration)
	.function("useGlobalVelocities", &btMultiBody::useGlobalVelocities)
	.function("isUsingGlobalVelocities", &btMultiBody::isUsingGlobalVelocities)
	.function("isPosUpdated", &btMultiBody::isPosUpdated)
	.function("setPosUpdated", &btMultiBody::setPosUpdated)
	.function("internalNeedsJointFeedback", &btMultiBody::internalNeedsJointFeedback)
	.function("forwardKinematics", &btMultiBody::forwardKinematics)
	.function("compTreeLinkVelocities", &btMultiBody::compTreeLinkVelocities)
	.function("updateCollisionObjectWorldTransforms", &btMultiBody::updateCollisionObjectWorldTransforms)
	.function("calculateSerializeBufferSize", &btMultiBody::calculateSerializeBufferSize)
	.function("serialize", &btMultiBody::serialize)
	.function("getBaseName", &btMultiBody::getBaseName)
	.function("setBaseName", &btMultiBody::setBaseName)
	.function("getUserPointer", &btMultiBody::getUserPointer)
	.function("getUserIndex", &btMultiBody::getUserIndex)
	.function("getUserIndex2", &btMultiBody::getUserIndex2)
	.function("setUserPointer", &btMultiBody::setUserPointer)
	.function("setUserIndex", &btMultiBody::setUserIndex)
	.function("setUserIndex2", &btMultiBody::setUserIndex2)
	.constructor<r.q(const).btMultiBody>()
	.function("operator =", &btMultiBody::operator =)
	.function("solveImatrix", &btMultiBody::solveImatrix)
	.function("solveImatrix", &btMultiBody::solveImatrix)
	.function("updateLinksDofOffsets", &btMultiBody::updateLinksDofOffsets)
	.function("mulMatrix", &btMultiBody::mulMatrix)
	enum_<btMultiBodySolverConstraint::btSolverConstraintType>("btMultiBodySolverConstraint::btSolverConstraintType")
		;
	.function("applyDeltaVee", &btMultiBodyConstraint::applyDeltaVee)
	.function("fillMultiBodyConstraint", &btMultiBodyConstraint::fillMultiBodyConstraint)
	.function("fillMultiBodyConstraint", &btMultiBodyConstraint::fillMultiBodyConstraint)
	.function("fillMultiBodyConstraint", &btMultiBodyConstraint::fillMultiBodyConstraint)
	.function("fillMultiBodyConstraint", &btMultiBodyConstraint::fillMultiBodyConstraint)
	.function("fillMultiBodyConstraint", &btMultiBodyConstraint::fillMultiBodyConstraint)
	.function("fillMultiBodyConstraint", &btMultiBodyConstraint::fillMultiBodyConstraint)
	.constructor<p.btMultiBody,p.btMultiBody,int,int,int,bool>()
	.function("updateJacobianSizes", &btMultiBodyConstraint::updateJacobianSizes)
	.function("allocateJacobiansMultiDof", &btMultiBodyConstraint::allocateJacobiansMultiDof)
	.function("setFrameInB", &btMultiBodyConstraint::setFrameInB)
	.function("setPivotInB", &btMultiBodyConstraint::setPivotInB)
	.function("finalizeMultiDof", &btMultiBodyConstraint::finalizeMultiDof)
	.function("getIslandIdA", &btMultiBodyConstraint::getIslandIdA)
	.function("getIslandIdB", &btMultiBodyConstraint::getIslandIdB)
	.function("createConstraintRows", &btMultiBodyConstraint::createConstraintRows)
	.function("getNumRows", &btMultiBodyConstraint::getNumRows)
	.function("getMultiBodyA", &btMultiBodyConstraint::getMultiBodyA)
	.function("getMultiBodyB", &btMultiBodyConstraint::getMultiBodyB)
	.function("internalSetAppliedImpulse", &btMultiBodyConstraint::internalSetAppliedImpulse)
	.function("getAppliedImpulse", &btMultiBodyConstraint::getAppliedImpulse)
	.function("getPosition", &btMultiBodyConstraint::getPosition)
	.function("setPosition", &btMultiBodyConstraint::setPosition)
	.function("isUnilateral", &btMultiBodyConstraint::isUnilateral)
	.function("jacobianA_int", select_overload<btScalar(int)>(&btMultiBodyConstraint::jacobianA))
	.function("jacobianA_int", select_overload<q(const).btScalar(int)const>(&btMultiBodyConstraint::jacobianA))
	.function("jacobianB_int", select_overload<btScalar(int)>(&btMultiBodyConstraint::jacobianB))
	.function("jacobianB_int", select_overload<q(const).btScalar(int)const>(&btMultiBodyConstraint::jacobianB))
	.function("getMaxAppliedImpulse", &btMultiBodyConstraint::getMaxAppliedImpulse)
	.function("setMaxAppliedImpulse", &btMultiBodyConstraint::setMaxAppliedImpulse)
	.function("debugDraw", &btMultiBodyConstraint::debugDraw)
	.function("resolveSingleConstraintRowGeneric", &btMultiBodyConstraintSolver::resolveSingleConstraintRowGeneric)
	.function("convertContacts", &btMultiBodyConstraintSolver::convertContacts)
	.function("addMultiBodyFrictionConstraint", &btMultiBodyConstraintSolver::addMultiBodyFrictionConstraint)
	.function("addMultiBodyFrictionConstraint", &btMultiBodyConstraintSolver::addMultiBodyFrictionConstraint)
	.function("addMultiBodyFrictionConstraint", &btMultiBodyConstraintSolver::addMultiBodyFrictionConstraint)
	.function("addMultiBodyTorsionalFrictionConstraint", &btMultiBodyConstraintSolver::addMultiBodyTorsionalFrictionConstraint)
	.function("addMultiBodyTorsionalFrictionConstraint", &btMultiBodyConstraintSolver::addMultiBodyTorsionalFrictionConstraint)
	.function("addMultiBodyTorsionalFrictionConstraint", &btMultiBodyConstraintSolver::addMultiBodyTorsionalFrictionConstraint)
	.function("setupMultiBodyJointLimitConstraint", &btMultiBodyConstraintSolver::setupMultiBodyJointLimitConstraint)
	.function("setupMultiBodyContactConstraint", &btMultiBodyConstraintSolver::setupMultiBodyContactConstraint)
	.function("setupMultiBodyContactConstraint", &btMultiBodyConstraintSolver::setupMultiBodyContactConstraint)
	.function("setupMultiBodyContactConstraint", &btMultiBodyConstraintSolver::setupMultiBodyContactConstraint)
	.function("setupMultiBodyTorsionalFrictionConstraint", &btMultiBodyConstraintSolver::setupMultiBodyTorsionalFrictionConstraint)
	.function("setupMultiBodyTorsionalFrictionConstraint", &btMultiBodyConstraintSolver::setupMultiBodyTorsionalFrictionConstraint)
	.function("setupMultiBodyTorsionalFrictionConstraint", &btMultiBodyConstraintSolver::setupMultiBodyTorsionalFrictionConstraint)
	.function("convertMultiBodyContact", &btMultiBodyConstraintSolver::convertMultiBodyContact)
	.function("solveGroupCacheFriendlySetup", &btMultiBodyConstraintSolver::solveGroupCacheFriendlySetup)
	.function("solveSingleIteration", &btMultiBodyConstraintSolver::solveSingleIteration)
	.function("applyDeltaVee", &btMultiBodyConstraintSolver::applyDeltaVee)
	.function("writeBackSolverBodyToMultiBody", &btMultiBodyConstraintSolver::writeBackSolverBodyToMultiBody)
	.function("solveGroupCacheFriendlyFinish", &btMultiBodyConstraintSolver::solveGroupCacheFriendlyFinish)
	.function("solveMultiBodyGroup", &btMultiBodyConstraintSolver::solveMultiBodyGroup)
	.constructor<p.btMultiBody,int,btScalar,btScalar>()
	.constructor<p.btMultiBody,int,btScalar,btScalar>()
	.constructor<p.btMultiBody,int,int,btScalar,btScalar>()
	.function("setVelocityTarget_btScalar_btScalar", select_overload<void(btScalar, btScalar)>(&btMultiBodyJointMotor::setVelocityTarget))
	.function("setVelocityTarget_btScalar", select_overload<void(btScalar)>(&btMultiBodyJointMotor::setVelocityTarget))
	.function("setPositionTarget_btScalar_btScalar", select_overload<void(btScalar, btScalar)>(&btMultiBodyJointMotor::setPositionTarget))
	.function("setPositionTarget_btScalar", select_overload<void(btScalar)>(&btMultiBodyJointMotor::setPositionTarget))
	.function("setErp", &btMultiBodyJointMotor::setErp)
	.function("getErp", &btMultiBodyJointMotor::getErp)
	.function("setRhsClamp", &btMultiBodyJointMotor::setRhsClamp)
	.constructor<p.btMultiBody,int>()
	.class_function("upcast", &btMultiBodyLinkCollider::upcast)
	.class_function("upcast", &btMultiBodyLinkCollider::upcast)
	.constructor<p.btMultiBody,int,p.btRigidBody,r.q(const).btVector3,r.q(const).btVector3>()
	.constructor<p.btMultiBody,int,p.btMultiBody,int,r.q(const).btVector3,r.q(const).btVector3>()
	.function("getPivotInB", &btMultiBodyPoint2Point::getPivotInB)
	.constructor<r.q(const).btClock>()
	.function("operator =", &btClock::operator =)
	.function("reset", &btClock::reset)
	.function("getTimeMilliseconds", &btClock::getTimeMilliseconds)
	.function("getTimeMicroseconds", &btClock::getTimeMicroseconds)
	.function("getTimeNanoseconds", &btClock::getTimeNanoseconds)
	.function("getTimeSeconds", &btClock::getTimeSeconds)
	.constructor<p.q(const).char,p.CProfileNode>()
	.function("Get_Sub_Node", &CProfileNode::Get_Sub_Node)
	.function("Get_Parent", &CProfileNode::Get_Parent)
	.function("Get_Sibling", &CProfileNode::Get_Sibling)
	.function("Get_Child", &CProfileNode::Get_Child)
	.function("CleanupMemory", &CProfileNode::CleanupMemory)
	.function("Reset", &CProfileNode::Reset)
	.function("Call", &CProfileNode::Call)
	.function("Return", &CProfileNode::Return)
	.function("Get_Name", &CProfileNode::Get_Name)
	.function("Get_Total_Calls", &CProfileNode::Get_Total_Calls)
	.function("Get_Total_Time", &CProfileNode::Get_Total_Time)
	.function("GetUserPointer", &CProfileNode::GetUserPointer)
	.function("SetUserPointer", &CProfileNode::SetUserPointer)
	.class_function("Start_Profile", &CProfileManager::Start_Profile)
	.class_function("Stop_Profile", &CProfileManager::Stop_Profile)
	.class_function("CleanupMemory", &CProfileManager::CleanupMemory)
	.class_function("Reset", &CProfileManager::Reset)
	.class_function("Increment_Frame_Counter", &CProfileManager::Increment_Frame_Counter)
	.class_function("Get_Frame_Count_Since_Reset", &CProfileManager::Get_Frame_Count_Since_Reset)
	.class_function("Get_Time_Since_Reset", &CProfileManager::Get_Time_Since_Reset)
	.class_function("Get_Iterator", &CProfileManager::Get_Iterator)
	.class_function("Release_Iterator", &CProfileManager::Release_Iterator)
	.class_function("dumpRecursive", &CProfileManager::dumpRecursive)
	.class_function("dumpAll", &CProfileManager::dumpAll)
	.constructor<p.q(const).char>()
	.function("operator ()", &btIntSortPredicate::operator ())
	.function("solveMLCP_r.q(const).btMatrixXf_r.q(const).btVectorXf_r.btVectorXf_r.q(const).btVectorXf_r.q(const).btVectorXf_r.q(const).btAlignedObjectArray<(int)>_int_bool", select_overload<bool(r.q(const).btMatrixXf, r.q(const).btVectorXf, r.btVectorXf, r.q(const).btVectorXf, r.q(const).btVectorXf, r.q(const).btAlignedObjectArray<(int)>, int, bool)>(&btMLCPSolverInterface::solveMLCP))
	.function("solveMLCP_r.q(const).btMatrixXf_r.q(const).btVectorXf_r.btVectorXf_r.q(const).btVectorXf_r.q(const).btVectorXf_r.q(const).btAlignedObjectArray<(int)>_int", select_overload<bool(r.q(const).btMatrixXf, r.q(const).btVectorXf, r.btVectorXf, r.q(const).btVectorXf, r.q(const).btVectorXf, r.q(const).btAlignedObjectArray<(int)>, int)>(&btMLCPSolverInterface::solveMLCP))
	.function("solveMLCP_r.q(const).btMatrixXf_r.q(const).btVectorXf_r.btVectorXf_r.q(const).btVectorXf_r.q(const).btVectorXf_r.q(const).btAlignedObjectArray<(int)>_int_bool", select_overload<bool(r.q(const).btMatrixXf, r.q(const).btVectorXf, r.btVectorXf, r.q(const).btVectorXf, r.q(const).btVectorXf, r.q(const).btAlignedObjectArray<(int)>, int, bool)>(&btDantzigSolver::solveMLCP))
	.function("solveMLCP_r.q(const).btMatrixXf_r.q(const).btVectorXf_r.btVectorXf_r.q(const).btVectorXf_r.q(const).btVectorXf_r.q(const).btAlignedObjectArray<(int)>_int", select_overload<bool(r.q(const).btMatrixXf, r.q(const).btVectorXf, r.btVectorXf, r.q(const).btVectorXf, r.q(const).btVectorXf, r.q(const).btAlignedObjectArray<(int)>, int)>(&btDantzigSolver::solveMLCP))
	.function("solveGroupCacheFriendlySetup", &btMLCPSolver::solveGroupCacheFriendlySetup)
	.function("solveGroupCacheFriendlyIterations", &btMLCPSolver::solveGroupCacheFriendlyIterations)
	.function("createMLCP", &btMLCPSolver::createMLCP)
	.function("createMLCPFast", &btMLCPSolver::createMLCPFast)
	.function("solveMLCP", &btMLCPSolver::solveMLCP)
	.constructor<p.btMLCPSolverInterface>()
	.function("setMLCPSolver", &btMLCPSolver::setMLCPSolver)
	.function("getNumFallbacks", &btMLCPSolver::getNumFallbacks)
	.function("setNumFallbacks", &btMLCPSolver::setNumFallbacks)
	.function("solveMLCP_r.q(const).btMatrixXf_r.q(const).btVectorXf_r.btVectorXf_r.q(const).btVectorXf_r.q(const).btVectorXf_r.q(const).btAlignedObjectArray<(int)>_int_bool", select_overload<bool(r.q(const).btMatrixXf, r.q(const).btVectorXf, r.btVectorXf, r.q(const).btVectorXf, r.q(const).btVectorXf, r.q(const).btAlignedObjectArray<(int)>, int, bool)>(&btSolveProjectedGaussSeidel::solveMLCP))
	.function("solveMLCP_r.q(const).btMatrixXf_r.q(const).btVectorXf_r.btVectorXf_r.q(const).btVectorXf_r.q(const).btVectorXf_r.q(const).btAlignedObjectArray<(int)>_int", select_overload<bool(r.q(const).btMatrixXf, r.q(const).btVectorXf, r.btVectorXf, r.q(const).btVectorXf, r.q(const).btVectorXf, r.q(const).btAlignedObjectArray<(int)>, int)>(&btSolveProjectedGaussSeidel::solveMLCP))
	.function("castRay", &btVehicleRaycaster::castRay)
	.function("getSuspensionRestLength", &btWheelInfo::getSuspensionRestLength)
	.constructor<r.btWheelInfoConstructionInfo>()
	.function("updateWheel", &btWheelInfo::updateWheel)
	.function("defaultInit", &btRaycastVehicle::defaultInit)
	.constructor<r.q(const).btRaycastVehicle::btVehicleTuning,p.btRigidBody,p.btVehicleRaycaster>()
	.function("getChassisWorldTransform", &btRaycastVehicle::getChassisWorldTransform)
	.function("rayCast", &btRaycastVehicle::rayCast)
	.function("updateVehicle", &btRaycastVehicle::updateVehicle)
	.function("resetSuspension", &btRaycastVehicle::resetSuspension)
	.function("getSteeringValue", &btRaycastVehicle::getSteeringValue)
	.function("setSteeringValue", &btRaycastVehicle::setSteeringValue)
	.function("applyEngineForce", &btRaycastVehicle::applyEngineForce)
	.function("getWheelTransformWS", &btRaycastVehicle::getWheelTransformWS)
	.function("updateWheelTransform_int_bool", select_overload<void(int, bool)>(&btRaycastVehicle::updateWheelTransform))
	.function("updateWheelTransform_int", select_overload<void(int)>(&btRaycastVehicle::updateWheelTransform))
	.function("addWheel", &btRaycastVehicle::addWheel)
	.function("getNumWheels", &btRaycastVehicle::getNumWheels)
	.function("getWheelInfo_int", select_overload<q(const).btWheelInfo(int)const>(&btRaycastVehicle::getWheelInfo))
	.function("getWheelInfo_int", select_overload<btWheelInfo(int)>(&btRaycastVehicle::getWheelInfo))
	.function("updateWheelTransformsWS_r.btWheelInfo_bool", select_overload<void(r.btWheelInfo, bool)>(&btRaycastVehicle::updateWheelTransformsWS))
	.function("updateWheelTransformsWS_r.btWheelInfo", select_overload<void(r.btWheelInfo)>(&btRaycastVehicle::updateWheelTransformsWS))
	.function("setBrake", &btRaycastVehicle::setBrake)
	.function("setPitchControl", &btRaycastVehicle::setPitchControl)
	.function("updateSuspension", &btRaycastVehicle::updateSuspension)
	.function("updateFriction", &btRaycastVehicle::updateFriction)
	.function("getRigidBody", select_overload<btRigidBody()>(&btRaycastVehicle::getRigidBody))
	.function("getRigidBody", select_overload<q(const).btRigidBody()const>(&btRaycastVehicle::getRigidBody))
	.function("getRightAxis", &btRaycastVehicle::getRightAxis)
	.function("getUpAxis", &btRaycastVehicle::getUpAxis)
	.function("getForwardAxis", &btRaycastVehicle::getForwardAxis)
	.function("getForwardVector", &btRaycastVehicle::getForwardVector)
	.function("getCurrentSpeedKmHour", &btRaycastVehicle::getCurrentSpeedKmHour)
	.function("setCoordinateSystem", &btRaycastVehicle::setCoordinateSystem)
	.function("getUserConstraintType", &btRaycastVehicle::getUserConstraintType)
	.function("setUserConstraintType", &btRaycastVehicle::setUserConstraintType)
	.function("setUserConstraintId", &btRaycastVehicle::setUserConstraintId)
	.function("getUserConstraintId", &btRaycastVehicle::getUserConstraintId)
	.constructor<p.btDynamicsWorld>()
	enum_<btSoftBodySolver::SolverTypes>("btSoftBodySolver::SolverTypes")
		;
	.function("getSolverType", &btSoftBodySolver::getSolverType)
	.function("checkInitialized", &btSoftBodySolver::checkInitialized)
	.function("optimize_r.btAlignedObjectArray<(p.btSoftBody)>_bool", select_overload<void(r.btAlignedObjectArray<(p.btSoftBody)>, bool)>(&btSoftBodySolver::optimize))
	.function("optimize_r.btAlignedObjectArray<(p.btSoftBody)>", select_overload<void(r.btAlignedObjectArray<(p.btSoftBody)>)>(&btSoftBodySolver::optimize))
	.function("copyBackToSoftBodies_bool", select_overload<void(bool)>(&btSoftBodySolver::copyBackToSoftBodies))
	.function("copyBackToSoftBodies", select_overload<void()>(&btSoftBodySolver::copyBackToSoftBodies))
	.function("predictMotion", &btSoftBodySolver::predictMotion)
	.function("solveConstraints", &btSoftBodySolver::solveConstraints)
	.function("updateSoftBodies", &btSoftBodySolver::updateSoftBodies)
	.function("processCollision_p.btSoftBody_p.q(const).btCollisionObjectWrapper", select_overload<void(p.btSoftBody, p.q(const).btCollisionObjectWrapper)>(&btSoftBodySolver::processCollision))
	.function("processCollision_p.btSoftBody_p.btSoftBody", select_overload<void(p.btSoftBody, p.btSoftBody)>(&btSoftBodySolver::processCollision))
	.function("setNumberOfPositionIterations", &btSoftBodySolver::setNumberOfPositionIterations)
	.function("getNumberOfPositionIterations", &btSoftBodySolver::getNumberOfPositionIterations)
	.function("setNumberOfVelocityIterations", &btSoftBodySolver::setNumberOfVelocityIterations)
	.function("getNumberOfVelocityIterations", &btSoftBodySolver::getNumberOfVelocityIterations)
	.function("getTimeScale", &btSoftBodySolver::getTimeScale)
	.function("copySoftBodyToVertexBuffer", &btSoftBodySolverOutput::copySoftBodyToVertexBuffer)
	enum_<btVertexBufferDescriptor::BufferTypes>("btVertexBufferDescriptor::BufferTypes")
		;
	.function("hasVertexPositions", &btVertexBufferDescriptor::hasVertexPositions)
	.function("hasNormals", &btVertexBufferDescriptor::hasNormals)
	.function("getBufferType", &btVertexBufferDescriptor::getBufferType)
	.function("getVertexOffset", &btVertexBufferDescriptor::getVertexOffset)
	.function("getVertexStride", &btVertexBufferDescriptor::getVertexStride)
	.function("getNormalOffset", &btVertexBufferDescriptor::getNormalOffset)
	.function("getNormalStride", &btVertexBufferDescriptor::getNormalStride)
	.constructor<p.float,int,int>()
	.constructor<p.float,int,int,int,int>()
	.function("getBasePointer", &btCPUVertexBufferDescriptor::getBasePointer)
	.function("optimize_r.btAlignedObjectArray<(p.btSoftBody)>_bool", select_overload<void(r.btAlignedObjectArray<(p.btSoftBody)>, bool)>(&btDefaultSoftBodySolver::optimize))
	.function("optimize_r.btAlignedObjectArray<(p.btSoftBody)>", select_overload<void(r.btAlignedObjectArray<(p.btSoftBody)>)>(&btDefaultSoftBodySolver::optimize))
	.function("copyBackToSoftBodies_bool", select_overload<void(bool)>(&btDefaultSoftBodySolver::copyBackToSoftBodies))
	.function("copyBackToSoftBodies", select_overload<void()>(&btDefaultSoftBodySolver::copyBackToSoftBodies))
	.function("copySoftBodyToVertexBuffer", &btDefaultSoftBodySolver::copySoftBodyToVertexBuffer)
	.function("processCollision_p.btSoftBody_p.q(const).btCollisionObjectWrapper", select_overload<void(p.btSoftBody, p.q(const).btCollisionObjectWrapper)>(&btDefaultSoftBodySolver::processCollision))
	.function("processCollision_p.btSoftBody_p.btSoftBody", select_overload<void(p.btSoftBody, p.btSoftBody)>(&btDefaultSoftBodySolver::processCollision))
	.constructor<p.btSoftBodyWorldInfo,int,p.q(const).btVector3,p.q(const).btScalar>()
	.constructor<p.btSoftBodyWorldInfo>()
	.function("initDefaults", &btSoftBody::initDefaults)
	.function("getWorldInfo", &btSoftBody::getWorldInfo)
	.function("checkLink_int_int", select_overload<bool(int, int)const>(&btSoftBody::checkLink))
	.function("checkLink_p.q(const).btSoftBody::Node_p.q(const).btSoftBody::Node", select_overload<bool(p.q(const).btSoftBody::Node, p.q(const).btSoftBody::Node)const>(&btSoftBody::checkLink))
	.function("checkFace", &btSoftBody::checkFace)
	.function("appendMaterial", &btSoftBody::appendMaterial)
	.function("appendNote_p.q(const).char_r.q(const).btVector3_r.q(const).btVector4_p.btSoftBody::Node_p.btSoftBody::Node_p.btSoftBody::Node_p.btSoftBody::Node", select_overload<void(p.q(const).char, r.q(const).btVector3, r.q(const).btVector4, p.btSoftBody::Node, p.btSoftBody::Node, p.btSoftBody::Node, p.btSoftBody::Node)>(&btSoftBody::appendNote))
	.function("appendNote_p.q(const).char_r.q(const).btVector3_r.q(const).btVector4_p.btSoftBody::Node_p.btSoftBody::Node_p.btSoftBody::Node", select_overload<void(p.q(const).char, r.q(const).btVector3, r.q(const).btVector4, p.btSoftBody::Node, p.btSoftBody::Node, p.btSoftBody::Node)>(&btSoftBody::appendNote))
	.function("appendNote_p.q(const).char_r.q(const).btVector3_r.q(const).btVector4_p.btSoftBody::Node_p.btSoftBody::Node", select_overload<void(p.q(const).char, r.q(const).btVector3, r.q(const).btVector4, p.btSoftBody::Node, p.btSoftBody::Node)>(&btSoftBody::appendNote))
	.function("appendNote_p.q(const).char_r.q(const).btVector3_r.q(const).btVector4_p.btSoftBody::Node", select_overload<void(p.q(const).char, r.q(const).btVector3, r.q(const).btVector4, p.btSoftBody::Node)>(&btSoftBody::appendNote))
	.function("appendNote_p.q(const).char_r.q(const).btVector3_r.q(const).btVector4", select_overload<void(p.q(const).char, r.q(const).btVector3, r.q(const).btVector4)>(&btSoftBody::appendNote))
	.function("appendNote_p.q(const).char_r.q(const).btVector3", select_overload<void(p.q(const).char, r.q(const).btVector3)>(&btSoftBody::appendNote))
	.function("appendNote_p.q(const).char_r.q(const).btVector3_p.btSoftBody::Node", select_overload<void(p.q(const).char, r.q(const).btVector3, p.btSoftBody::Node)>(&btSoftBody::appendNote))
	.function("appendNote_p.q(const).char_r.q(const).btVector3_p.btSoftBody::Link", select_overload<void(p.q(const).char, r.q(const).btVector3, p.btSoftBody::Link)>(&btSoftBody::appendNote))
	.function("appendNote_p.q(const).char_r.q(const).btVector3_p.btSoftBody::Face", select_overload<void(p.q(const).char, r.q(const).btVector3, p.btSoftBody::Face)>(&btSoftBody::appendNote))
	.function("appendNode", &btSoftBody::appendNode)
	.function("appendLink_int_p.btSoftBody::Material", select_overload<void(int, p.btSoftBody::Material)>(&btSoftBody::appendLink))
	.function("appendLink_int", select_overload<void(int)>(&btSoftBody::appendLink))
	.function("appendLink", select_overload<void()>(&btSoftBody::appendLink))
	.function("appendLink_int_int_p.btSoftBody::Material_bool", select_overload<void(int, int, p.btSoftBody::Material, bool)>(&btSoftBody::appendLink))
	.function("appendLink_int_int_p.btSoftBody::Material", select_overload<void(int, int, p.btSoftBody::Material)>(&btSoftBody::appendLink))
	.function("appendLink_int_int", select_overload<void(int, int)>(&btSoftBody::appendLink))
	.function("appendLink_p.btSoftBody::Node_p.btSoftBody::Node_p.btSoftBody::Material_bool", select_overload<void(p.btSoftBody::Node, p.btSoftBody::Node, p.btSoftBody::Material, bool)>(&btSoftBody::appendLink))
	.function("appendLink_p.btSoftBody::Node_p.btSoftBody::Node_p.btSoftBody::Material", select_overload<void(p.btSoftBody::Node, p.btSoftBody::Node, p.btSoftBody::Material)>(&btSoftBody::appendLink))
	.function("appendLink_p.btSoftBody::Node_p.btSoftBody::Node", select_overload<void(p.btSoftBody::Node, p.btSoftBody::Node)>(&btSoftBody::appendLink))
	.function("appendFace_int_p.btSoftBody::Material", select_overload<void(int, p.btSoftBody::Material)>(&btSoftBody::appendFace))
	.function("appendFace_int", select_overload<void(int)>(&btSoftBody::appendFace))
	.function("appendFace", select_overload<void()>(&btSoftBody::appendFace))
	.function("appendFace_int_int_int_p.btSoftBody::Material", select_overload<void(int, int, int, p.btSoftBody::Material)>(&btSoftBody::appendFace))
	.function("appendFace_int_int_int", select_overload<void(int, int, int)>(&btSoftBody::appendFace))
	.function("appendTetra_int_p.btSoftBody::Material", select_overload<void(int, p.btSoftBody::Material)>(&btSoftBody::appendTetra))
	.function("appendTetra_int_int_int_int_p.btSoftBody::Material", select_overload<void(int, int, int, int, p.btSoftBody::Material)>(&btSoftBody::appendTetra))
	.function("appendTetra_int_int_int_int", select_overload<void(int, int, int, int)>(&btSoftBody::appendTetra))
	.function("appendAnchor_int_p.btRigidBody_bool_btScalar", select_overload<void(int, p.btRigidBody, bool, btScalar)>(&btSoftBody::appendAnchor))
	.function("appendAnchor_int_p.btRigidBody_bool", select_overload<void(int, p.btRigidBody, bool)>(&btSoftBody::appendAnchor))
	.function("appendAnchor_int_p.btRigidBody", select_overload<void(int, p.btRigidBody)>(&btSoftBody::appendAnchor))
	.function("appendAnchor_int_p.btRigidBody_r.q(const).btVector3_bool_btScalar", select_overload<void(int, p.btRigidBody, r.q(const).btVector3, bool, btScalar)>(&btSoftBody::appendAnchor))
	.function("appendAnchor_int_p.btRigidBody_r.q(const).btVector3_bool", select_overload<void(int, p.btRigidBody, r.q(const).btVector3, bool)>(&btSoftBody::appendAnchor))
	.function("appendAnchor_int_p.btRigidBody_r.q(const).btVector3", select_overload<void(int, p.btRigidBody, r.q(const).btVector3)>(&btSoftBody::appendAnchor))
	.function("appendLinearJoint_r.q(const).btSoftBody::LJoint::Specs_p.btSoftBody::Cluster_btSoftBody::Body", select_overload<void(r.q(const).btSoftBody::LJoint::Specs, p.btSoftBody::Cluster, btSoftBody::Body)>(&btSoftBody::appendLinearJoint))
	.function("appendLinearJoint_r.q(const).btSoftBody::LJoint::Specs_btSoftBody::Body", select_overload<void(r.q(const).btSoftBody::LJoint::Specs, btSoftBody::Body)>(&btSoftBody::appendLinearJoint))
	.function("appendLinearJoint_r.q(const).btSoftBody::LJoint::Specs", select_overload<void(r.q(const).btSoftBody::LJoint::Specs)>(&btSoftBody::appendLinearJoint))
	.function("appendLinearJoint_r.q(const).btSoftBody::LJoint::Specs_p.btSoftBody", select_overload<void(r.q(const).btSoftBody::LJoint::Specs, p.btSoftBody)>(&btSoftBody::appendLinearJoint))
	.function("appendAngularJoint_r.q(const).btSoftBody::AJoint::Specs_p.btSoftBody::Cluster_btSoftBody::Body", select_overload<void(r.q(const).btSoftBody::AJoint::Specs, p.btSoftBody::Cluster, btSoftBody::Body)>(&btSoftBody::appendAngularJoint))
	.function("appendAngularJoint_r.q(const).btSoftBody::AJoint::Specs_btSoftBody::Body", select_overload<void(r.q(const).btSoftBody::AJoint::Specs, btSoftBody::Body)>(&btSoftBody::appendAngularJoint))
	.function("appendAngularJoint_r.q(const).btSoftBody::AJoint::Specs", select_overload<void(r.q(const).btSoftBody::AJoint::Specs)>(&btSoftBody::appendAngularJoint))
	.function("appendAngularJoint_r.q(const).btSoftBody::AJoint::Specs_p.btSoftBody", select_overload<void(r.q(const).btSoftBody::AJoint::Specs, p.btSoftBody)>(&btSoftBody::appendAngularJoint))
	.function("addForce_r.q(const).btVector3", select_overload<void(r.q(const).btVector3)>(&btSoftBody::addForce))
	.function("addForce_r.q(const).btVector3_int", select_overload<void(r.q(const).btVector3, int)>(&btSoftBody::addForce))
	.function("addAeroForceToNode", &btSoftBody::addAeroForceToNode)
	.function("addAeroForceToFace", &btSoftBody::addAeroForceToFace)
	.function("addVelocity_r.q(const).btVector3", select_overload<void(r.q(const).btVector3)>(&btSoftBody::addVelocity))
	.function("setVelocity", &btSoftBody::setVelocity)
	.function("addVelocity_r.q(const).btVector3_int", select_overload<void(r.q(const).btVector3, int)>(&btSoftBody::addVelocity))
	.function("setMass", &btSoftBody::setMass)
	.function("getMass", &btSoftBody::getMass)
	.function("getTotalMass", &btSoftBody::getTotalMass)
	.function("setTotalMass_btScalar_bool", select_overload<void(btScalar, bool)>(&btSoftBody::setTotalMass))
	.function("setTotalMass_btScalar", select_overload<void(btScalar)>(&btSoftBody::setTotalMass))
	.function("setTotalDensity", &btSoftBody::setTotalDensity)
	.function("setVolumeMass", &btSoftBody::setVolumeMass)
	.function("setVolumeDensity", &btSoftBody::setVolumeDensity)
	.function("transform", &btSoftBody::transform)
	.function("translate", &btSoftBody::translate)
	.function("rotate", &btSoftBody::rotate)
	.function("scale", &btSoftBody::scale)
	.function("getRestLengthScale", &btSoftBody::getRestLengthScale)
	.function("setRestLengthScale", &btSoftBody::setRestLengthScale)
	.function("setPose", &btSoftBody::setPose)
	.function("resetLinkRestLengths", &btSoftBody::resetLinkRestLengths)
	.function("getVolume", &btSoftBody::getVolume)
	.function("clusterCount", &btSoftBody::clusterCount)
	.class_function("clusterCom", &btSoftBody::clusterCom)
	.function("clusterCom_int", select_overload<btVector3(int)const>(&btSoftBody::clusterCom))
	.class_function("clusterVelocity", &btSoftBody::clusterVelocity)
	.class_function("clusterVImpulse", &btSoftBody::clusterVImpulse)
	.class_function("clusterDImpulse", &btSoftBody::clusterDImpulse)
	.class_function("clusterImpulse", &btSoftBody::clusterImpulse)
	.class_function("clusterVAImpulse", &btSoftBody::clusterVAImpulse)
	.class_function("clusterDAImpulse", &btSoftBody::clusterDAImpulse)
	.class_function("clusterAImpulse", &btSoftBody::clusterAImpulse)
	.class_function("clusterDCImpulse", &btSoftBody::clusterDCImpulse)
	.function("generateBendingConstraints_int_p.btSoftBody::Material", select_overload<int(int, p.btSoftBody::Material)>(&btSoftBody::generateBendingConstraints))
	.function("generateBendingConstraints_int", select_overload<int(int)>(&btSoftBody::generateBendingConstraints))
	.function("randomizeConstraints", &btSoftBody::randomizeConstraints)
	.function("releaseCluster", &btSoftBody::releaseCluster)
	.function("releaseClusters", &btSoftBody::releaseClusters)
	.function("generateClusters_int_int", select_overload<int(int, int)>(&btSoftBody::generateClusters))
	.function("generateClusters_int", select_overload<int(int)>(&btSoftBody::generateClusters))
	.function("refine", &btSoftBody::refine)
	.function("cutLink_int_int_btScalar", select_overload<bool(int, int, btScalar)>(&btSoftBody::cutLink))
	.function("cutLink_p.q(const).btSoftBody::Node_p.q(const).btSoftBody::Node_btScalar", select_overload<bool(p.q(const).btSoftBody::Node, p.q(const).btSoftBody::Node, btScalar)>(&btSoftBody::cutLink))
	.function("rayTest_r.q(const).btVector3_r.q(const).btVector3_r.btSoftBody::sRayCast", select_overload<bool(r.q(const).btVector3, r.q(const).btVector3, r.btSoftBody::sRayCast)>(&btSoftBody::rayTest))
	.function("setSolver", &btSoftBody::setSolver)
	.function("predictMotion", &btSoftBody::predictMotion)
	.function("solveConstraints", &btSoftBody::solveConstraints)
	.function("staticSolve", &btSoftBody::staticSolve)
	.class_function("solveCommonConstraints", &btSoftBody::solveCommonConstraints)
	.class_function("solveClusters", &btSoftBody::solveClusters)
	.function("integrateMotion", &btSoftBody::integrateMotion)
	.function("defaultCollisionHandler_p.q(const).btCollisionObjectWrapper", select_overload<void(p.q(const).btCollisionObjectWrapper)>(&btSoftBody::defaultCollisionHandler))
	.function("defaultCollisionHandler_p.btSoftBody", select_overload<void(p.btSoftBody)>(&btSoftBody::defaultCollisionHandler))
	.function("setWindVelocity", &btSoftBody::setWindVelocity)
	.function("getWindVelocity", &btSoftBody::getWindVelocity)
	.function("setSoftBodySolver", &btSoftBody::setSoftBodySolver)
	.function("getSoftBodySolver", select_overload<btSoftBodySolver()>(&btSoftBody::getSoftBodySolver))
	.function("getSoftBodySolver", select_overload<btSoftBodySolver()const>(&btSoftBody::getSoftBodySolver))
	.class_function("upcast", &btSoftBody::upcast)
	.class_function("upcast", &btSoftBody::upcast)
	.function("getAabb", &btSoftBody::getAabb)
	.function("pointersToIndices", &btSoftBody::pointersToIndices)
	.function("indicesToPointers_p.q(const).int", select_overload<void(p.q(const).int)>(&btSoftBody::indicesToPointers))
	.function("indicesToPointers", select_overload<void()>(&btSoftBody::indicesToPointers))
	.function("rayTest_r.q(const).btVector3_r.q(const).btVector3_r.btScalar_r.btSoftBody::eFeature::__r.int_bool", select_overload<int(r.q(const).btVector3, r.q(const).btVector3, r.btScalar, r.btSoftBody::eFeature::_, r.int, bool)const>(&btSoftBody::rayTest))
	.function("initializeFaceTree", &btSoftBody::initializeFaceTree)
	.function("evaluateCom", &btSoftBody::evaluateCom)
	.function("checkContact", &btSoftBody::checkContact)
	.function("updateNormals", &btSoftBody::updateNormals)
	.function("updateBounds", &btSoftBody::updateBounds)
	.function("updatePose", &btSoftBody::updatePose)
	.function("updateConstants", &btSoftBody::updateConstants)
	.function("updateLinkConstants", &btSoftBody::updateLinkConstants)
	.function("updateArea_bool", select_overload<void(bool)>(&btSoftBody::updateArea))
	.function("updateArea", select_overload<void()>(&btSoftBody::updateArea))
	.function("initializeClusters", &btSoftBody::initializeClusters)
	.function("updateClusters", &btSoftBody::updateClusters)
	.function("cleanupClusters", &btSoftBody::cleanupClusters)
	.function("prepareClusters", &btSoftBody::prepareClusters)
	.function("solveClusters_btScalar", select_overload<void(btScalar)>(&btSoftBody::solveClusters))
	.function("applyClusters", &btSoftBody::applyClusters)
	.function("dampClusters", &btSoftBody::dampClusters)
	.function("applyForces", &btSoftBody::applyForces)
	.class_function("PSolve_Anchors", &btSoftBody::PSolve_Anchors)
	.class_function("PSolve_RContacts", &btSoftBody::PSolve_RContacts)
	.class_function("PSolve_SContacts", &btSoftBody::PSolve_SContacts)
	.class_function("PSolve_Links", &btSoftBody::PSolve_Links)
	.class_function("VSolve_Links", &btSoftBody::VSolve_Links)
	.class_function("getSolver", &btSoftBody::getSolver)
	.class_function("getSolver", &btSoftBody::getSolver)
	.constructor<int,int,p.btCollisionShape>()
	.function("getTriangleIndex", &btTriIndex::getTriangleIndex)
	.function("getPartId", &btTriIndex::getPartId)
	.function("getUid", &btTriIndex::getUid)
	.constructor<p.btDispatcher,p.q(const).btCollisionObjectWrapper,p.q(const).btCollisionObjectWrapper,bool>()
	.function("setTimeStepAndCounters", &btSoftBodyTriangleCallback::setTimeStepAndCounters)
	.function("clearCache", &btSoftBodyTriangleCallback::clearCache)
	.function("getAabbMin", &btSoftBodyTriangleCallback::getAabbMin)
	.function("getAabbMax", &btSoftBodyTriangleCallback::getAabbMax)
	.constructor<r.q(const).btCollisionAlgorithmConstructionInfo,p.q(const).btCollisionObjectWrapper,p.q(const).btCollisionObjectWrapper,bool>()
	.function("clearCache", &btSoftBodyConcaveCollisionAlgorithm::clearCache)
	enum_<btSoftJointBodyType>("btSoftJointBodyType")
		;
	enum_<fDrawFlags::_>("fDrawFlags::_")
		;
	.class_function("Draw", &btSoftBodyHelpers::Draw)
	.class_function("Draw", &btSoftBodyHelpers::Draw)
	.class_function("DrawInfos", &btSoftBodyHelpers::DrawInfos)
	.class_function("DrawNodeTree", &btSoftBodyHelpers::DrawNodeTree)
	.class_function("DrawNodeTree", &btSoftBodyHelpers::DrawNodeTree)
	.class_function("DrawNodeTree", &btSoftBodyHelpers::DrawNodeTree)
	.class_function("DrawFaceTree", &btSoftBodyHelpers::DrawFaceTree)
	.class_function("DrawFaceTree", &btSoftBodyHelpers::DrawFaceTree)
	.class_function("DrawFaceTree", &btSoftBodyHelpers::DrawFaceTree)
	.class_function("DrawClusterTree", &btSoftBodyHelpers::DrawClusterTree)
	.class_function("DrawClusterTree", &btSoftBodyHelpers::DrawClusterTree)
	.class_function("DrawClusterTree", &btSoftBodyHelpers::DrawClusterTree)
	.class_function("DrawFrame", &btSoftBodyHelpers::DrawFrame)
	.class_function("CreateRope", &btSoftBodyHelpers::CreateRope)
	.class_function("CreatePatch", &btSoftBodyHelpers::CreatePatch)
	.class_function("CreatePatchUV", &btSoftBodyHelpers::CreatePatchUV)
	.class_function("CreatePatchUV", &btSoftBodyHelpers::CreatePatchUV)
	.class_function("CalculateUV", &btSoftBodyHelpers::CalculateUV)
	.class_function("CreateEllipsoid", &btSoftBodyHelpers::CreateEllipsoid)
	.class_function("CreateFromTriMesh", &btSoftBodyHelpers::CreateFromTriMesh)
	.class_function("CreateFromTriMesh", &btSoftBodyHelpers::CreateFromTriMesh)
	.class_function("CreateFromConvexHull", &btSoftBodyHelpers::CreateFromConvexHull)
	.class_function("CreateFromConvexHull", &btSoftBodyHelpers::CreateFromConvexHull)
	.class_function("CreateFromTetGenData", &btSoftBodyHelpers::CreateFromTetGenData)
	.class_function("ReoptimizeLinkOrder", &btSoftBodyHelpers::ReoptimizeLinkOrder)
	.constructor<btScalar,unsigned int>()
	.constructor<btScalar>()
	.function("decompose", &btPolarDecomposition::decompose)
	.function("maxIterations", &btPolarDecomposition::maxIterations)
	.constructor<p.btSoftBody>()
	.constructor<p.q(const).btSoftBody::Cluster>()
	.function("getShapeType", &btSoftClusterCollisionShape::getShapeType)
	.class_function("Lerp", &btSoftClusterCollisionShape::Lerp)
	.class_function("Clamp", &btSoftClusterCollisionShape::Clamp)
	.class_function("ClusterMetric", &btSoftClusterCollisionShape::ClusterMetric)
	.class_function("ScaleAlongAxis", &btSoftClusterCollisionShape::ScaleAlongAxis)
	.class_function("Cross", &btSoftClusterCollisionShape::Cross)
	.class_function("Diagonal", &btSoftClusterCollisionShape::Diagonal)
	.class_function("Add", &btSoftClusterCollisionShape::Add)
	.class_function("Sub", &btSoftClusterCollisionShape::Sub)
	.class_function("Mul", &btSoftClusterCollisionShape::Mul)
	.class_function("Orthogonalize", &btSoftClusterCollisionShape::Orthogonalize)
	.class_function("MassMatrix", &btSoftClusterCollisionShape::MassMatrix)
	.class_function("ImpulseMatrix", &btSoftClusterCollisionShape::ImpulseMatrix)
	.class_function("ImpulseMatrix", &btSoftClusterCollisionShape::ImpulseMatrix)
	.class_function("AngularImpulseMatrix", &btSoftClusterCollisionShape::AngularImpulseMatrix)
	.class_function("ProjectOnAxis", &btSoftClusterCollisionShape::ProjectOnAxis)
	.class_function("ProjectOnPlane", &btSoftClusterCollisionShape::ProjectOnPlane)
	.class_function("ProjectOrigin", &btSoftClusterCollisionShape::ProjectOrigin)
	.class_function("ProjectOrigin", &btSoftClusterCollisionShape::ProjectOrigin)
	.class_function("BaryCoord", &btSoftClusterCollisionShape::BaryCoord)
	.class_function("ImplicitSolve", &btSoftClusterCollisionShape::ImplicitSolve)
	.class_function("ImplicitSolve", &btSoftClusterCollisionShape::ImplicitSolve)
	.class_function("EvaluateMedium", &btSoftClusterCollisionShape::EvaluateMedium)
	.class_function("NormalizeAny", &btSoftClusterCollisionShape::NormalizeAny)
	.class_function("VolumeOf", &btSoftClusterCollisionShape::VolumeOf)
	.class_function("CenterOf", &btSoftClusterCollisionShape::CenterOf)
	.class_function("AreaOf", &btSoftClusterCollisionShape::AreaOf)
	.class_function("VolumeOf", &btSoftClusterCollisionShape::VolumeOf)
	.class_function("ApplyClampedForce", &btSoftClusterCollisionShape::ApplyClampedForce)
	.class_function("MatchEdge", &btSoftClusterCollisionShape::MatchEdge)
	.class_function("system", &btEigen::system)
	.class_function("system", &btEigen::system)
	.class_function("mulTPQ", &btEigen::mulTPQ)
	.class_function("mulPQ", &btEigen::mulPQ)
	.class_function("PolarDecompose", &btEigen::PolarDecompose)
	.constructor<r.q(const).btDefaultCollisionConstructionInfo>()
	.constructor<p.btPersistentManifold,r.q(const).btCollisionAlgorithmConstructionInfo,p.q(const).btCollisionObjectWrapper,p.q(const).btCollisionObjectWrapper,bool>()
	.constructor<r.q(const).btCollisionAlgorithmConstructionInfo>()
	.constructor<p.btPersistentManifold,r.q(const).btCollisionAlgorithmConstructionInfo,p.q(const).btCollisionObjectWrapper,p.q(const).btCollisionObjectWrapper>()
	enum_<HullFlag>("HullFlag")
		;
	.constructor<HullFlag,unsigned int,p.q(const).btVector3,unsigned int>()
	.constructor<HullFlag,unsigned int,p.q(const).btVector3>()
	.function("HasHullFlag", &HullDesc::HasHullFlag)
	.function("SetHullFlag", &HullDesc::SetHullFlag)
	.function("ClearHullFlag", &HullDesc::ClearHullFlag)
	enum_<HullError>("HullError")
		;
	.constructor<r.q(const).btVector3,btScalar>()
	.constructor<int,int,int>()
	.constructor<int,int,int,int>()
	.function("operator []_int", select_overload<q(const).int(int)const>(&int4::operator []))
	.function("operator []_int", select_overload<int(int)>(&int4::operator []))
	.function("CreateConvexHull", &HullLibrary::CreateConvexHull)
	.function("ReleaseResult", &HullLibrary::ReleaseResult)
	.function("ComputeHull", &HullLibrary::ComputeHull)
	.function("allocateTriangle", &HullLibrary::allocateTriangle)
	.function("deAllocateTriangle", &HullLibrary::deAllocateTriangle)
	.function("b2bfix", &HullLibrary::b2bfix)
	.function("removeb2b", &HullLibrary::removeb2b)
	.function("checkit", &HullLibrary::checkit)
	.function("extrudable", &HullLibrary::extrudable)
	.function("calchull", &HullLibrary::calchull)
	.function("calchullgen", &HullLibrary::calchullgen)
	.function("FindSimplex", &HullLibrary::FindSimplex)
	.function("ConvexHCrop", &HullLibrary::ConvexHCrop)
	.function("extrude", &HullLibrary::extrude)
	.function("test_cube", &HullLibrary::test_cube)
	.function("BringOutYourDead", &HullLibrary::BringOutYourDead)
	.function("CleanupVertices", &HullLibrary::CleanupVertices)
	.function("compute", &btConvexHullComputer::compute)
	.function("compute_p.q(const).float_int_int_btScalar_btScalar", select_overload<btScalar(p.q(const).float, int, int, btScalar, btScalar)>(&btConvexHullComputer::compute))
	.function("compute_p.q(const).double_int_int_btScalar_btScalar", select_overload<btScalar(p.q(const).double, int, int, btScalar, btScalar)>(&btConvexHullComputer::compute))
	.constructor<r.q(const).btTransform,r.q(const).btTransform>()
	.constructor<r.q(const).btTransform>()
	.class_function("getPlaneEquationsFromVertices", &btGeometryUtil::getPlaneEquationsFromVertices)
	.class_function("getVerticesFromPlaneEquations", &btGeometryUtil::getVerticesFromPlaneEquations)
	.class_function("isPointInsidePlanes", &btGeometryUtil::isPointInsidePlanes)
	.class_function("areVerticesBehindPlane", &btGeometryUtil::areVerticesBehindPlane)
	.constructor<p.btGEN_Link,p.btGEN_Link>()
	.function("getNext", &btGEN_Link::getNext)
	.function("getPrev", &btGEN_Link::getPrev)
	.function("isHead", &btGEN_Link::isHead)
	.function("isTail", &btGEN_Link::isTail)
	.function("insertBefore", &btGEN_Link::insertBefore)
	.function("insertAfter", &btGEN_Link::insertAfter)
	.function("remove", &btGEN_Link::remove)
	.function("getHead", &btGEN_List::getHead)
	.function("getTail", &btGEN_List::getTail)
	.function("addHead", &btGEN_List::addHead)
	.function("addTail", &btGEN_List::addTail)
	.constructor<int,int>()
	.function("getFreeCount", &btPoolAllocator::getFreeCount)
	.function("getUsedCount", &btPoolAllocator::getUsedCount)
	.function("getMaxCount", &btPoolAllocator::getMaxCount)
	.function("allocate", &btPoolAllocator::allocate)
	.function("validPtr", &btPoolAllocator::validPtr)
	.function("freeMemory", &btPoolAllocator::freeMemory)
	.function("getElementSize", &btPoolAllocator::getElementSize)
	.function("getPoolAddress", select_overload<unsigned char()>(&btPoolAllocator::getPoolAddress))
	.function("getPoolAddress", select_overload<q(const).unsigned char()const>(&btPoolAllocator::getPoolAddress))
	.constructor<unsigned int>()
	.function("create", &btStackAlloc::create)
	.function("destroy", &btStackAlloc::destroy)
	.function("getAvailableMemory", &btStackAlloc::getAvailableMemory)
	.function("allocate", &btStackAlloc::allocate)
	.function("beginBlock", &btStackAlloc::beginBlock)
	.function("endBlock", &btStackAlloc::endBlock)
	.function("ctor", &btStackAlloc::ctor)
	class_<rgb>("rgb")
//variableHandler - r
//variableHandler - g
//variableHandler - b
	;
	class_<hsv>("hsv")
//variableHandler - h
//variableHandler - s
//variableHandler - v
	;
	function("rgb2hsv", &rgb2hsv);
	function("hsv2rgb", &hsv2rgb);
	function("initGL", &initGL);
	function("renderGL", &renderGL);
	function("printGLInfo", &printGLInfo);
	function("setGLBackgroundColor", &setGLBackgroundColor);
	function("setGLViewSize", &setGLViewSize);
//variableHandler - Action
//variableHandler - ActionBuilder
//variableHandler - Camera
//variableHandler - CameraBuilder
//variableHandler - Clock
//variableHandler - ClockBuilder
//variableHandler - CollisionResponse
//variableHandler - CollisionResponseBuilder
//variableHandler - CubeBuilder
//variableHandler - Font
//variableHandler - FontBuilder
//variableHandler - GameClock
//variableHandler - Geometry
//variableHandler - Image
//variableHandler - ImageBuilder
//variableHandler - JLIFactoryTypes
//variableHandler - JsonJLI
//variableHandler - JsonJLIBuilder
//variableHandler - LevelOfDetail
//variableHandler - LevelOfDetailBuilder
//variableHandler - Light
//variableHandler - LightBuilder
//variableHandler - Material
//variableHandler - MaterialBuilder
//variableHandler - MaterialProperty
//variableHandler - MaterialPropertyBuilder
//variableHandler - Node
//variableHandler - NodeBuilder
//variableHandler - NodeState
//variableHandler - NodeStateBuilder
//variableHandler - NodeStateMachine
//variableHandler - NodeStateMachineBuilder
//variableHandler - ParticleEmitter
//variableHandler - ParticleEmitterBuilder
//variableHandler - PhysicsBody
//variableHandler - PhysicsBodyGhost
//variableHandler - PhysicsBodyGhostBuilder
//variableHandler - PhysicsBodyRigid
//variableHandler - PhysicsBodyRigidBuilder
//variableHandler - PhysicsBodySoft
//variableHandler - PhysicsBodySoftBuilder
//variableHandler - PhysicsCloseContact
//variableHandler - PhysicsCloseContactBuilder
//variableHandler - PhysicsConstraint
//variableHandler - PhysicsConstraintBuilder
//variableHandler - PhysicsConstraintConeTwist
//variableHandler - PhysicsConstraintConeTwistBuilder
//variableHandler - PhysicsConstraintFixed
//variableHandler - PhysicsConstraintFixedBuilder
//variableHandler - PhysicsConstraintGeneric6Dof
//variableHandler - PhysicsConstraintGeneric6DofBuilder
//variableHandler - PhysicsConstraintGeneric6DofSpring
//variableHandler - PhysicsConstraintGeneric6DofSpringBuilder
//variableHandler - PhysicsConstraintHinge
//variableHandler - PhysicsConstraintHingeBuilder
//variableHandler - PhysicsConstraintPointToPoint
//variableHandler - PhysicsConstraintPointToPointBuilder
//variableHandler - PhysicsConstraintSlider
//variableHandler - PhysicsConstraintSliderBuilder
//variableHandler - PhysicsContact
//variableHandler - PhysicsContactBuilder
//variableHandler - PhysicsField
//variableHandler - PhysicsFieldBuilder
//variableHandler - PhysicsRayContact
//variableHandler - PhysicsRayContactBuilder
//variableHandler - PhysicsShape
//variableHandler - PhysicsShapeBox
//variableHandler - PhysicsShapeBox2D
//variableHandler - PhysicsShapeBox2DBuilder
//variableHandler - PhysicsShapeBoxBuilder
//variableHandler - PhysicsShapeBvhTriangleMesh
//variableHandler - PhysicsShapeBvhTriangleMeshBuilder
//variableHandler - PhysicsShapeCapsule
//variableHandler - PhysicsShapeCapsuleBuilder
//variableHandler - PhysicsShapeCone
//variableHandler - PhysicsShapeConeBuilder
//variableHandler - PhysicsShapeConvexHull
//variableHandler - PhysicsShapeConvexHullBuilder
//variableHandler - PhysicsShapeConvexTriangleMesh
//variableHandler - PhysicsShapeConvexTriangleMeshBuilder
//variableHandler - PhysicsShapeCylinder
//variableHandler - PhysicsShapeCylinderBuilder
//variableHandler - PhysicsShapeHeightfieldTerrain
//variableHandler - PhysicsShapeHeightfieldTerrainBuilder
//variableHandler - PhysicsShapeMultiSphere
//variableHandler - PhysicsShapeMultiSphereBuilder
//variableHandler - PhysicsShapeSphere
//variableHandler - PhysicsShapeSphereBuilder
//variableHandler - PhysicsShapeStaticPlane
//variableHandler - PhysicsShapeStaticPlaneBuilder
//variableHandler - PhysicsWorld
//variableHandler - PhysicsWorldBuilder
//variableHandler - Plane
//variableHandler - PlaneBuilder
//variableHandler - Scene
//variableHandler - SceneBuilder
//variableHandler - SceneState
//variableHandler - SceneStateBuilder
//variableHandler - SceneStateMachine
//variableHandler - SceneStateMachineBuilder
//variableHandler - ShaderProgram
//variableHandler - ShaderProgramBuilder
//variableHandler - Skinner
//variableHandler - SkinnerBuilder
//variableHandler - SoundBuilder
//variableHandler - Sprite2D
//variableHandler - Sprite2DBuilder
//variableHandler - SpriteFrameAtlas
//variableHandler - SpriteFrameAtlasBuilder
//variableHandler - SteeringBehavior
//variableHandler - SteeringBehaviorBuilder
//variableHandler - SteeringBehaviorAlignment
//variableHandler - SteeringBehaviorAlignmentBuilder
//variableHandler - SteeringBehaviorArrive
//variableHandler - SteeringBehaviorArriveBuilder
//variableHandler - SteeringBehaviorCohesion
//variableHandler - SteeringBehaviorCohesionBuilder
//variableHandler - SteeringBehaviorEvade
//variableHandler - SteeringBehaviorEvadeBuilder
//variableHandler - SteeringBehaviorFlee
//variableHandler - SteeringBehaviorFleeBuilder
//variableHandler - SteeringBehaviorFollowPath
//variableHandler - SteeringBehaviorFollowPathBuilder
//variableHandler - SteeringBehaviorHide
//variableHandler - SteeringBehaviorHideBuilder
//variableHandler - SteeringBehaviorInterpose
//variableHandler - SteeringBehaviorInterposeBuilder
//variableHandler - SteeringBehaviorMachine
//variableHandler - SteeringBehaviorMachineBuilder
//variableHandler - SteeringBehaviorMachineDithered
//variableHandler - SteeringBehaviorMachineDitheredBuilder
//variableHandler - SteeringBehaviorMachinePrioritized
//variableHandler - SteeringBehaviorMachinePrioritizedBuilder
//variableHandler - SteeringBehaviorMachineWeighted
//variableHandler - SteeringBehaviorMachineWeightedBuilder
//variableHandler - SteeringBehaviorObstacleAvoidance
//variableHandler - SteeringBehaviorObstacleAvoidanceBuilder
//variableHandler - SteeringBehaviorOffsetPursuit
//variableHandler - SteeringBehaviorOffsetPursuitBuilder
//variableHandler - SteeringBehaviorPursuit
//variableHandler - SteeringBehaviorPursuitBuilder
//variableHandler - SteeringBehaviorSeek
//variableHandler - SteeringBehaviorSeekBuilder
//variableHandler - SteeringBehaviorSeparation
//variableHandler - SteeringBehaviorSeparationBuilder
//variableHandler - SteeringBehaviorWallAvoidance
//variableHandler - SteeringBehaviorWallAvoidanceBuilder
//variableHandler - SteeringBehaviorWander
//variableHandler - SteeringBehaviorWanderBuilder
//variableHandler - StopWatch
//variableHandler - StopWatchBuilder
//variableHandler - Thread
//variableHandler - ThreadBuilder
//variableHandler - Timer
//variableHandler - TimerBuilder
//variableHandler - World
//variableHandler - WorldClock
//variableHandler - WorldDebugDrawer
//variableHandler - WorldFactory
//variableHandler - ButtonHUD
//variableHandler - ButtonHUDBuilder
//variableHandler - CheckboxHUD
//variableHandler - CheckboxHUDBuilder
//variableHandler - DropdownHUD
//variableHandler - DropdownHUDBuilder
//variableHandler - LabelHUD
//variableHandler - LabelHUDBuilder
//variableHandler - SliderHUD
//variableHandler - SliderHUDBuilder
//variableHandler - TextboxHUD
//variableHandler - TextboxHUDBuilder
//variableHandler - WorldHUD
//variableHandler - WorldLuaVirtualMachine
//variableHandler - WorldResourceLoader
//variableHandler - WorldSQLite
//variableHandler - WorldSocket
//variableHandler - WorldState
//variableHandler - WorldStateBuilder
//variableHandler - WorldStateMachine
//variableHandler - WorldStateMachineBuilder
//variableHandler - Xml
//variableHandler - XmlBuilder
//variableHandler - DeviceInputTime
//variableHandler - DeviceTouch
//variableHandler - Sound
//variableHandler - WorldFacebook
//variableHandler - WorldInput
//variableHandler - WorldPythonVirtualMachine
//variableHandler - WorldSound
	class_<btAlignedObjectArray<(njli::JLIGlyphPosition)>>("btAlignedObjectArray<(njli::JLIGlyphPosition)>")
	.function("operator =", &btAlignedObjectArray<(njli::JLIGlyphPosition)>::operator =)
	.function("allocSize", &btAlignedObjectArray<(njli::JLIGlyphPosition)>::allocSize)
	.function("copy", &btAlignedObjectArray<(njli::JLIGlyphPosition)>::copy)
	.function("init", &btAlignedObjectArray<(njli::JLIGlyphPosition)>::init)
	.function("destroy", &btAlignedObjectArray<(njli::JLIGlyphPosition)>::destroy)
	.function("allocate", &btAlignedObjectArray<(njli::JLIGlyphPosition)>::allocate)
	.function("deallocate", &btAlignedObjectArray<(njli::JLIGlyphPosition)>::deallocate)
	.constructor<r.q(const).btAlignedObjectArray<(njli::JLIGlyphPosition)>>()
	.function("size", &btAlignedObjectArray<(njli::JLIGlyphPosition)>::size)
	.function("at_int", select_overload<q(const).njli::JLIGlyphPosition(int)const>(&btAlignedObjectArray<(njli::JLIGlyphPosition)>::at))
	.function("at_int", select_overload<njli::JLIGlyphPosition(int)>(&btAlignedObjectArray<(njli::JLIGlyphPosition)>::at))
	.function("operator []_int", select_overload<q(const).njli::JLIGlyphPosition(int)const>(&btAlignedObjectArray<(njli::JLIGlyphPosition)>::operator []))
	.function("operator []_int", select_overload<njli::JLIGlyphPosition(int)>(&btAlignedObjectArray<(njli::JLIGlyphPosition)>::operator []))
	.function("clear", &btAlignedObjectArray<(njli::JLIGlyphPosition)>::clear)
	.function("pop_back", &btAlignedObjectArray<(njli::JLIGlyphPosition)>::pop_back)
	.function("resizeNoInitialize", &btAlignedObjectArray<(njli::JLIGlyphPosition)>::resizeNoInitialize)
	.function("resize_int_r.q(const).njli::JLIGlyphPosition", select_overload<void(int, r.q(const).njli::JLIGlyphPosition)>(&btAlignedObjectArray<(njli::JLIGlyphPosition)>::resize))
	.function("resize_int", select_overload<void(int)>(&btAlignedObjectArray<(njli::JLIGlyphPosition)>::resize))
	.function("expandNonInitializing", &btAlignedObjectArray<(njli::JLIGlyphPosition)>::expandNonInitializing)
	.function("expand_r.q(const).njli::JLIGlyphPosition", select_overload<njli::JLIGlyphPosition(r.q(const).njli::JLIGlyphPosition)>(&btAlignedObjectArray<(njli::JLIGlyphPosition)>::expand))
	.function("expand", select_overload<njli::JLIGlyphPosition()>(&btAlignedObjectArray<(njli::JLIGlyphPosition)>::expand))
	.function("push_back", &btAlignedObjectArray<(njli::JLIGlyphPosition)>::push_back)
	.function("capacity", &btAlignedObjectArray<(njli::JLIGlyphPosition)>::capacity)
	.function("reserve", &btAlignedObjectArray<(njli::JLIGlyphPosition)>::reserve)
	.function("swap", &btAlignedObjectArray<(njli::JLIGlyphPosition)>::swap)
	.function("findBinarySearch", &btAlignedObjectArray<(njli::JLIGlyphPosition)>::findBinarySearch)
	.function("findLinearSearch", &btAlignedObjectArray<(njli::JLIGlyphPosition)>::findLinearSearch)
	.function("removeAtIndex", &btAlignedObjectArray<(njli::JLIGlyphPosition)>::removeAtIndex)
	.function("remove", &btAlignedObjectArray<(njli::JLIGlyphPosition)>::remove)
	.function("initializeFromBuffer", &btAlignedObjectArray<(njli::JLIGlyphPosition)>::initializeFromBuffer)
	.function("copyFromArray", &btAlignedObjectArray<(njli::JLIGlyphPosition)>::copyFromArray)
	;
	class_<btAlignedObjectArray<(njli::JLITextRow)>>("btAlignedObjectArray<(njli::JLITextRow)>")
	.function("operator =", &btAlignedObjectArray<(njli::JLITextRow)>::operator =)
	.function("allocSize", &btAlignedObjectArray<(njli::JLITextRow)>::allocSize)
	.function("copy", &btAlignedObjectArray<(njli::JLITextRow)>::copy)
	.function("init", &btAlignedObjectArray<(njli::JLITextRow)>::init)
	.function("destroy", &btAlignedObjectArray<(njli::JLITextRow)>::destroy)
	.function("allocate", &btAlignedObjectArray<(njli::JLITextRow)>::allocate)
	.function("deallocate", &btAlignedObjectArray<(njli::JLITextRow)>::deallocate)
	.constructor<r.q(const).btAlignedObjectArray<(njli::JLITextRow)>>()
	.function("size", &btAlignedObjectArray<(njli::JLITextRow)>::size)
	.function("at_int", select_overload<q(const).njli::JLITextRow(int)const>(&btAlignedObjectArray<(njli::JLITextRow)>::at))
	.function("at_int", select_overload<njli::JLITextRow(int)>(&btAlignedObjectArray<(njli::JLITextRow)>::at))
	.function("operator []_int", select_overload<q(const).njli::JLITextRow(int)const>(&btAlignedObjectArray<(njli::JLITextRow)>::operator []))
	.function("operator []_int", select_overload<njli::JLITextRow(int)>(&btAlignedObjectArray<(njli::JLITextRow)>::operator []))
	.function("clear", &btAlignedObjectArray<(njli::JLITextRow)>::clear)
	.function("pop_back", &btAlignedObjectArray<(njli::JLITextRow)>::pop_back)
	.function("resizeNoInitialize", &btAlignedObjectArray<(njli::JLITextRow)>::resizeNoInitialize)
	.function("resize_int_r.q(const).njli::JLITextRow", select_overload<void(int, r.q(const).njli::JLITextRow)>(&btAlignedObjectArray<(njli::JLITextRow)>::resize))
	.function("resize_int", select_overload<void(int)>(&btAlignedObjectArray<(njli::JLITextRow)>::resize))
	.function("expandNonInitializing", &btAlignedObjectArray<(njli::JLITextRow)>::expandNonInitializing)
	.function("expand_r.q(const).njli::JLITextRow", select_overload<njli::JLITextRow(r.q(const).njli::JLITextRow)>(&btAlignedObjectArray<(njli::JLITextRow)>::expand))
	.function("expand", select_overload<njli::JLITextRow()>(&btAlignedObjectArray<(njli::JLITextRow)>::expand))
	.function("push_back", &btAlignedObjectArray<(njli::JLITextRow)>::push_back)
	.function("capacity", &btAlignedObjectArray<(njli::JLITextRow)>::capacity)
	.function("reserve", &btAlignedObjectArray<(njli::JLITextRow)>::reserve)
	.function("swap", &btAlignedObjectArray<(njli::JLITextRow)>::swap)
	.function("findBinarySearch", &btAlignedObjectArray<(njli::JLITextRow)>::findBinarySearch)
	.function("findLinearSearch", &btAlignedObjectArray<(njli::JLITextRow)>::findLinearSearch)
	.function("removeAtIndex", &btAlignedObjectArray<(njli::JLITextRow)>::removeAtIndex)
	.function("remove", &btAlignedObjectArray<(njli::JLITextRow)>::remove)
	.function("initializeFromBuffer", &btAlignedObjectArray<(njli::JLITextRow)>::initializeFromBuffer)
	.function("copyFromArray", &btAlignedObjectArray<(njli::JLITextRow)>::copyFromArray)
	;
	function("new_SoundArray", &new_SoundArray, allow_raw_pointers());
	function("delete_SoundArray", &delete_SoundArray);
	function("SoundArray_getitem", &SoundArray_getitem, allow_raw_pointers());
	function("SoundArray_setitem", &SoundArray_setitem);
	function("new_ActionArray", &new_ActionArray, allow_raw_pointers());
	function("delete_ActionArray", &delete_ActionArray);
	function("ActionArray_getitem", &ActionArray_getitem, allow_raw_pointers());
	function("ActionArray_setitem", &ActionArray_setitem);
	function("new_ActionBuilderArray", &new_ActionBuilderArray, allow_raw_pointers());
	function("delete_ActionBuilderArray", &delete_ActionBuilderArray);
	function("ActionBuilderArray_getitem", &ActionBuilderArray_getitem, allow_raw_pointers());
	function("ActionBuilderArray_setitem", &ActionBuilderArray_setitem);
	function("new_CameraArray", &new_CameraArray, allow_raw_pointers());
	function("delete_CameraArray", &delete_CameraArray);
	function("CameraArray_getitem", &CameraArray_getitem, allow_raw_pointers());
	function("CameraArray_setitem", &CameraArray_setitem);
	function("new_CameraBuilderArray", &new_CameraBuilderArray, allow_raw_pointers());
	function("delete_CameraBuilderArray", &delete_CameraBuilderArray);
	function("CameraBuilderArray_getitem", &CameraBuilderArray_getitem, allow_raw_pointers());
	function("CameraBuilderArray_setitem", &CameraBuilderArray_setitem);
	function("new_ClockArray", &new_ClockArray, allow_raw_pointers());
	function("delete_ClockArray", &delete_ClockArray);
	function("ClockArray_getitem", &ClockArray_getitem, allow_raw_pointers());
	function("ClockArray_setitem", &ClockArray_setitem);
	function("new_ClockBuilderArray", &new_ClockBuilderArray, allow_raw_pointers());
	function("delete_ClockBuilderArray", &delete_ClockBuilderArray);
	function("ClockBuilderArray_getitem", &ClockBuilderArray_getitem, allow_raw_pointers());
	function("ClockBuilderArray_setitem", &ClockBuilderArray_setitem);
	function("new_CollisionResponseArray", &new_CollisionResponseArray, allow_raw_pointers());
	function("delete_CollisionResponseArray", &delete_CollisionResponseArray);
	function("CollisionResponseArray_getitem", &CollisionResponseArray_getitem, allow_raw_pointers());
	function("CollisionResponseArray_setitem", &CollisionResponseArray_setitem);
	function("new_CollisionResponseBuilderArray", &new_CollisionResponseBuilderArray, allow_raw_pointers());
	function("delete_CollisionResponseBuilderArray", &delete_CollisionResponseBuilderArray);
	function("CollisionResponseBuilderArray_getitem", &CollisionResponseBuilderArray_getitem, allow_raw_pointers());
	function("CollisionResponseBuilderArray_setitem", &CollisionResponseBuilderArray_setitem);
	function("new_CubeArray", &new_CubeArray, allow_raw_pointers());
	function("delete_CubeArray", &delete_CubeArray);
	function("CubeArray_getitem", &CubeArray_getitem, allow_raw_pointers());
	function("CubeArray_setitem", &CubeArray_setitem);
	function("new_CubeBuilderArray", &new_CubeBuilderArray, allow_raw_pointers());
	function("delete_CubeBuilderArray", &delete_CubeBuilderArray);
	function("CubeBuilderArray_getitem", &CubeBuilderArray_getitem, allow_raw_pointers());
	function("CubeBuilderArray_setitem", &CubeBuilderArray_setitem);
	function("new_FontArray", &new_FontArray, allow_raw_pointers());
	function("delete_FontArray", &delete_FontArray);
	function("FontArray_getitem", &FontArray_getitem, allow_raw_pointers());
	function("FontArray_setitem", &FontArray_setitem);
	function("new_FontBuilderArray", &new_FontBuilderArray, allow_raw_pointers());
	function("delete_FontBuilderArray", &delete_FontBuilderArray);
	function("FontBuilderArray_getitem", &FontBuilderArray_getitem, allow_raw_pointers());
	function("FontBuilderArray_setitem", &FontBuilderArray_setitem);
	function("new_ImageArray", &new_ImageArray, allow_raw_pointers());
	function("delete_ImageArray", &delete_ImageArray);
	function("ImageArray_getitem", &ImageArray_getitem, allow_raw_pointers());
	function("ImageArray_setitem", &ImageArray_setitem);
	function("new_ImageBuilderArray", &new_ImageBuilderArray, allow_raw_pointers());
	function("delete_ImageBuilderArray", &delete_ImageBuilderArray);
	function("ImageBuilderArray_getitem", &ImageBuilderArray_getitem, allow_raw_pointers());
	function("ImageBuilderArray_setitem", &ImageBuilderArray_setitem);
	function("new_JsonJLIArray", &new_JsonJLIArray, allow_raw_pointers());
	function("delete_JsonJLIArray", &delete_JsonJLIArray);
	function("JsonJLIArray_getitem", &JsonJLIArray_getitem, allow_raw_pointers());
	function("JsonJLIArray_setitem", &JsonJLIArray_setitem);
	function("new_JsonJLIBuilderArray", &new_JsonJLIBuilderArray, allow_raw_pointers());
	function("delete_JsonJLIBuilderArray", &delete_JsonJLIBuilderArray);
	function("JsonJLIBuilderArray_getitem", &JsonJLIBuilderArray_getitem, allow_raw_pointers());
	function("JsonJLIBuilderArray_setitem", &JsonJLIBuilderArray_setitem);
	function("new_LevelOfDetailArray", &new_LevelOfDetailArray, allow_raw_pointers());
	function("delete_LevelOfDetailArray", &delete_LevelOfDetailArray);
	function("LevelOfDetailArray_getitem", &LevelOfDetailArray_getitem, allow_raw_pointers());
	function("LevelOfDetailArray_setitem", &LevelOfDetailArray_setitem);
	function("new_LevelOfDetailBuilderArray", &new_LevelOfDetailBuilderArray, allow_raw_pointers());
	function("delete_LevelOfDetailBuilderArray", &delete_LevelOfDetailBuilderArray);
	function("LevelOfDetailBuilderArray_getitem", &LevelOfDetailBuilderArray_getitem, allow_raw_pointers());
	function("LevelOfDetailBuilderArray_setitem", &LevelOfDetailBuilderArray_setitem);
	function("new_LightArray", &new_LightArray, allow_raw_pointers());
	function("delete_LightArray", &delete_LightArray);
	function("LightArray_getitem", &LightArray_getitem, allow_raw_pointers());
	function("LightArray_setitem", &LightArray_setitem);
	function("new_LightBuilderArray", &new_LightBuilderArray, allow_raw_pointers());
	function("delete_LightBuilderArray", &delete_LightBuilderArray);
	function("LightBuilderArray_getitem", &LightBuilderArray_getitem, allow_raw_pointers());
	function("LightBuilderArray_setitem", &LightBuilderArray_setitem);
	function("new_MaterialArray", &new_MaterialArray, allow_raw_pointers());
	function("delete_MaterialArray", &delete_MaterialArray);
	function("MaterialArray_getitem", &MaterialArray_getitem, allow_raw_pointers());
	function("MaterialArray_setitem", &MaterialArray_setitem);
	function("new_MaterialBuilderArray", &new_MaterialBuilderArray, allow_raw_pointers());
	function("delete_MaterialBuilderArray", &delete_MaterialBuilderArray);
	function("MaterialBuilderArray_getitem", &MaterialBuilderArray_getitem, allow_raw_pointers());
	function("MaterialBuilderArray_setitem", &MaterialBuilderArray_setitem);
	function("new_MaterialPropertyArray", &new_MaterialPropertyArray, allow_raw_pointers());
	function("delete_MaterialPropertyArray", &delete_MaterialPropertyArray);
	function("MaterialPropertyArray_getitem", &MaterialPropertyArray_getitem, allow_raw_pointers());
	function("MaterialPropertyArray_setitem", &MaterialPropertyArray_setitem);
	function("new_MaterialPropertyBuilderArray", &new_MaterialPropertyBuilderArray, allow_raw_pointers());
	function("delete_MaterialPropertyBuilderArray", &delete_MaterialPropertyBuilderArray);
	function("MaterialPropertyBuilderArray_getitem", &MaterialPropertyBuilderArray_getitem, allow_raw_pointers());
	function("MaterialPropertyBuilderArray_setitem", &MaterialPropertyBuilderArray_setitem);
	function("new_NodeArray", &new_NodeArray, allow_raw_pointers());
	function("delete_NodeArray", &delete_NodeArray);
	function("NodeArray_getitem", &NodeArray_getitem, allow_raw_pointers());
	function("NodeArray_setitem", &NodeArray_setitem);
	function("new_NodeBuilderArray", &new_NodeBuilderArray, allow_raw_pointers());
	function("delete_NodeBuilderArray", &delete_NodeBuilderArray);
	function("NodeBuilderArray_getitem", &NodeBuilderArray_getitem, allow_raw_pointers());
	function("NodeBuilderArray_setitem", &NodeBuilderArray_setitem);
	function("new_NodeStateArray", &new_NodeStateArray, allow_raw_pointers());
	function("delete_NodeStateArray", &delete_NodeStateArray);
	function("NodeStateArray_getitem", &NodeStateArray_getitem, allow_raw_pointers());
	function("NodeStateArray_setitem", &NodeStateArray_setitem);
	function("new_NodeStateBuilderArray", &new_NodeStateBuilderArray, allow_raw_pointers());
	function("delete_NodeStateBuilderArray", &delete_NodeStateBuilderArray);
	function("NodeStateBuilderArray_getitem", &NodeStateBuilderArray_getitem, allow_raw_pointers());
	function("NodeStateBuilderArray_setitem", &NodeStateBuilderArray_setitem);
	function("new_NodeStateMachineArray", &new_NodeStateMachineArray, allow_raw_pointers());
	function("delete_NodeStateMachineArray", &delete_NodeStateMachineArray);
	function("NodeStateMachineArray_getitem", &NodeStateMachineArray_getitem, allow_raw_pointers());
	function("NodeStateMachineArray_setitem", &NodeStateMachineArray_setitem);
	function("new_NodeStateMachineBuilderArray", &new_NodeStateMachineBuilderArray, allow_raw_pointers());
	function("delete_NodeStateMachineBuilderArray", &delete_NodeStateMachineBuilderArray);
	function("NodeStateMachineBuilderArray_getitem", &NodeStateMachineBuilderArray_getitem, allow_raw_pointers());
	function("NodeStateMachineBuilderArray_setitem", &NodeStateMachineBuilderArray_setitem);
	function("new_ParticleEmitterArray", &new_ParticleEmitterArray, allow_raw_pointers());
	function("delete_ParticleEmitterArray", &delete_ParticleEmitterArray);
	function("ParticleEmitterArray_getitem", &ParticleEmitterArray_getitem, allow_raw_pointers());
	function("ParticleEmitterArray_setitem", &ParticleEmitterArray_setitem);
	function("new_ParticleEmitterBuilderArray", &new_ParticleEmitterBuilderArray, allow_raw_pointers());
	function("delete_ParticleEmitterBuilderArray", &delete_ParticleEmitterBuilderArray);
	function("ParticleEmitterBuilderArray_getitem", &ParticleEmitterBuilderArray_getitem, allow_raw_pointers());
	function("ParticleEmitterBuilderArray_setitem", &ParticleEmitterBuilderArray_setitem);
	function("new_PhysicsBodyGhostArray", &new_PhysicsBodyGhostArray, allow_raw_pointers());
	function("delete_PhysicsBodyGhostArray", &delete_PhysicsBodyGhostArray);
	function("PhysicsBodyGhostArray_getitem", &PhysicsBodyGhostArray_getitem, allow_raw_pointers());
	function("PhysicsBodyGhostArray_setitem", &PhysicsBodyGhostArray_setitem);
	function("new_PhysicsBodyGhostBuilderArray", &new_PhysicsBodyGhostBuilderArray, allow_raw_pointers());
	function("delete_PhysicsBodyGhostBuilderArray", &delete_PhysicsBodyGhostBuilderArray);
	function("PhysicsBodyGhostBuilderArray_getitem", &PhysicsBodyGhostBuilderArray_getitem, allow_raw_pointers());
	function("PhysicsBodyGhostBuilderArray_setitem", &PhysicsBodyGhostBuilderArray_setitem);
	function("new_PhysicsBodyRigidArray", &new_PhysicsBodyRigidArray, allow_raw_pointers());
	function("delete_PhysicsBodyRigidArray", &delete_PhysicsBodyRigidArray);
	function("PhysicsBodyRigidArray_getitem", &PhysicsBodyRigidArray_getitem, allow_raw_pointers());
	function("PhysicsBodyRigidArray_setitem", &PhysicsBodyRigidArray_setitem);
	function("new_PhysicsBodyRigidBuilderArray", &new_PhysicsBodyRigidBuilderArray, allow_raw_pointers());
	function("delete_PhysicsBodyRigidBuilderArray", &delete_PhysicsBodyRigidBuilderArray);
	function("PhysicsBodyRigidBuilderArray_getitem", &PhysicsBodyRigidBuilderArray_getitem, allow_raw_pointers());
	function("PhysicsBodyRigidBuilderArray_setitem", &PhysicsBodyRigidBuilderArray_setitem);
	function("new_PhysicsBodySoftArray", &new_PhysicsBodySoftArray, allow_raw_pointers());
	function("delete_PhysicsBodySoftArray", &delete_PhysicsBodySoftArray);
	function("PhysicsBodySoftArray_getitem", &PhysicsBodySoftArray_getitem, allow_raw_pointers());
	function("PhysicsBodySoftArray_setitem", &PhysicsBodySoftArray_setitem);
	function("new_PhysicsBodySoftBuilderArray", &new_PhysicsBodySoftBuilderArray, allow_raw_pointers());
	function("delete_PhysicsBodySoftBuilderArray", &delete_PhysicsBodySoftBuilderArray);
	function("PhysicsBodySoftBuilderArray_getitem", &PhysicsBodySoftBuilderArray_getitem, allow_raw_pointers());
	function("PhysicsBodySoftBuilderArray_setitem", &PhysicsBodySoftBuilderArray_setitem);
	function("new_PhysicsCloseContactArray", &new_PhysicsCloseContactArray, allow_raw_pointers());
	function("delete_PhysicsCloseContactArray", &delete_PhysicsCloseContactArray);
	function("PhysicsCloseContactArray_getitem", &PhysicsCloseContactArray_getitem, allow_raw_pointers());
	function("PhysicsCloseContactArray_setitem", &PhysicsCloseContactArray_setitem);
	function("new_PhysicsCloseContactBuilderArray", &new_PhysicsCloseContactBuilderArray, allow_raw_pointers());
	function("delete_PhysicsCloseContactBuilderArray", &delete_PhysicsCloseContactBuilderArray);
	function("PhysicsCloseContactBuilderArray_getitem", &PhysicsCloseContactBuilderArray_getitem, allow_raw_pointers());
	function("PhysicsCloseContactBuilderArray_setitem", &PhysicsCloseContactBuilderArray_setitem);
	function("new_PhysicsConstraintArray", &new_PhysicsConstraintArray, allow_raw_pointers());
	function("delete_PhysicsConstraintArray", &delete_PhysicsConstraintArray);
	function("PhysicsConstraintArray_getitem", &PhysicsConstraintArray_getitem, allow_raw_pointers());
	function("PhysicsConstraintArray_setitem", &PhysicsConstraintArray_setitem);
	function("new_PhysicsConstraintBuilderArray", &new_PhysicsConstraintBuilderArray, allow_raw_pointers());
	function("delete_PhysicsConstraintBuilderArray", &delete_PhysicsConstraintBuilderArray);
	function("PhysicsConstraintBuilderArray_getitem", &PhysicsConstraintBuilderArray_getitem, allow_raw_pointers());
	function("PhysicsConstraintBuilderArray_setitem", &PhysicsConstraintBuilderArray_setitem);
	function("new_PhysicsConstraintConeTwistArray", &new_PhysicsConstraintConeTwistArray, allow_raw_pointers());
	function("delete_PhysicsConstraintConeTwistArray", &delete_PhysicsConstraintConeTwistArray);
	function("PhysicsConstraintConeTwistArray_getitem", &PhysicsConstraintConeTwistArray_getitem, allow_raw_pointers());
	function("PhysicsConstraintConeTwistArray_setitem", &PhysicsConstraintConeTwistArray_setitem);
	function("new_PhysicsConstraintConeTwistBuilderArray", &new_PhysicsConstraintConeTwistBuilderArray, allow_raw_pointers());
	function("delete_PhysicsConstraintConeTwistBuilderArray", &delete_PhysicsConstraintConeTwistBuilderArray);
	function("PhysicsConstraintConeTwistBuilderArray_getitem", &PhysicsConstraintConeTwistBuilderArray_getitem, allow_raw_pointers());
	function("PhysicsConstraintConeTwistBuilderArray_setitem", &PhysicsConstraintConeTwistBuilderArray_setitem);
	function("new_PhysicsConstraintFixedArray", &new_PhysicsConstraintFixedArray, allow_raw_pointers());
	function("delete_PhysicsConstraintFixedArray", &delete_PhysicsConstraintFixedArray);
	function("PhysicsConstraintFixedArray_getitem", &PhysicsConstraintFixedArray_getitem, allow_raw_pointers());
	function("PhysicsConstraintFixedArray_setitem", &PhysicsConstraintFixedArray_setitem);
	function("new_PhysicsConstraintFixedBuilderArray", &new_PhysicsConstraintFixedBuilderArray, allow_raw_pointers());
	function("delete_PhysicsConstraintFixedBuilderArray", &delete_PhysicsConstraintFixedBuilderArray);
	function("PhysicsConstraintFixedBuilderArray_getitem", &PhysicsConstraintFixedBuilderArray_getitem, allow_raw_pointers());
	function("PhysicsConstraintFixedBuilderArray_setitem", &PhysicsConstraintFixedBuilderArray_setitem);
	function("new_PhysicsConstraintGeneric6DofArray", &new_PhysicsConstraintGeneric6DofArray, allow_raw_pointers());
	function("delete_PhysicsConstraintGeneric6DofArray", &delete_PhysicsConstraintGeneric6DofArray);
	function("PhysicsConstraintGeneric6DofArray_getitem", &PhysicsConstraintGeneric6DofArray_getitem, allow_raw_pointers());
	function("PhysicsConstraintGeneric6DofArray_setitem", &PhysicsConstraintGeneric6DofArray_setitem);
	function("new_PhysicsConstraintGeneric6DofBuilderArray", &new_PhysicsConstraintGeneric6DofBuilderArray, allow_raw_pointers());
	function("delete_PhysicsConstraintGeneric6DofBuilderArray", &delete_PhysicsConstraintGeneric6DofBuilderArray);
	function("PhysicsConstraintGeneric6DofBuilderArray_getitem", &PhysicsConstraintGeneric6DofBuilderArray_getitem, allow_raw_pointers());
	function("PhysicsConstraintGeneric6DofBuilderArray_setitem", &PhysicsConstraintGeneric6DofBuilderArray_setitem);
	function("new_PhysicsConstraintGeneric6DofSpringArray", &new_PhysicsConstraintGeneric6DofSpringArray, allow_raw_pointers());
	function("delete_PhysicsConstraintGeneric6DofSpringArray", &delete_PhysicsConstraintGeneric6DofSpringArray);
	function("PhysicsConstraintGeneric6DofSpringArray_getitem", &PhysicsConstraintGeneric6DofSpringArray_getitem, allow_raw_pointers());
	function("PhysicsConstraintGeneric6DofSpringArray_setitem", &PhysicsConstraintGeneric6DofSpringArray_setitem);
	function("new_PhysicsConstraintGeneric6DofSpringBuilderArray", &new_PhysicsConstraintGeneric6DofSpringBuilderArray, allow_raw_pointers());
	function("delete_PhysicsConstraintGeneric6DofSpringBuilderArray", &delete_PhysicsConstraintGeneric6DofSpringBuilderArray);
	function("PhysicsConstraintGeneric6DofSpringBuilderArray_getitem", &PhysicsConstraintGeneric6DofSpringBuilderArray_getitem, allow_raw_pointers());
	function("PhysicsConstraintGeneric6DofSpringBuilderArray_setitem", &PhysicsConstraintGeneric6DofSpringBuilderArray_setitem);
	function("new_PhysicsConstraintHingeArray", &new_PhysicsConstraintHingeArray, allow_raw_pointers());
	function("delete_PhysicsConstraintHingeArray", &delete_PhysicsConstraintHingeArray);
	function("PhysicsConstraintHingeArray_getitem", &PhysicsConstraintHingeArray_getitem, allow_raw_pointers());
	function("PhysicsConstraintHingeArray_setitem", &PhysicsConstraintHingeArray_setitem);
	function("new_PhysicsConstraintHingeBuilderArray", &new_PhysicsConstraintHingeBuilderArray, allow_raw_pointers());
	function("delete_PhysicsConstraintHingeBuilderArray", &delete_PhysicsConstraintHingeBuilderArray);
	function("PhysicsConstraintHingeBuilderArray_getitem", &PhysicsConstraintHingeBuilderArray_getitem, allow_raw_pointers());
	function("PhysicsConstraintHingeBuilderArray_setitem", &PhysicsConstraintHingeBuilderArray_setitem);
	function("new_PhysicsConstraintPointToPointArray", &new_PhysicsConstraintPointToPointArray, allow_raw_pointers());
	function("delete_PhysicsConstraintPointToPointArray", &delete_PhysicsConstraintPointToPointArray);
	function("PhysicsConstraintPointToPointArray_getitem", &PhysicsConstraintPointToPointArray_getitem, allow_raw_pointers());
	function("PhysicsConstraintPointToPointArray_setitem", &PhysicsConstraintPointToPointArray_setitem);
	function("new_PhysicsConstraintPointToPointBuilderArray", &new_PhysicsConstraintPointToPointBuilderArray, allow_raw_pointers());
	function("delete_PhysicsConstraintPointToPointBuilderArray", &delete_PhysicsConstraintPointToPointBuilderArray);
	function("PhysicsConstraintPointToPointBuilderArray_getitem", &PhysicsConstraintPointToPointBuilderArray_getitem, allow_raw_pointers());
	function("PhysicsConstraintPointToPointBuilderArray_setitem", &PhysicsConstraintPointToPointBuilderArray_setitem);
	function("new_PhysicsConstraintSliderArray", &new_PhysicsConstraintSliderArray, allow_raw_pointers());
	function("delete_PhysicsConstraintSliderArray", &delete_PhysicsConstraintSliderArray);
	function("PhysicsConstraintSliderArray_getitem", &PhysicsConstraintSliderArray_getitem, allow_raw_pointers());
	function("PhysicsConstraintSliderArray_setitem", &PhysicsConstraintSliderArray_setitem);
	function("new_PhysicsConstraintSliderBuilderArray", &new_PhysicsConstraintSliderBuilderArray, allow_raw_pointers());
	function("delete_PhysicsConstraintSliderBuilderArray", &delete_PhysicsConstraintSliderBuilderArray);
	function("PhysicsConstraintSliderBuilderArray_getitem", &PhysicsConstraintSliderBuilderArray_getitem, allow_raw_pointers());
	function("PhysicsConstraintSliderBuilderArray_setitem", &PhysicsConstraintSliderBuilderArray_setitem);
	function("new_PhysicsContactArray", &new_PhysicsContactArray, allow_raw_pointers());
	function("delete_PhysicsContactArray", &delete_PhysicsContactArray);
	function("PhysicsContactArray_getitem", &PhysicsContactArray_getitem, allow_raw_pointers());
	function("PhysicsContactArray_setitem", &PhysicsContactArray_setitem);
	function("new_PhysicsContactBuilderArray", &new_PhysicsContactBuilderArray, allow_raw_pointers());
	function("delete_PhysicsContactBuilderArray", &delete_PhysicsContactBuilderArray);
	function("PhysicsContactBuilderArray_getitem", &PhysicsContactBuilderArray_getitem, allow_raw_pointers());
	function("PhysicsContactBuilderArray_setitem", &PhysicsContactBuilderArray_setitem);
	function("new_PhysicsFieldArray", &new_PhysicsFieldArray, allow_raw_pointers());
	function("delete_PhysicsFieldArray", &delete_PhysicsFieldArray);
	function("PhysicsFieldArray_getitem", &PhysicsFieldArray_getitem, allow_raw_pointers());
	function("PhysicsFieldArray_setitem", &PhysicsFieldArray_setitem);
	function("new_PhysicsFieldBuilderArray", &new_PhysicsFieldBuilderArray, allow_raw_pointers());
	function("delete_PhysicsFieldBuilderArray", &delete_PhysicsFieldBuilderArray);
	function("PhysicsFieldBuilderArray_getitem", &PhysicsFieldBuilderArray_getitem, allow_raw_pointers());
	function("PhysicsFieldBuilderArray_setitem", &PhysicsFieldBuilderArray_setitem);
	function("new_PhysicsRayContactArray", &new_PhysicsRayContactArray, allow_raw_pointers());
	function("delete_PhysicsRayContactArray", &delete_PhysicsRayContactArray);
	function("PhysicsRayContactArray_getitem", &PhysicsRayContactArray_getitem, allow_raw_pointers());
	function("PhysicsRayContactArray_setitem", &PhysicsRayContactArray_setitem);
	function("new_PhysicsRayContactBuilderArray", &new_PhysicsRayContactBuilderArray, allow_raw_pointers());
	function("delete_PhysicsRayContactBuilderArray", &delete_PhysicsRayContactBuilderArray);
	function("PhysicsRayContactBuilderArray_getitem", &PhysicsRayContactBuilderArray_getitem, allow_raw_pointers());
	function("PhysicsRayContactBuilderArray_setitem", &PhysicsRayContactBuilderArray_setitem);
	function("new_PhysicsShapeBoxArray", &new_PhysicsShapeBoxArray, allow_raw_pointers());
	function("delete_PhysicsShapeBoxArray", &delete_PhysicsShapeBoxArray);
	function("PhysicsShapeBoxArray_getitem", &PhysicsShapeBoxArray_getitem, allow_raw_pointers());
	function("PhysicsShapeBoxArray_setitem", &PhysicsShapeBoxArray_setitem);
	function("new_PhysicsShapeBox2DArray", &new_PhysicsShapeBox2DArray, allow_raw_pointers());
	function("delete_PhysicsShapeBox2DArray", &delete_PhysicsShapeBox2DArray);
	function("PhysicsShapeBox2DArray_getitem", &PhysicsShapeBox2DArray_getitem, allow_raw_pointers());
	function("PhysicsShapeBox2DArray_setitem", &PhysicsShapeBox2DArray_setitem);
	function("new_PhysicsShapeBox2DBuilderArray", &new_PhysicsShapeBox2DBuilderArray, allow_raw_pointers());
	function("delete_PhysicsShapeBox2DBuilderArray", &delete_PhysicsShapeBox2DBuilderArray);
	function("PhysicsShapeBox2DBuilderArray_getitem", &PhysicsShapeBox2DBuilderArray_getitem, allow_raw_pointers());
	function("PhysicsShapeBox2DBuilderArray_setitem", &PhysicsShapeBox2DBuilderArray_setitem);
	function("new_PhysicsShapeBoxBuilderArray", &new_PhysicsShapeBoxBuilderArray, allow_raw_pointers());
	function("delete_PhysicsShapeBoxBuilderArray", &delete_PhysicsShapeBoxBuilderArray);
	function("PhysicsShapeBoxBuilderArray_getitem", &PhysicsShapeBoxBuilderArray_getitem, allow_raw_pointers());
	function("PhysicsShapeBoxBuilderArray_setitem", &PhysicsShapeBoxBuilderArray_setitem);
	function("new_PhysicsShapeBvhTriangleMeshArray", &new_PhysicsShapeBvhTriangleMeshArray, allow_raw_pointers());
	function("delete_PhysicsShapeBvhTriangleMeshArray", &delete_PhysicsShapeBvhTriangleMeshArray);
	function("PhysicsShapeBvhTriangleMeshArray_getitem", &PhysicsShapeBvhTriangleMeshArray_getitem, allow_raw_pointers());
	function("PhysicsShapeBvhTriangleMeshArray_setitem", &PhysicsShapeBvhTriangleMeshArray_setitem);
	function("new_PhysicsShapeBvhTriangleMeshBuilderArray", &new_PhysicsShapeBvhTriangleMeshBuilderArray, allow_raw_pointers());
	function("delete_PhysicsShapeBvhTriangleMeshBuilderArray", &delete_PhysicsShapeBvhTriangleMeshBuilderArray);
	function("PhysicsShapeBvhTriangleMeshBuilderArray_getitem", &PhysicsShapeBvhTriangleMeshBuilderArray_getitem, allow_raw_pointers());
	function("PhysicsShapeBvhTriangleMeshBuilderArray_setitem", &PhysicsShapeBvhTriangleMeshBuilderArray_setitem);
	function("new_PhysicsShapeCapsuleArray", &new_PhysicsShapeCapsuleArray, allow_raw_pointers());
	function("delete_PhysicsShapeCapsuleArray", &delete_PhysicsShapeCapsuleArray);
	function("PhysicsShapeCapsuleArray_getitem", &PhysicsShapeCapsuleArray_getitem, allow_raw_pointers());
	function("PhysicsShapeCapsuleArray_setitem", &PhysicsShapeCapsuleArray_setitem);
	function("new_PhysicsShapeCapsuleBuilderArray", &new_PhysicsShapeCapsuleBuilderArray, allow_raw_pointers());
	function("delete_PhysicsShapeCapsuleBuilderArray", &delete_PhysicsShapeCapsuleBuilderArray);
	function("PhysicsShapeCapsuleBuilderArray_getitem", &PhysicsShapeCapsuleBuilderArray_getitem, allow_raw_pointers());
	function("PhysicsShapeCapsuleBuilderArray_setitem", &PhysicsShapeCapsuleBuilderArray_setitem);
	function("new_PhysicsShapeConeArray", &new_PhysicsShapeConeArray, allow_raw_pointers());
	function("delete_PhysicsShapeConeArray", &delete_PhysicsShapeConeArray);
	function("PhysicsShapeConeArray_getitem", &PhysicsShapeConeArray_getitem, allow_raw_pointers());
	function("PhysicsShapeConeArray_setitem", &PhysicsShapeConeArray_setitem);
	function("new_PhysicsShapeConeBuilderArray", &new_PhysicsShapeConeBuilderArray, allow_raw_pointers());
	function("delete_PhysicsShapeConeBuilderArray", &delete_PhysicsShapeConeBuilderArray);
	function("PhysicsShapeConeBuilderArray_getitem", &PhysicsShapeConeBuilderArray_getitem, allow_raw_pointers());
	function("PhysicsShapeConeBuilderArray_setitem", &PhysicsShapeConeBuilderArray_setitem);
	function("new_PhysicsShapeConvexHullArray", &new_PhysicsShapeConvexHullArray, allow_raw_pointers());
	function("delete_PhysicsShapeConvexHullArray", &delete_PhysicsShapeConvexHullArray);
	function("PhysicsShapeConvexHullArray_getitem", &PhysicsShapeConvexHullArray_getitem, allow_raw_pointers());
	function("PhysicsShapeConvexHullArray_setitem", &PhysicsShapeConvexHullArray_setitem);
	function("new_PhysicsShapeConvexHullBuilderArray", &new_PhysicsShapeConvexHullBuilderArray, allow_raw_pointers());
	function("delete_PhysicsShapeConvexHullBuilderArray", &delete_PhysicsShapeConvexHullBuilderArray);
	function("PhysicsShapeConvexHullBuilderArray_getitem", &PhysicsShapeConvexHullBuilderArray_getitem, allow_raw_pointers());
	function("PhysicsShapeConvexHullBuilderArray_setitem", &PhysicsShapeConvexHullBuilderArray_setitem);
	function("new_PhysicsShapeConvexTriangleMeshArray", &new_PhysicsShapeConvexTriangleMeshArray, allow_raw_pointers());
	function("delete_PhysicsShapeConvexTriangleMeshArray", &delete_PhysicsShapeConvexTriangleMeshArray);
	function("PhysicsShapeConvexTriangleMeshArray_getitem", &PhysicsShapeConvexTriangleMeshArray_getitem, allow_raw_pointers());
	function("PhysicsShapeConvexTriangleMeshArray_setitem", &PhysicsShapeConvexTriangleMeshArray_setitem);
	function("new_PhysicsShapeConvexTriangleMeshBuilderArray", &new_PhysicsShapeConvexTriangleMeshBuilderArray, allow_raw_pointers());
	function("delete_PhysicsShapeConvexTriangleMeshBuilderArray", &delete_PhysicsShapeConvexTriangleMeshBuilderArray);
	function("PhysicsShapeConvexTriangleMeshBuilderArray_getitem", &PhysicsShapeConvexTriangleMeshBuilderArray_getitem, allow_raw_pointers());
	function("PhysicsShapeConvexTriangleMeshBuilderArray_setitem", &PhysicsShapeConvexTriangleMeshBuilderArray_setitem);
	function("new_PhysicsShapeCylinderArray", &new_PhysicsShapeCylinderArray, allow_raw_pointers());
	function("delete_PhysicsShapeCylinderArray", &delete_PhysicsShapeCylinderArray);
	function("PhysicsShapeCylinderArray_getitem", &PhysicsShapeCylinderArray_getitem, allow_raw_pointers());
	function("PhysicsShapeCylinderArray_setitem", &PhysicsShapeCylinderArray_setitem);
	function("new_PhysicsShapeCylinderBuilderArray", &new_PhysicsShapeCylinderBuilderArray, allow_raw_pointers());
	function("delete_PhysicsShapeCylinderBuilderArray", &delete_PhysicsShapeCylinderBuilderArray);
	function("PhysicsShapeCylinderBuilderArray_getitem", &PhysicsShapeCylinderBuilderArray_getitem, allow_raw_pointers());
	function("PhysicsShapeCylinderBuilderArray_setitem", &PhysicsShapeCylinderBuilderArray_setitem);
	function("new_PhysicsShapeHeightfieldTerrainArray", &new_PhysicsShapeHeightfieldTerrainArray, allow_raw_pointers());
	function("delete_PhysicsShapeHeightfieldTerrainArray", &delete_PhysicsShapeHeightfieldTerrainArray);
	function("PhysicsShapeHeightfieldTerrainArray_getitem", &PhysicsShapeHeightfieldTerrainArray_getitem, allow_raw_pointers());
	function("PhysicsShapeHeightfieldTerrainArray_setitem", &PhysicsShapeHeightfieldTerrainArray_setitem);
	function("new_PhysicsShapeHeightfieldTerrainBuilderArray", &new_PhysicsShapeHeightfieldTerrainBuilderArray, allow_raw_pointers());
	function("delete_PhysicsShapeHeightfieldTerrainBuilderArray", &delete_PhysicsShapeHeightfieldTerrainBuilderArray);
	function("PhysicsShapeHeightfieldTerrainBuilderArray_getitem", &PhysicsShapeHeightfieldTerrainBuilderArray_getitem, allow_raw_pointers());
	function("PhysicsShapeHeightfieldTerrainBuilderArray_setitem", &PhysicsShapeHeightfieldTerrainBuilderArray_setitem);
	function("new_PhysicsShapeMultiSphereArray", &new_PhysicsShapeMultiSphereArray, allow_raw_pointers());
	function("delete_PhysicsShapeMultiSphereArray", &delete_PhysicsShapeMultiSphereArray);
	function("PhysicsShapeMultiSphereArray_getitem", &PhysicsShapeMultiSphereArray_getitem, allow_raw_pointers());
	function("PhysicsShapeMultiSphereArray_setitem", &PhysicsShapeMultiSphereArray_setitem);
	function("new_PhysicsShapeMultiSphereBuilderArray", &new_PhysicsShapeMultiSphereBuilderArray, allow_raw_pointers());
	function("delete_PhysicsShapeMultiSphereBuilderArray", &delete_PhysicsShapeMultiSphereBuilderArray);
	function("PhysicsShapeMultiSphereBuilderArray_getitem", &PhysicsShapeMultiSphereBuilderArray_getitem, allow_raw_pointers());
	function("PhysicsShapeMultiSphereBuilderArray_setitem", &PhysicsShapeMultiSphereBuilderArray_setitem);
	function("new_PhysicsShapeSphereArray", &new_PhysicsShapeSphereArray, allow_raw_pointers());
	function("delete_PhysicsShapeSphereArray", &delete_PhysicsShapeSphereArray);
	function("PhysicsShapeSphereArray_getitem", &PhysicsShapeSphereArray_getitem, allow_raw_pointers());
	function("PhysicsShapeSphereArray_setitem", &PhysicsShapeSphereArray_setitem);
	function("new_PhysicsShapeSphereBuilderArray", &new_PhysicsShapeSphereBuilderArray, allow_raw_pointers());
	function("delete_PhysicsShapeSphereBuilderArray", &delete_PhysicsShapeSphereBuilderArray);
	function("PhysicsShapeSphereBuilderArray_getitem", &PhysicsShapeSphereBuilderArray_getitem, allow_raw_pointers());
	function("PhysicsShapeSphereBuilderArray_setitem", &PhysicsShapeSphereBuilderArray_setitem);
	function("new_PhysicsShapeStaticPlaneArray", &new_PhysicsShapeStaticPlaneArray, allow_raw_pointers());
	function("delete_PhysicsShapeStaticPlaneArray", &delete_PhysicsShapeStaticPlaneArray);
	function("PhysicsShapeStaticPlaneArray_getitem", &PhysicsShapeStaticPlaneArray_getitem, allow_raw_pointers());
	function("PhysicsShapeStaticPlaneArray_setitem", &PhysicsShapeStaticPlaneArray_setitem);
	function("new_PhysicsShapeStaticPlaneBuilderArray", &new_PhysicsShapeStaticPlaneBuilderArray, allow_raw_pointers());
	function("delete_PhysicsShapeStaticPlaneBuilderArray", &delete_PhysicsShapeStaticPlaneBuilderArray);
	function("PhysicsShapeStaticPlaneBuilderArray_getitem", &PhysicsShapeStaticPlaneBuilderArray_getitem, allow_raw_pointers());
	function("PhysicsShapeStaticPlaneBuilderArray_setitem", &PhysicsShapeStaticPlaneBuilderArray_setitem);
	function("new_PhysicsWorldArray", &new_PhysicsWorldArray, allow_raw_pointers());
	function("delete_PhysicsWorldArray", &delete_PhysicsWorldArray);
	function("PhysicsWorldArray_getitem", &PhysicsWorldArray_getitem, allow_raw_pointers());
	function("PhysicsWorldArray_setitem", &PhysicsWorldArray_setitem);
	function("new_PhysicsWorldBuilderArray", &new_PhysicsWorldBuilderArray, allow_raw_pointers());
	function("delete_PhysicsWorldBuilderArray", &delete_PhysicsWorldBuilderArray);
	function("PhysicsWorldBuilderArray_getitem", &PhysicsWorldBuilderArray_getitem, allow_raw_pointers());
	function("PhysicsWorldBuilderArray_setitem", &PhysicsWorldBuilderArray_setitem);
	function("new_PlaneArray", &new_PlaneArray, allow_raw_pointers());
	function("delete_PlaneArray", &delete_PlaneArray);
	function("PlaneArray_getitem", &PlaneArray_getitem, allow_raw_pointers());
	function("PlaneArray_setitem", &PlaneArray_setitem);
	function("new_PlaneBuilderArray", &new_PlaneBuilderArray, allow_raw_pointers());
	function("delete_PlaneBuilderArray", &delete_PlaneBuilderArray);
	function("PlaneBuilderArray_getitem", &PlaneBuilderArray_getitem, allow_raw_pointers());
	function("PlaneBuilderArray_setitem", &PlaneBuilderArray_setitem);
	function("new_SceneArray", &new_SceneArray, allow_raw_pointers());
	function("delete_SceneArray", &delete_SceneArray);
	function("SceneArray_getitem", &SceneArray_getitem, allow_raw_pointers());
	function("SceneArray_setitem", &SceneArray_setitem);
	function("new_SceneBuilderArray", &new_SceneBuilderArray, allow_raw_pointers());
	function("delete_SceneBuilderArray", &delete_SceneBuilderArray);
	function("SceneBuilderArray_getitem", &SceneBuilderArray_getitem, allow_raw_pointers());
	function("SceneBuilderArray_setitem", &SceneBuilderArray_setitem);
	function("new_SceneStateArray", &new_SceneStateArray, allow_raw_pointers());
	function("delete_SceneStateArray", &delete_SceneStateArray);
	function("SceneStateArray_getitem", &SceneStateArray_getitem, allow_raw_pointers());
	function("SceneStateArray_setitem", &SceneStateArray_setitem);
	function("new_SceneStateBuilderArray", &new_SceneStateBuilderArray, allow_raw_pointers());
	function("delete_SceneStateBuilderArray", &delete_SceneStateBuilderArray);
	function("SceneStateBuilderArray_getitem", &SceneStateBuilderArray_getitem, allow_raw_pointers());
	function("SceneStateBuilderArray_setitem", &SceneStateBuilderArray_setitem);
	function("new_SceneStateMachineArray", &new_SceneStateMachineArray, allow_raw_pointers());
	function("delete_SceneStateMachineArray", &delete_SceneStateMachineArray);
	function("SceneStateMachineArray_getitem", &SceneStateMachineArray_getitem, allow_raw_pointers());
	function("SceneStateMachineArray_setitem", &SceneStateMachineArray_setitem);
	function("new_SceneStateMachineBuilderArray", &new_SceneStateMachineBuilderArray, allow_raw_pointers());
	function("delete_SceneStateMachineBuilderArray", &delete_SceneStateMachineBuilderArray);
	function("SceneStateMachineBuilderArray_getitem", &SceneStateMachineBuilderArray_getitem, allow_raw_pointers());
	function("SceneStateMachineBuilderArray_setitem", &SceneStateMachineBuilderArray_setitem);
	function("new_ShaderProgramArray", &new_ShaderProgramArray, allow_raw_pointers());
	function("delete_ShaderProgramArray", &delete_ShaderProgramArray);
	function("ShaderProgramArray_getitem", &ShaderProgramArray_getitem, allow_raw_pointers());
	function("ShaderProgramArray_setitem", &ShaderProgramArray_setitem);
	function("new_ShaderProgramBuilderArray", &new_ShaderProgramBuilderArray, allow_raw_pointers());
	function("delete_ShaderProgramBuilderArray", &delete_ShaderProgramBuilderArray);
	function("ShaderProgramBuilderArray_getitem", &ShaderProgramBuilderArray_getitem, allow_raw_pointers());
	function("ShaderProgramBuilderArray_setitem", &ShaderProgramBuilderArray_setitem);
	function("new_SkinnerArray", &new_SkinnerArray, allow_raw_pointers());
	function("delete_SkinnerArray", &delete_SkinnerArray);
	function("SkinnerArray_getitem", &SkinnerArray_getitem, allow_raw_pointers());
	function("SkinnerArray_setitem", &SkinnerArray_setitem);
	function("new_SkinnerBuilderArray", &new_SkinnerBuilderArray, allow_raw_pointers());
	function("delete_SkinnerBuilderArray", &delete_SkinnerBuilderArray);
	function("SkinnerBuilderArray_getitem", &SkinnerBuilderArray_getitem, allow_raw_pointers());
	function("SkinnerBuilderArray_setitem", &SkinnerBuilderArray_setitem);
	function("new_SoundBuilderArray", &new_SoundBuilderArray, allow_raw_pointers());
	function("delete_SoundBuilderArray", &delete_SoundBuilderArray);
	function("SoundBuilderArray_getitem", &SoundBuilderArray_getitem, allow_raw_pointers());
	function("SoundBuilderArray_setitem", &SoundBuilderArray_setitem);
	function("new_Sprite2DArray", &new_Sprite2DArray, allow_raw_pointers());
	function("delete_Sprite2DArray", &delete_Sprite2DArray);
	function("Sprite2DArray_getitem", &Sprite2DArray_getitem, allow_raw_pointers());
	function("Sprite2DArray_setitem", &Sprite2DArray_setitem);
	function("new_Sprite2DBuilderArray", &new_Sprite2DBuilderArray, allow_raw_pointers());
	function("delete_Sprite2DBuilderArray", &delete_Sprite2DBuilderArray);
	function("Sprite2DBuilderArray_getitem", &Sprite2DBuilderArray_getitem, allow_raw_pointers());
	function("Sprite2DBuilderArray_setitem", &Sprite2DBuilderArray_setitem);
	function("new_SpriteFrameAtlasArray", &new_SpriteFrameAtlasArray, allow_raw_pointers());
	function("delete_SpriteFrameAtlasArray", &delete_SpriteFrameAtlasArray);
	function("SpriteFrameAtlasArray_getitem", &SpriteFrameAtlasArray_getitem, allow_raw_pointers());
	function("SpriteFrameAtlasArray_setitem", &SpriteFrameAtlasArray_setitem);
	function("new_SpriteFrameAtlasBuilderArray", &new_SpriteFrameAtlasBuilderArray, allow_raw_pointers());
	function("delete_SpriteFrameAtlasBuilderArray", &delete_SpriteFrameAtlasBuilderArray);
	function("SpriteFrameAtlasBuilderArray_getitem", &SpriteFrameAtlasBuilderArray_getitem, allow_raw_pointers());
	function("SpriteFrameAtlasBuilderArray_setitem", &SpriteFrameAtlasBuilderArray_setitem);
	function("new_SteeringBehaviorAlignment", &new_SteeringBehaviorAlignment, allow_raw_pointers());
	function("delete_SteeringBehaviorAlignment", &delete_SteeringBehaviorAlignment);
	function("SteeringBehaviorAlignment_getitem", &SteeringBehaviorAlignment_getitem, allow_raw_pointers());
	function("SteeringBehaviorAlignment_setitem", &SteeringBehaviorAlignment_setitem);
	function("new_SteeringBehaviorAlignmentBuilder", &new_SteeringBehaviorAlignmentBuilder, allow_raw_pointers());
	function("delete_SteeringBehaviorAlignmentBuilder", &delete_SteeringBehaviorAlignmentBuilder);
	function("SteeringBehaviorAlignmentBuilder_getitem", &SteeringBehaviorAlignmentBuilder_getitem, allow_raw_pointers());
	function("SteeringBehaviorAlignmentBuilder_setitem", &SteeringBehaviorAlignmentBuilder_setitem);
	function("new_SteeringBehaviorArrive", &new_SteeringBehaviorArrive, allow_raw_pointers());
	function("delete_SteeringBehaviorArrive", &delete_SteeringBehaviorArrive);
	function("SteeringBehaviorArrive_getitem", &SteeringBehaviorArrive_getitem, allow_raw_pointers());
	function("SteeringBehaviorArrive_setitem", &SteeringBehaviorArrive_setitem);
	function("new_SteeringBehaviorArriveBuilder", &new_SteeringBehaviorArriveBuilder, allow_raw_pointers());
	function("delete_SteeringBehaviorArriveBuilder", &delete_SteeringBehaviorArriveBuilder);
	function("SteeringBehaviorArriveBuilder_getitem", &SteeringBehaviorArriveBuilder_getitem, allow_raw_pointers());
	function("SteeringBehaviorArriveBuilder_setitem", &SteeringBehaviorArriveBuilder_setitem);
	function("new_SteeringBehaviorCohesion", &new_SteeringBehaviorCohesion, allow_raw_pointers());
	function("delete_SteeringBehaviorCohesion", &delete_SteeringBehaviorCohesion);
	function("SteeringBehaviorCohesion_getitem", &SteeringBehaviorCohesion_getitem, allow_raw_pointers());
	function("SteeringBehaviorCohesion_setitem", &SteeringBehaviorCohesion_setitem);
	function("new_SteeringBehaviorCohesionBuilder", &new_SteeringBehaviorCohesionBuilder, allow_raw_pointers());
	function("delete_SteeringBehaviorCohesionBuilder", &delete_SteeringBehaviorCohesionBuilder);
	function("SteeringBehaviorCohesionBuilder_getitem", &SteeringBehaviorCohesionBuilder_getitem, allow_raw_pointers());
	function("SteeringBehaviorCohesionBuilder_setitem", &SteeringBehaviorCohesionBuilder_setitem);
	function("new_SteeringBehaviorEvade", &new_SteeringBehaviorEvade, allow_raw_pointers());
	function("delete_SteeringBehaviorEvade", &delete_SteeringBehaviorEvade);
	function("SteeringBehaviorEvade_getitem", &SteeringBehaviorEvade_getitem, allow_raw_pointers());
	function("SteeringBehaviorEvade_setitem", &SteeringBehaviorEvade_setitem);
	function("new_SteeringBehaviorEvadeBuilder", &new_SteeringBehaviorEvadeBuilder, allow_raw_pointers());
	function("delete_SteeringBehaviorEvadeBuilder", &delete_SteeringBehaviorEvadeBuilder);
	function("SteeringBehaviorEvadeBuilder_getitem", &SteeringBehaviorEvadeBuilder_getitem, allow_raw_pointers());
	function("SteeringBehaviorEvadeBuilder_setitem", &SteeringBehaviorEvadeBuilder_setitem);
	function("new_SteeringBehaviorFlee", &new_SteeringBehaviorFlee, allow_raw_pointers());
	function("delete_SteeringBehaviorFlee", &delete_SteeringBehaviorFlee);
	function("SteeringBehaviorFlee_getitem", &SteeringBehaviorFlee_getitem, allow_raw_pointers());
	function("SteeringBehaviorFlee_setitem", &SteeringBehaviorFlee_setitem);
	function("new_SteeringBehaviorFleeBuilder", &new_SteeringBehaviorFleeBuilder, allow_raw_pointers());
	function("delete_SteeringBehaviorFleeBuilder", &delete_SteeringBehaviorFleeBuilder);
	function("SteeringBehaviorFleeBuilder_getitem", &SteeringBehaviorFleeBuilder_getitem, allow_raw_pointers());
	function("SteeringBehaviorFleeBuilder_setitem", &SteeringBehaviorFleeBuilder_setitem);
	function("new_SteeringBehaviorFollowPath", &new_SteeringBehaviorFollowPath, allow_raw_pointers());
	function("delete_SteeringBehaviorFollowPath", &delete_SteeringBehaviorFollowPath);
	function("SteeringBehaviorFollowPath_getitem", &SteeringBehaviorFollowPath_getitem, allow_raw_pointers());
	function("SteeringBehaviorFollowPath_setitem", &SteeringBehaviorFollowPath_setitem);
	function("new_SteeringBehaviorFollowPathBuilder", &new_SteeringBehaviorFollowPathBuilder, allow_raw_pointers());
	function("delete_SteeringBehaviorFollowPathBuilder", &delete_SteeringBehaviorFollowPathBuilder);
	function("SteeringBehaviorFollowPathBuilder_getitem", &SteeringBehaviorFollowPathBuilder_getitem, allow_raw_pointers());
	function("SteeringBehaviorFollowPathBuilder_setitem", &SteeringBehaviorFollowPathBuilder_setitem);
	function("new_SteeringBehaviorHide", &new_SteeringBehaviorHide, allow_raw_pointers());
	function("delete_SteeringBehaviorHide", &delete_SteeringBehaviorHide);
	function("SteeringBehaviorHide_getitem", &SteeringBehaviorHide_getitem, allow_raw_pointers());
	function("SteeringBehaviorHide_setitem", &SteeringBehaviorHide_setitem);
	function("new_SteeringBehaviorHideBuilder", &new_SteeringBehaviorHideBuilder, allow_raw_pointers());
	function("delete_SteeringBehaviorHideBuilder", &delete_SteeringBehaviorHideBuilder);
	function("SteeringBehaviorHideBuilder_getitem", &SteeringBehaviorHideBuilder_getitem, allow_raw_pointers());
	function("SteeringBehaviorHideBuilder_setitem", &SteeringBehaviorHideBuilder_setitem);
	function("new_SteeringBehaviorInterpose", &new_SteeringBehaviorInterpose, allow_raw_pointers());
	function("delete_SteeringBehaviorInterpose", &delete_SteeringBehaviorInterpose);
	function("SteeringBehaviorInterpose_getitem", &SteeringBehaviorInterpose_getitem, allow_raw_pointers());
	function("SteeringBehaviorInterpose_setitem", &SteeringBehaviorInterpose_setitem);
	function("new_SteeringBehaviorInterposeBuilder", &new_SteeringBehaviorInterposeBuilder, allow_raw_pointers());
	function("delete_SteeringBehaviorInterposeBuilder", &delete_SteeringBehaviorInterposeBuilder);
	function("SteeringBehaviorInterposeBuilder_getitem", &SteeringBehaviorInterposeBuilder_getitem, allow_raw_pointers());
	function("SteeringBehaviorInterposeBuilder_setitem", &SteeringBehaviorInterposeBuilder_setitem);
	function("new_SteeringBehaviorMachineDithered", &new_SteeringBehaviorMachineDithered, allow_raw_pointers());
	function("delete_SteeringBehaviorMachineDithered", &delete_SteeringBehaviorMachineDithered);
	function("SteeringBehaviorMachineDithered_getitem", &SteeringBehaviorMachineDithered_getitem, allow_raw_pointers());
	function("SteeringBehaviorMachineDithered_setitem", &SteeringBehaviorMachineDithered_setitem);
	function("new_SteeringBehaviorMachineDitheredBuilder", &new_SteeringBehaviorMachineDitheredBuilder, allow_raw_pointers());
	function("delete_SteeringBehaviorMachineDitheredBuilder", &delete_SteeringBehaviorMachineDitheredBuilder);
	function("SteeringBehaviorMachineDitheredBuilder_getitem", &SteeringBehaviorMachineDitheredBuilder_getitem, allow_raw_pointers());
	function("SteeringBehaviorMachineDitheredBuilder_setitem", &SteeringBehaviorMachineDitheredBuilder_setitem);
	function("new_SteeringBehaviorMachinePrioritized", &new_SteeringBehaviorMachinePrioritized, allow_raw_pointers());
	function("delete_SteeringBehaviorMachinePrioritized", &delete_SteeringBehaviorMachinePrioritized);
	function("SteeringBehaviorMachinePrioritized_getitem", &SteeringBehaviorMachinePrioritized_getitem, allow_raw_pointers());
	function("SteeringBehaviorMachinePrioritized_setitem", &SteeringBehaviorMachinePrioritized_setitem);
	function("new_SteeringBehaviorMachinePrioritizedBuilder", &new_SteeringBehaviorMachinePrioritizedBuilder, allow_raw_pointers());
	function("delete_SteeringBehaviorMachinePrioritizedBuilder", &delete_SteeringBehaviorMachinePrioritizedBuilder);
	function("SteeringBehaviorMachinePrioritizedBuilder_getitem", &SteeringBehaviorMachinePrioritizedBuilder_getitem, allow_raw_pointers());
	function("SteeringBehaviorMachinePrioritizedBuilder_setitem", &SteeringBehaviorMachinePrioritizedBuilder_setitem);
	function("new_SteeringBehaviorMachineWeighted", &new_SteeringBehaviorMachineWeighted, allow_raw_pointers());
	function("delete_SteeringBehaviorMachineWeighted", &delete_SteeringBehaviorMachineWeighted);
	function("SteeringBehaviorMachineWeighted_getitem", &SteeringBehaviorMachineWeighted_getitem, allow_raw_pointers());
	function("SteeringBehaviorMachineWeighted_setitem", &SteeringBehaviorMachineWeighted_setitem);
	function("new_SteeringBehaviorMachineWeightedBuilder", &new_SteeringBehaviorMachineWeightedBuilder, allow_raw_pointers());
	function("delete_SteeringBehaviorMachineWeightedBuilder", &delete_SteeringBehaviorMachineWeightedBuilder);
	function("SteeringBehaviorMachineWeightedBuilder_getitem", &SteeringBehaviorMachineWeightedBuilder_getitem, allow_raw_pointers());
	function("SteeringBehaviorMachineWeightedBuilder_setitem", &SteeringBehaviorMachineWeightedBuilder_setitem);
	function("new_SteeringBehaviorObstacleAvoidance", &new_SteeringBehaviorObstacleAvoidance, allow_raw_pointers());
	function("delete_SteeringBehaviorObstacleAvoidance", &delete_SteeringBehaviorObstacleAvoidance);
	function("SteeringBehaviorObstacleAvoidance_getitem", &SteeringBehaviorObstacleAvoidance_getitem, allow_raw_pointers());
	function("SteeringBehaviorObstacleAvoidance_setitem", &SteeringBehaviorObstacleAvoidance_setitem);
	function("new_SteeringBehaviorObstacleAvoidanceBuilder", &new_SteeringBehaviorObstacleAvoidanceBuilder, allow_raw_pointers());
	function("delete_SteeringBehaviorObstacleAvoidanceBuilder", &delete_SteeringBehaviorObstacleAvoidanceBuilder);
	function("SteeringBehaviorObstacleAvoidanceBuilder_getitem", &SteeringBehaviorObstacleAvoidanceBuilder_getitem, allow_raw_pointers());
	function("SteeringBehaviorObstacleAvoidanceBuilder_setitem", &SteeringBehaviorObstacleAvoidanceBuilder_setitem);
	function("new_SteeringBehaviorOffsetPursuit", &new_SteeringBehaviorOffsetPursuit, allow_raw_pointers());
	function("delete_SteeringBehaviorOffsetPursuit", &delete_SteeringBehaviorOffsetPursuit);
	function("SteeringBehaviorOffsetPursuit_getitem", &SteeringBehaviorOffsetPursuit_getitem, allow_raw_pointers());
	function("SteeringBehaviorOffsetPursuit_setitem", &SteeringBehaviorOffsetPursuit_setitem);
	function("new_SteeringBehaviorOffsetPursuitBuilder", &new_SteeringBehaviorOffsetPursuitBuilder, allow_raw_pointers());
	function("delete_SteeringBehaviorOffsetPursuitBuilder", &delete_SteeringBehaviorOffsetPursuitBuilder);
	function("SteeringBehaviorOffsetPursuitBuilder_getitem", &SteeringBehaviorOffsetPursuitBuilder_getitem, allow_raw_pointers());
	function("SteeringBehaviorOffsetPursuitBuilder_setitem", &SteeringBehaviorOffsetPursuitBuilder_setitem);
	function("new_SteeringBehaviorPursuit", &new_SteeringBehaviorPursuit, allow_raw_pointers());
	function("delete_SteeringBehaviorPursuit", &delete_SteeringBehaviorPursuit);
	function("SteeringBehaviorPursuit_getitem", &SteeringBehaviorPursuit_getitem, allow_raw_pointers());
	function("SteeringBehaviorPursuit_setitem", &SteeringBehaviorPursuit_setitem);
	function("new_SteeringBehaviorPursuitBuilder", &new_SteeringBehaviorPursuitBuilder, allow_raw_pointers());
	function("delete_SteeringBehaviorPursuitBuilder", &delete_SteeringBehaviorPursuitBuilder);
	function("SteeringBehaviorPursuitBuilder_getitem", &SteeringBehaviorPursuitBuilder_getitem, allow_raw_pointers());
	function("SteeringBehaviorPursuitBuilder_setitem", &SteeringBehaviorPursuitBuilder_setitem);
	function("new_SteeringBehaviorSeek", &new_SteeringBehaviorSeek, allow_raw_pointers());
	function("delete_SteeringBehaviorSeek", &delete_SteeringBehaviorSeek);
	function("SteeringBehaviorSeek_getitem", &SteeringBehaviorSeek_getitem, allow_raw_pointers());
	function("SteeringBehaviorSeek_setitem", &SteeringBehaviorSeek_setitem);
	function("new_SteeringBehaviorSeekBuilder", &new_SteeringBehaviorSeekBuilder, allow_raw_pointers());
	function("delete_SteeringBehaviorSeekBuilder", &delete_SteeringBehaviorSeekBuilder);
	function("SteeringBehaviorSeekBuilder_getitem", &SteeringBehaviorSeekBuilder_getitem, allow_raw_pointers());
	function("SteeringBehaviorSeekBuilder_setitem", &SteeringBehaviorSeekBuilder_setitem);
	function("new_SteeringBehaviorSeparation", &new_SteeringBehaviorSeparation, allow_raw_pointers());
	function("delete_SteeringBehaviorSeparation", &delete_SteeringBehaviorSeparation);
	function("SteeringBehaviorSeparation_getitem", &SteeringBehaviorSeparation_getitem, allow_raw_pointers());
	function("SteeringBehaviorSeparation_setitem", &SteeringBehaviorSeparation_setitem);
	function("new_SteeringBehaviorSeparationBuilder", &new_SteeringBehaviorSeparationBuilder, allow_raw_pointers());
	function("delete_SteeringBehaviorSeparationBuilder", &delete_SteeringBehaviorSeparationBuilder);
	function("SteeringBehaviorSeparationBuilder_getitem", &SteeringBehaviorSeparationBuilder_getitem, allow_raw_pointers());
	function("SteeringBehaviorSeparationBuilder_setitem", &SteeringBehaviorSeparationBuilder_setitem);
	function("new_SteeringBehaviorWallAvoidance", &new_SteeringBehaviorWallAvoidance, allow_raw_pointers());
	function("delete_SteeringBehaviorWallAvoidance", &delete_SteeringBehaviorWallAvoidance);
	function("SteeringBehaviorWallAvoidance_getitem", &SteeringBehaviorWallAvoidance_getitem, allow_raw_pointers());
	function("SteeringBehaviorWallAvoidance_setitem", &SteeringBehaviorWallAvoidance_setitem);
	function("new_SteeringBehaviorWallAvoidanceBuilder", &new_SteeringBehaviorWallAvoidanceBuilder, allow_raw_pointers());
	function("delete_SteeringBehaviorWallAvoidanceBuilder", &delete_SteeringBehaviorWallAvoidanceBuilder);
	function("SteeringBehaviorWallAvoidanceBuilder_getitem", &SteeringBehaviorWallAvoidanceBuilder_getitem, allow_raw_pointers());
	function("SteeringBehaviorWallAvoidanceBuilder_setitem", &SteeringBehaviorWallAvoidanceBuilder_setitem);
	function("new_SteeringBehaviorWander", &new_SteeringBehaviorWander, allow_raw_pointers());
	function("delete_SteeringBehaviorWander", &delete_SteeringBehaviorWander);
	function("SteeringBehaviorWander_getitem", &SteeringBehaviorWander_getitem, allow_raw_pointers());
	function("SteeringBehaviorWander_setitem", &SteeringBehaviorWander_setitem);
	function("new_SteeringBehaviorWanderBuilder", &new_SteeringBehaviorWanderBuilder, allow_raw_pointers());
	function("delete_SteeringBehaviorWanderBuilder", &delete_SteeringBehaviorWanderBuilder);
	function("SteeringBehaviorWanderBuilder_getitem", &SteeringBehaviorWanderBuilder_getitem, allow_raw_pointers());
	function("SteeringBehaviorWanderBuilder_setitem", &SteeringBehaviorWanderBuilder_setitem);
	function("new_StopWatchArray", &new_StopWatchArray, allow_raw_pointers());
	function("delete_StopWatchArray", &delete_StopWatchArray);
	function("StopWatchArray_getitem", &StopWatchArray_getitem, allow_raw_pointers());
	function("StopWatchArray_setitem", &StopWatchArray_setitem);
	function("new_StopWatchBuilderArray", &new_StopWatchBuilderArray, allow_raw_pointers());
	function("delete_StopWatchBuilderArray", &delete_StopWatchBuilderArray);
	function("StopWatchBuilderArray_getitem", &StopWatchBuilderArray_getitem, allow_raw_pointers());
	function("StopWatchBuilderArray_setitem", &StopWatchBuilderArray_setitem);
	function("new_TimerArray", &new_TimerArray, allow_raw_pointers());
	function("delete_TimerArray", &delete_TimerArray);
	function("TimerArray_getitem", &TimerArray_getitem, allow_raw_pointers());
	function("TimerArray_setitem", &TimerArray_setitem);
	function("new_TimerBuilderArray", &new_TimerBuilderArray, allow_raw_pointers());
	function("delete_TimerBuilderArray", &delete_TimerBuilderArray);
	function("TimerBuilderArray_getitem", &TimerBuilderArray_getitem, allow_raw_pointers());
	function("TimerBuilderArray_setitem", &TimerBuilderArray_setitem);
	function("new_ButtonHUDArray", &new_ButtonHUDArray, allow_raw_pointers());
	function("delete_ButtonHUDArray", &delete_ButtonHUDArray);
	function("ButtonHUDArray_getitem", &ButtonHUDArray_getitem, allow_raw_pointers());
	function("ButtonHUDArray_setitem", &ButtonHUDArray_setitem);
	function("new_ButtonHUDBuilderArray", &new_ButtonHUDBuilderArray, allow_raw_pointers());
	function("delete_ButtonHUDBuilderArray", &delete_ButtonHUDBuilderArray);
	function("ButtonHUDBuilderArray_getitem", &ButtonHUDBuilderArray_getitem, allow_raw_pointers());
	function("ButtonHUDBuilderArray_setitem", &ButtonHUDBuilderArray_setitem);
	function("new_CheckboxHUDArray", &new_CheckboxHUDArray, allow_raw_pointers());
	function("delete_CheckboxHUDArray", &delete_CheckboxHUDArray);
	function("CheckboxHUDArray_getitem", &CheckboxHUDArray_getitem, allow_raw_pointers());
	function("CheckboxHUDArray_setitem", &CheckboxHUDArray_setitem);
	function("new_CheckboxHUDBuilderArray", &new_CheckboxHUDBuilderArray, allow_raw_pointers());
	function("delete_CheckboxHUDBuilderArray", &delete_CheckboxHUDBuilderArray);
	function("CheckboxHUDBuilderArray_getitem", &CheckboxHUDBuilderArray_getitem, allow_raw_pointers());
	function("CheckboxHUDBuilderArray_setitem", &CheckboxHUDBuilderArray_setitem);
	function("new_DropdownHUDArray", &new_DropdownHUDArray, allow_raw_pointers());
	function("delete_DropdownHUDArray", &delete_DropdownHUDArray);
	function("DropdownHUDArray_getitem", &DropdownHUDArray_getitem, allow_raw_pointers());
	function("DropdownHUDArray_setitem", &DropdownHUDArray_setitem);
	function("new_DropdownHUDBuilderArray", &new_DropdownHUDBuilderArray, allow_raw_pointers());
	function("delete_DropdownHUDBuilderArray", &delete_DropdownHUDBuilderArray);
	function("DropdownHUDBuilderArray_getitem", &DropdownHUDBuilderArray_getitem, allow_raw_pointers());
	function("DropdownHUDBuilderArray_setitem", &DropdownHUDBuilderArray_setitem);
	function("new_LabelHUDArray", &new_LabelHUDArray, allow_raw_pointers());
	function("delete_LabelHUDArray", &delete_LabelHUDArray);
	function("LabelHUDArray_getitem", &LabelHUDArray_getitem, allow_raw_pointers());
	function("LabelHUDArray_setitem", &LabelHUDArray_setitem);
	function("new_LabelHUDBuilderArray", &new_LabelHUDBuilderArray, allow_raw_pointers());
	function("delete_LabelHUDBuilderArray", &delete_LabelHUDBuilderArray);
	function("LabelHUDBuilderArray_getitem", &LabelHUDBuilderArray_getitem, allow_raw_pointers());
	function("LabelHUDBuilderArray_setitem", &LabelHUDBuilderArray_setitem);
	function("new_SliderHUDArray", &new_SliderHUDArray, allow_raw_pointers());
	function("delete_SliderHUDArray", &delete_SliderHUDArray);
	function("SliderHUDArray_getitem", &SliderHUDArray_getitem, allow_raw_pointers());
	function("SliderHUDArray_setitem", &SliderHUDArray_setitem);
	function("new_SliderHUDBuilderArray", &new_SliderHUDBuilderArray, allow_raw_pointers());
	function("delete_SliderHUDBuilderArray", &delete_SliderHUDBuilderArray);
	function("SliderHUDBuilderArray_getitem", &SliderHUDBuilderArray_getitem, allow_raw_pointers());
	function("SliderHUDBuilderArray_setitem", &SliderHUDBuilderArray_setitem);
	function("new_TextboxHUDArray", &new_TextboxHUDArray, allow_raw_pointers());
	function("delete_TextboxHUDArray", &delete_TextboxHUDArray);
	function("TextboxHUDArray_getitem", &TextboxHUDArray_getitem, allow_raw_pointers());
	function("TextboxHUDArray_setitem", &TextboxHUDArray_setitem);
	function("new_TextboxHUDBuilderArray", &new_TextboxHUDBuilderArray, allow_raw_pointers());
	function("delete_TextboxHUDBuilderArray", &delete_TextboxHUDBuilderArray);
	function("TextboxHUDBuilderArray_getitem", &TextboxHUDBuilderArray_getitem, allow_raw_pointers());
	function("TextboxHUDBuilderArray_setitem", &TextboxHUDBuilderArray_setitem);
	function("new_WorldStateArray", &new_WorldStateArray, allow_raw_pointers());
	function("delete_WorldStateArray", &delete_WorldStateArray);
	function("WorldStateArray_getitem", &WorldStateArray_getitem, allow_raw_pointers());
	function("WorldStateArray_setitem", &WorldStateArray_setitem);
	function("new_WorldStateBuilderArray", &new_WorldStateBuilderArray, allow_raw_pointers());
	function("delete_WorldStateBuilderArray", &delete_WorldStateBuilderArray);
	function("WorldStateBuilderArray_getitem", &WorldStateBuilderArray_getitem, allow_raw_pointers());
	function("WorldStateBuilderArray_setitem", &WorldStateBuilderArray_setitem);
	function("new_WorldStateMachineArray", &new_WorldStateMachineArray, allow_raw_pointers());
	function("delete_WorldStateMachineArray", &delete_WorldStateMachineArray);
	function("WorldStateMachineArray_getitem", &WorldStateMachineArray_getitem, allow_raw_pointers());
	function("WorldStateMachineArray_setitem", &WorldStateMachineArray_setitem);
	function("new_WorldStateMachineBuilderArray", &new_WorldStateMachineBuilderArray, allow_raw_pointers());
	function("delete_WorldStateMachineBuilderArray", &delete_WorldStateMachineBuilderArray);
	function("WorldStateMachineBuilderArray_getitem", &WorldStateMachineBuilderArray_getitem, allow_raw_pointers());
	function("WorldStateMachineBuilderArray_setitem", &WorldStateMachineBuilderArray_setitem);
	function("new_XmlArray", &new_XmlArray, allow_raw_pointers());
	function("delete_XmlArray", &delete_XmlArray);
	function("XmlArray_getitem", &XmlArray_getitem, allow_raw_pointers());
	function("XmlArray_setitem", &XmlArray_setitem);
	function("new_XmlBuilderArray", &new_XmlBuilderArray, allow_raw_pointers());
	function("delete_XmlBuilderArray", &delete_XmlBuilderArray);
	function("XmlBuilderArray_getitem", &XmlBuilderArray_getitem, allow_raw_pointers());
	function("XmlBuilderArray_setitem", &XmlBuilderArray_setitem);
	function("LOCALIZED_TEXT", &LOCALIZED_TEXT);
	function("LOCALIZED_TEXT", &LOCALIZED_TEXT);
	function("LOCALIZED_LANGUAGE", &LOCALIZED_LANGUAGE);
}

